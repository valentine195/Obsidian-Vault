/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RpgManager
});
module.exports = __toCommonJS(main_exports);
var import_obsidian42 = require("obsidian");

// src/controller/Controller.ts
var import_obsidian2 = require("obsidian");

// src/abstracts/AbstractRpgManagerMarkdownRenderChild.ts
var import_obsidian = require("obsidian");
var AbstractRpgManagerMarkdownRenderChild = class extends import_obsidian.MarkdownRenderChild {
  constructor(app2, container) {
    super(container);
    this.app = app2;
    this.container = container;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
};

// src/controller/Controller.ts
var Controller = class extends AbstractRpgManagerMarkdownRenderChild {
  constructor(app2, container, _source, _component, _sourcePath) {
    super(app2, container);
    this._source = _source;
    this._component = _component;
    this._sourcePath = _sourcePath;
    this._isActive = false;
    this._models = [];
    this.componentVersion = void 0;
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => this._onRename(file, oldPath)));
    this.registerEvent(this.app.workspace.on("rpgmanager:refresh-views", this._render.bind(this)));
    this.registerEvent(this.app.workspace.on("rpgmanager:force-refresh-views", (() => {
      this._render(true);
    }).bind(this)));
  }
  _onRename(file, oldPath) {
    return __async(this, null, function* () {
      if (this._sourcePath === oldPath)
        this._sourcePath = file.path;
      this._render();
    });
  }
  _generateModels() {
    this._models = [];
    try {
      const configurations = (0, import_obsidian2.parseYaml)(this._source);
      if (configurations.models.header !== void 0) {
        this._models.push(this._generateModel("Header"));
      }
      if (configurations.models.lists !== void 0) {
        this._models.push(this._generateModel("List", configurations.models.lists));
      }
    } catch (e) {
    }
  }
  _generateModel(modelName, sourceMeta = void 0) {
    return this.factories.models.create(this._currentComponent.campaignSettings, modelName, this._currentComponent, this._source, this._sourcePath, sourceMeta);
  }
  _initialise() {
    return __async(this, null, function* () {
      var _a;
      if (this.componentVersion !== void 0 && this._currentComponent.version === this.componentVersion) {
        return false;
      }
      this.componentVersion = (_a = this._currentComponent.version) != null ? _a : 0 + 0;
      this._generateModels();
      return true;
    });
  }
  _waitForComponentToBeReady() {
    return __async(this, null, function* () {
      const poll = (resolve) => {
        if (this.database.isReady && this._currentComponent.version !== void 0) {
          resolve();
        } else {
          setTimeout((callback) => poll(resolve), 100);
        }
      };
      return new Promise(poll);
    });
  }
  onload() {
    super.onload();
    this._render();
  }
  _render(forceRefresh = false) {
    return __async(this, null, function* () {
      if (this.database === void 0)
        return;
      if (this._currentComponent === void 0) {
        const rpgmComponent = this.app.plugins.getPlugin("rpg-manager").database.readByPath(this._sourcePath);
        if (rpgmComponent === void 0)
          return;
        this._currentComponent = rpgmComponent;
      }
      yield this._waitForComponentToBeReady();
      if (forceRefresh)
        this.componentVersion = void 0;
      if (yield this._initialise()) {
        this.container.empty();
        for (let modelCounter = 0; modelCounter < this._models.length; modelCounter++) {
          yield this._models[modelCounter].generateData().then((data) => {
            data.elements.forEach((element) => {
              const view = this.factories.views.create(this._currentComponent.campaignSettings, element.responseType, this._sourcePath);
              view.render(this.container, element);
            });
          });
        }
        this.container.show();
      }
    });
  }
  _isComponentVisible() {
    return __async(this, null, function* () {
      if (this._currentComponent === void 0) {
        return false;
      }
      if (this._currentComponent.file === void 0) {
        return false;
      }
      yield this.app.workspace.iterateAllLeaves((leaf) => {
        var _a;
        if (leaf.view instanceof import_obsidian2.MarkdownView) {
          const file = (_a = leaf.view) == null ? void 0 : _a.file;
          if (file !== void 0) {
            if (file.path === this._currentComponent.file.path)
              return true;
          }
        }
      });
      return false;
    });
  }
};

// src/components/enums/ComponentType.ts
var ComponentType = /* @__PURE__ */ ((ComponentType2) => {
  ComponentType2[ComponentType2["Campaign"] = 1] = "Campaign";
  ComponentType2[ComponentType2["Adventure"] = 2] = "Adventure";
  ComponentType2[ComponentType2["Act"] = 4] = "Act";
  ComponentType2[ComponentType2["Scene"] = 8] = "Scene";
  ComponentType2[ComponentType2["Session"] = 16] = "Session";
  ComponentType2[ComponentType2["Character"] = 32] = "Character";
  ComponentType2[ComponentType2["NonPlayerCharacter"] = 64] = "NonPlayerCharacter";
  ComponentType2[ComponentType2["Location"] = 128] = "Location";
  ComponentType2[ComponentType2["Event"] = 256] = "Event";
  ComponentType2[ComponentType2["Clue"] = 512] = "Clue";
  ComponentType2[ComponentType2["Faction"] = 1024] = "Faction";
  ComponentType2[ComponentType2["Music"] = 2048] = "Music";
  ComponentType2[ComponentType2["Subplot"] = 4096] = "Subplot";
  return ComponentType2;
})(ComponentType || {});

// src/abstracts/AbstractRpgManager.ts
var AbstractRpgManager = class {
  constructor(app2) {
    this.app = app2;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  set database(database) {
    this.app.plugins.getPlugin("rpg-manager").database = database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
};

// src/factories/abstracts/AbstractFactory.ts
var AbstractFactory = class extends AbstractRpgManager {
};

// src/models/factories/SubModelFactory.ts
var SubModelFactory = class extends AbstractFactory {
  create(subModelType, currentComponent, data, title = void 0, additionalInformation = void 0) {
    return __async(this, null, function* () {
      const subModel = new subModelType(this.app, currentComponent);
      return subModel.generateData(data, title, additionalInformation);
    });
  }
};

// src/responses/abstracts/AbstractContent.ts
var AbstractContent = class extends AbstractRpgManager {
  constructor(app2, content, isInLine = null, additionalInfo = void 0, isEditable = false) {
    super(app2);
    this.additionalInfo = additionalInfo;
    this.isEditable = isEditable;
    this.isInLine = false;
    this.content = content;
    if (isInLine != null) {
      this.isInLine = isInLine;
    }
  }
};

// src/responses/contents/StringContent.ts
var StringContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    container.textContent = this.content != null ? this.content : "";
  }
};

// src/responses/contents/LinkContent.ts
var import_obsidian3 = require("obsidian");
var LinkContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    if (this.content != null) {
      import_obsidian3.MarkdownRenderer.renderMarkdown(this.content.toString(), container, sourcePath, null);
    } else {
      container.textContent = "";
    }
  }
};

// src/responses/contents/NumberContent.ts
var NumberContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    container.textContent = this.content != null ? this.content.toString() : "";
  }
};

// src/responses/contents/ObjectContent.ts
var import_obsidian4 = require("obsidian");
var ObjectContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    if (this.content != null) {
      import_obsidian4.MarkdownRenderer.renderMarkdown(this.content.toString(), container, sourcePath, null);
    } else {
      container.textContent = "";
    }
  }
};

// src/responses/contents/MarkdownContent.ts
var import_obsidian5 = require("obsidian");
var MarkdownContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    import_obsidian5.MarkdownRenderer.renderMarkdown(this.content != null ? this.content : "&nbsp;", container, sourcePath, null);
  }
};

// src/responses/contents/ImageContent.ts
var ImageContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    if (this.content != null && this.content.length > 0) {
      const image = new Image(75, 75);
      image.onerror = (evt) => {
        container.textContent = "";
        return;
      };
      image.onload = (evt) => {
        image.style.objectFit = "cover";
        container.append(image);
        container.style.width = image.style.width;
      };
      image.src = this.content[0].src;
    } else {
      container.textContent = "";
    }
  }
};

// src/responses/contents/SVGContent.ts
var import_obsidian6 = require("obsidian");
var SVGContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    if (this.content != null) {
      if (this.additionalInfo.storyCircleStage !== void 0) {
        const storyCircleStage = this.additionalInfo.storyCircleStage;
        const svgContainer = container.createEl("div");
        (0, import_obsidian6.setIcon)(svgContainer, this.content);
        svgContainer.style.transform = "rotate(" + (+storyCircleStage * 45).toString() + "deg)";
      }
    } else {
      container.textContent = "";
    }
  }
};

// src/responses/contents/DateContent.ts
var import_obsidian7 = require("obsidian");
var DateContent = class extends AbstractContent {
  fillContent(container, sourcePath) {
    if (container === void 0)
      return;
    if (this.content != null) {
      import_obsidian7.MarkdownRenderer.renderMarkdown(this.content, container, sourcePath, null);
    } else {
      container.textContent = "";
    }
  }
};

// src/responses/factories/ContentFactory.ts
var ContentFactory = class extends AbstractFactory {
  create(content, type, isInline = false, additionalInformation = void 0, isEditable = false) {
    switch (type) {
      case 0 /* String */:
        return new StringContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 7 /* Date */:
        return new DateContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 2 /* Link */:
        return new LinkContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 1 /* Number */:
        return new NumberContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 3 /* Object */:
        return new ObjectContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 4 /* Markdown */:
        return new MarkdownContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 5 /* Image */:
        return new ImageContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
      case 6 /* SVG */:
        return new SVGContent(this.app, content, isInline, additionalInformation, isEditable);
        break;
    }
  }
};

// src/templates/factories/FileFactory.ts
var import_obsidian8 = require("obsidian");

// src/components/components/campaign/enums/CampaignSetting.ts
var CampaignSetting = /* @__PURE__ */ ((CampaignSetting2) => {
  CampaignSetting2[CampaignSetting2["Agnostic"] = 0] = "Agnostic";
  CampaignSetting2[CampaignSetting2["Raw"] = 1] = "Raw";
  CampaignSetting2[CampaignSetting2["Vampire"] = 2] = "Vampire";
  return CampaignSetting2;
})(CampaignSetting || {});

// src/templates/factories/FileFactory.ts
var path = require("path");
var FileFactory = class extends AbstractFactory {
  create(settings, type, create, templateName, name, campaignId, adventureId = void 0, actId = void 0, sceneId = void 0, sessionId = void 0, additionalInformation = null) {
    return __async(this, null, function* () {
      let pathSeparator = "";
      try {
        pathSeparator = path.sep;
      } catch (e) {
        pathSeparator = "/";
      }
      let folder = pathSeparator;
      try {
        const campaign = this.app.plugins.getPlugin("rpg-manager").database.readSingle(1 /* Campaign */, campaignId);
        settings = campaign.campaignSettings;
        folder = campaign.folder;
      } catch (e) {
      }
      const template = this.app.plugins.getPlugin("rpg-manager").factories.templates.create(settings, type, templateName, name, campaignId.id, adventureId == null ? void 0 : adventureId.id, actId == null ? void 0 : actId.id, sceneId == null ? void 0 : sceneId.id, sessionId == null ? void 0 : sessionId.id, additionalInformation);
      const fileName = yield this._generateFilePath(type, folder, name, pathSeparator);
      template.generateData().then((data) => {
        if (create) {
          this._createNewFile(data, fileName);
        } else {
          this._editExistingFile(data, fileName);
        }
      });
    });
  }
  _createNewFile(data, fileName) {
    return __async(this, null, function* () {
      const newFile = yield app.vault.create(fileName, data);
      const currentLeaf = app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
      const leaf = app.workspace.getLeaf(currentLeaf != null);
      yield leaf.openFile(newFile);
    });
  }
  _editExistingFile(data, fileName) {
    return __async(this, null, function* () {
      const activeView = app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
      if (activeView != null) {
        const editor = activeView.editor;
        editor.setValue(data + "\n" + editor.getValue());
        let file = activeView.file;
        yield this.app.fileManager.renameFile(file, fileName);
        file = activeView.file;
        app.workspace.getLeaf().openFile(file);
      }
    });
  }
  silentCreate(type, name, campaignId, adventureId = void 0, actId = void 0, sceneId = void 0, sessionId = void 0, additionalInformation = void 0) {
    return __async(this, null, function* () {
      let folder = "";
      let settings = 0 /* Agnostic */;
      let campaign;
      const id = this.factories.id.create(1 /* Campaign */, campaignId);
      if (id !== void 0) {
        try {
          campaign = this.app.plugins.getPlugin("rpg-manager").database.readSingle(1 /* Campaign */, id);
        } catch (e) {
          campaign = void 0;
        }
      }
      if (campaign !== void 0) {
        settings = campaign.campaignSettings;
        folder = campaign.folder;
      }
      const template = this.app.plugins.getPlugin("rpg-manager").factories.templates.create(settings, type, "internal" + ComponentType[type], name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation);
      const fileName = yield this._generateFilePath(type, folder, name, "/");
      const data = yield template.generateData();
      const newFile = yield app.vault.create(fileName, data);
      const leaf = app.workspace.getLeaf(true);
      yield leaf.openFile(newFile);
    });
  }
  _generateFilePath(type, folder, name, pathSeparator) {
    return __async(this, null, function* () {
      if (folder.startsWith(pathSeparator))
        folder = folder.substring(pathSeparator.length);
      if (folder.endsWith(pathSeparator))
        folder = folder.substring(0, folder.length - pathSeparator.length);
      let response = name + ".md";
      if (this.settings.automaticMove) {
        let fullPath;
        if (type !== 1 /* Campaign */) {
          fullPath = folder + pathSeparator + ComponentType[type] + "s";
          if (fullPath.startsWith(pathSeparator))
            fullPath = fullPath.substring(pathSeparator.length);
          const fileOrFolder = yield this.app.vault.getAbstractFileByPath(fullPath);
          if (fileOrFolder == null) {
            try {
              yield this.app.vault.createFolder(fullPath);
            } catch (e) {
            }
          }
        } else {
          fullPath = folder;
          if (fullPath.startsWith(pathSeparator))
            fullPath = fullPath.substring(1);
        }
        response = fullPath + pathSeparator + response;
      }
      return response;
    });
  }
};

// src/modals/abstracts/AbstractModalPart.ts
var AbstractModalPart = class extends AbstractRpgManager {
  constructor(app2, modal) {
    super(app2);
    this.modal = modal;
  }
  prepareAdditionalInformation() {
    return null;
  }
  save(settings, type, create, templateName, name, campaignId, adventureId = void 0, actId = void 0, sceneId = void 0, sessionId = void 0, additionalInformation = null) {
    return __async(this, null, function* () {
      this.factories.files.create(settings, type, create, templateName, name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation);
      return Promise.resolve(void 0);
    });
  }
};

// src/components/components/campaign/modals/CampaignModalPart.ts
var CampaignModalPart = class extends AbstractModalPart {
  constructor(app2, modal) {
    super(app2, modal);
    this._campaigns = this.database.readList(1 /* Campaign */, void 0);
  }
  addElement(contentEl) {
    return __async(this, null, function* () {
      const campaignEl = contentEl.createDiv({ cls: "campaignContainer" });
      if (this.modal.type === 1 /* Campaign */) {
        this.addAdditionalElements();
        this._addNewCampaignElements(campaignEl);
      } else {
        if (this._campaigns.length === 0) {
          const mainContent = this.modal.getContentEl();
          mainContent.empty();
          mainContent.createEl("h2", { cls: "rpgm-modal-title", text: "Main campaign missing" });
          mainContent.createSpan({ cls: "", text: "This Obsidian Vault does not contain a Rpg Manager campaign yet. Before creating a " + ComponentType[this.modal.type] + ", please initialise your first campaign." });
        } else {
          this._childEl = contentEl.createDiv({ cls: "child" });
          this._childEl.id = "CampaignChild";
          this._selectCampaignElements(campaignEl);
        }
      }
      if (this.modal.type === 1 /* Campaign */) {
        this.modal.saver = this;
      }
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
      if (this.modal.type !== 2 /* Adventure */ && this.modal.type !== 16 /* Session */ && this.modal.type !== 4 /* Act */ && this.modal.type !== 8 /* Scene */) {
        this.modal.elementModal = this.factories.modals.create(this.modal.campaignSetting, this.modal.type, this.modal);
        this.modal.elementModal.addElement(containerEl);
      } else {
        if (this.modal.type === 2 /* Adventure */ || this.modal.type === 4 /* Act */ || this.modal.type === 8 /* Scene */) {
          this.modal.adventureModal = this.factories.modals.create(this.modal.campaignSetting, 2 /* Adventure */, this.modal);
          this.modal.adventureModal.addElement(containerEl);
        } else if (this.modal.type === 16 /* Session */) {
          this.modal.sessionModal = this.factories.modals.create(this.modal.campaignSetting, 16 /* Session */, this.modal);
          this.modal.sessionModal.addElement(containerEl);
        }
      }
    });
  }
  validate() {
    return true;
  }
  _addNewCampaignElements(containerEl) {
    if (this.modal.campaignId === void 0) {
      this.modal.campaignId = this.factories.id.create(1 /* Campaign */, 1);
    }
    this._campaigns.forEach((campaign) => {
      if (this.modal.campaignId !== void 0 && campaign.id.campaignId >= this.modal.campaignId.id) {
        this.modal.campaignId.id = campaign.id.campaignId + 1;
      }
    });
    containerEl.createEl("label", { text: "Select Campaign Settings" });
    this._campaignSettingsEl = containerEl.createEl("select");
    Object.keys(CampaignSetting).filter((v) => isNaN(Number(v))).forEach((setting) => {
      const campaignSettingOption = this._campaignSettingsEl.createEl("option", {
        text: setting,
        value: setting
      });
      if (setting === 0 /* Agnostic */.toString()) {
        campaignSettingOption.selected = true;
      }
    });
    this._selectSetting();
    this._campaignSettingsEl.addEventListener("change", (e) => {
      this._selectSetting();
    });
  }
  _selectCampaignElements(containerEl) {
    const groupElement = containerEl.createDiv({ cls: "group" });
    groupElement.createDiv({ cls: "title", text: "Campaign" });
    const selectionContainerEl = groupElement.createDiv({ cls: "container" });
    groupElement.createDiv({ cls: "clear" });
    this._campaignEl = selectionContainerEl.createEl("select");
    if (this._campaigns.length > 1) {
      this._campaignEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
    }
    this._campaigns.forEach((campaign) => {
      const campaignOptionEl = this._campaignEl.createEl("option", {
        text: campaign.file.basename,
        value: campaign.id.campaignId.toString()
      });
      if (this._campaigns.length === 1) {
        campaignOptionEl.selected = true;
        this._selectCampaign();
      }
    });
    this._campaignEl.addEventListener("change", (e) => {
      this._selectCampaign();
    });
    this._campaignErrorEl = containerEl.createEl("p", { cls: "error" });
  }
  _selectSetting() {
    this.modal.campaignSetting = CampaignSetting[this._campaignSettingsEl.value];
  }
  _selectCampaign() {
    const campaignId = this.factories.id.create(1 /* Campaign */, this._campaignEl.value);
    if (campaignId !== void 0)
      this.modal.campaignId = campaignId;
    this._childEl.empty();
    this.loadChild(this._childEl);
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
      if (this.modal.additionalInformationEl.style.display !== "block") {
        this.modal.additionalInformationEl.style.display = "block";
        this.modal.additionalInformationEl.createEl("h2", {
          cls: "rpgm-modal-title",
          text: "Additional Information for the " + ComponentType[this.modal.type]
        });
        this.modal.additionalInformationEl.createEl("label", { text: "Current Date" });
        this._currentDateEl = this.modal.additionalInformationEl.createEl("input", { type: "text" });
      }
    });
  }
  prepareAdditionalInformation() {
    return {
      current: this._currentDateEl.value
    };
  }
};

// src/components/components/adventure/modals/AdventureModalPart.ts
var AdventureModalPart = class extends AbstractModalPart {
  constructor(app2, modal) {
    super(app2, modal);
    if (this.modal.adventureId === void 0) {
      this.modal.adventureId = this.factories.id.create(2 /* Adventure */, this.modal.campaignId.id);
      this.modal.adventureId.id = 0;
    }
    this._adventures = this.database.readList(2 /* Adventure */, this.modal.campaignId);
  }
  addElement(contentEl) {
    return __async(this, null, function* () {
      const adventureEl = contentEl.createDiv({ cls: "adventureContainer" });
      if (this.modal.type === 2 /* Adventure */) {
        this.addAdditionalElements();
        this._addNewAdventureElements(adventureEl);
      } else {
        if (this._adventures.length === 0) {
          const mainContent = this.modal.getContentEl();
          mainContent.empty();
          mainContent.createEl("h2", { cls: "rpgm-modal-title", text: "Adventures missing" });
          mainContent.createSpan({ cls: "", text: "This Obsidian Vault does not contain a Rpg Manager Adventure for the selected campaign. Before creating a " + ComponentType[this.modal.type] + ", please initialise your first adventure for the campaign." });
        } else {
          this._childEl = contentEl.createDiv({ cls: "child" });
          this._childEl.id = "AdventureChild";
          this._selectAdventureElements(adventureEl);
        }
      }
      if (this.modal.type === 2 /* Adventure */) {
        this.modal.saver = this;
        this.modal.enableButton();
      }
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
      this.modal.actModal = this.factories.modals.create(this.modal.campaignSetting, 4 /* Act */, this.modal);
      this.modal.actModal.addElement(containerEl);
    });
  }
  validate() {
    var _a;
    if (((_a = this.modal.adventureId) == null ? void 0 : _a.id) === 0)
      this.modal.adventureId.id = 1;
    return true;
  }
  _addNewAdventureElements(containerEl) {
    this._adventures.forEach((adventure) => {
      var _a, _b, _c;
      if (this.modal.adventureId !== void 0 && ((_a = adventure.id.adventureId) != null ? _a : 0) >= ((_b = this.modal.adventureId.id) != null ? _b : 0)) {
        this.modal.adventureId.id = ((_c = adventure.id.adventureId) != null ? _c : 0) + 1;
      }
    });
  }
  _selectAdventureElements(containerEl) {
    const groupElement = containerEl.createDiv({ cls: "group" });
    groupElement.createDiv({ cls: "title", text: "Adventure" });
    const selectionContainerEl = groupElement.createDiv({ cls: "container" });
    groupElement.createDiv({ cls: "clear" });
    this._adventureEl = selectionContainerEl.createEl("select");
    if (this._adventures.length > 1) {
      this._adventureEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
    }
    this._adventures.forEach((adventure) => {
      var _a, _b;
      const adventureOptionEl = this._adventureEl.createEl("option", {
        text: adventure.file.basename,
        value: (_a = adventure.id.adventureId) == null ? void 0 : _a.toString()
      });
      if (this._adventures.length === 1 || ((_b = this.modal.adventureId) == null ? void 0 : _b.id) === adventure.id.adventureId) {
        adventureOptionEl.selected = true;
        this._selectAdventure();
      }
    });
    this._adventureEl.addEventListener("change", (e) => {
      this._selectAdventure();
    });
    this._adventureErrorEl = containerEl.createEl("p", { cls: "error" });
  }
  _selectAdventure() {
    if (this.modal.adventureId !== void 0) {
      this.modal.adventureId.id = +this._adventureEl.value;
    }
    this._childEl.empty();
    this.loadChild(this._childEl);
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/act/modals/ActModalPart.ts
var ActModalPart = class extends AbstractModalPart {
  constructor(app2, modal) {
    var _a;
    super(app2, modal);
    if (this.modal.actId === void 0) {
      this.modal.actId = this.factories.id.create(4 /* Act */, this.modal.campaignId.id, (_a = this.modal.adventureId) == null ? void 0 : _a.id);
      this.modal.actId.id = 0;
    }
    this._allAct = this.database.read((component) => component.id.type === 4 /* Act */ && component.id.campaignId === this.modal.campaignId.id);
    this._acts = this.database.read((component) => {
      var _a2;
      return component.id.type === 4 /* Act */ && component.id.campaignId === this.modal.campaignId.id && component.id.adventureId === ((_a2 = this.modal.adventureId) == null ? void 0 : _a2.id);
    });
  }
  addElement(contentEl) {
    return __async(this, null, function* () {
      const actEl = contentEl.createDiv({ cls: "actContainer" });
      if (this.modal.type === 4 /* Act */) {
        this._addNewActElements(actEl);
      } else {
        if (this._acts.length === 0) {
          const mainContent = this.modal.getContentEl();
          mainContent.empty();
          mainContent.createEl("h2", { cls: "rpgm-modal-title", text: "Acts missing" });
          mainContent.createSpan({ cls: "", text: "This Obsidian Vault does not contain a Rpg Manager Act for the selected adventure. Before creating a " + ComponentType[this.modal.type] + ", please initialise your first act for the adventure." });
        } else {
          this._childEl = contentEl.createDiv({ cls: "child" });
          this._childEl.id = "ActChild";
          this._selectActElements(actEl);
        }
      }
      if (this.modal.type === 4 /* Act */) {
        this.modal.saver = this;
        this.modal.enableButton();
      }
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
      this.modal.sceneModal = this.factories.modals.create(this.modal.campaignSetting, 8 /* Scene */, this.modal);
      this.modal.sceneModal.addElement(containerEl);
    });
  }
  validate() {
    var _a;
    if (((_a = this.modal.actId) == null ? void 0 : _a.id) === 0)
      this.modal.actId.id = 1;
    return true;
  }
  _addNewActElements(containerEl) {
    this._allAct.forEach((component) => {
      var _a, _b, _c;
      if (this.modal.actId !== void 0 && ((_a = component.id.actId) != null ? _a : 0) >= ((_b = this.modal.actId.id) != null ? _b : 0)) {
        this.modal.actId.id = ((_c = component.id.actId) != null ? _c : 0) + 1;
      }
    });
  }
  _selectActElements(containerEl) {
    const groupElement = containerEl.createDiv({ cls: "group" });
    groupElement.createDiv({ cls: "title", text: "Act" });
    const selectionContainerEl = groupElement.createDiv({ cls: "container" });
    groupElement.createDiv({ cls: "clear" });
    this._actEl = selectionContainerEl.createEl("select");
    if (this._acts.length > 1) {
      this._actEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
    }
    this._acts.forEach((act) => {
      var _a, _b;
      const actOptionEl = this._actEl.createEl("option", {
        text: act.file.basename,
        value: (_a = act.id.actId) == null ? void 0 : _a.toString()
      });
      if (this._acts.length === 1 || ((_b = this.modal.actId) == null ? void 0 : _b.id) === act.id.actId) {
        actOptionEl.selected = true;
        this._selectAct();
      }
    });
    this._actEl.addEventListener("change", (e) => {
      this._selectAct();
    });
    this._actErrorEl = containerEl.createEl("p", { cls: "error" });
  }
  _selectAct() {
    var _a;
    if (this.modal.actId === void 0) {
      this.modal.actId = this.factories.id.create(2 /* Adventure */, this.modal.campaignId.id, (_a = this.modal.adventureId) == null ? void 0 : _a.id);
    }
    if (this.modal.actId !== void 0) {
      this.modal.actId.id = +this._actEl.value;
    }
    this._childEl.empty();
    this.loadChild(this._childEl);
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/scene/modals/SceneModalPart.ts
var SceneModalPart = class extends AbstractModalPart {
  constructor(app2, modal) {
    var _a, _b;
    super(app2, modal);
    this.modal.sceneId = this.factories.id.create(8 /* Scene */, this.modal.campaignId.id, (_a = this.modal.adventureId) == null ? void 0 : _a.id, (_b = this.modal.actId) == null ? void 0 : _b.id);
    this.modal.sceneId.id = 0;
    if (this.modal.adventureId != null && this.modal.actId != null) {
      this._scenes = this.database.readList(8 /* Scene */, this.modal.actId);
    } else {
      this._scenes = [];
    }
  }
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "sceneContainer" });
      this._scenes.forEach((scene) => {
        var _a, _b, _c;
        if (this.modal.sceneId !== void 0 && ((_a = scene.id.sceneId) != null ? _a : 0) >= ((_b = this.modal.sceneId.id) != null ? _b : 0)) {
          this.modal.sceneId.id = ((_c = scene.id.sceneId) != null ? _c : 0) + 1;
        }
      });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    var _a;
    if (((_a = this.modal.sceneId) == null ? void 0 : _a.id) === 0)
      this.modal.sceneId.id = 1;
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/character/modals/CharacterModalPart.ts
var CharacterModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "characterContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/clue/modals/ClueModalPart.ts
var ClueModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "clueContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/event/modals/EventModalPart.ts
var EventModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "eventContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/faction/modals/FactionModalPart.ts
var FactionModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "factionContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/location/modals/LocationModalPart.ts
var LocationModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "locationContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/character/modals/NonPlayerCharacterModalPart.ts
var NonPlayerCharacterModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "characterContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/music/modals/MusicModalPart.ts
var MusicModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "musicContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/session/modals/SessionModalPart.ts
var SessionModalPart = class extends AbstractModalPart {
  constructor(app2, modal) {
    super(app2, modal);
    this.modal.sessionId = this.factories.id.create(16 /* Session */, this.modal.campaignId.id);
    this.modal.sessionId.id = 0;
    this._sessions = this.database.readList(16 /* Session */, this.modal.campaignId);
  }
  addElement(contentEl) {
    return __async(this, null, function* () {
      const sessionEl = contentEl.createDiv({ cls: "sessionContainer" });
      this.addAdditionalElements();
      this._addNewAdventureElements(sessionEl);
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    var _a;
    if (((_a = this.modal.sessionId) == null ? void 0 : _a.id) === 0)
      this.modal.sessionId.id = 1;
    return true;
  }
  _addNewAdventureElements(containerEl) {
    this._sessions.forEach((session) => {
      var _a, _b, _c;
      if (this.modal.sessionId !== void 0 && ((_a = session.id.sessionId) != null ? _a : 0) >= ((_b = this.modal.sessionId.id) != null ? _b : 0)) {
        this.modal.sessionId.id = ((_c = session.id.sessionId) != null ? _c : 0) + 1;
      }
    });
  }
  _selectSession() {
    if (this.modal.sessionId !== void 0) {
      this.modal.sessionId.id = +this._sessionEl.value;
    }
    this._childEl.empty();
    this.loadChild(this._childEl);
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/components/components/subplot/modals/SubplotModalPart.ts
var SubplotModalPart = class extends AbstractModalPart {
  addElement(contentEl) {
    return __async(this, null, function* () {
      contentEl.createDiv({ cls: "subplotContainer" });
      this.modal.saver = this;
      this.modal.enableButton();
    });
  }
  loadChild(containerEl) {
    return __async(this, null, function* () {
    });
  }
  validate() {
    return true;
  }
  addAdditionalElements() {
    return __async(this, null, function* () {
    });
  }
};

// src/modals/factories/ModalFactory.ts
var ModalFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
    this._modalTypeMap = /* @__PURE__ */ new Map();
    this._modalTypeMap.set("AgnosticCampaign", CampaignModalPart);
    this._modalTypeMap.set("AgnosticAdventure", AdventureModalPart);
    this._modalTypeMap.set("AgnosticAct", ActModalPart);
    this._modalTypeMap.set("AgnosticScene", SceneModalPart);
    this._modalTypeMap.set("AgnosticCharacter", CharacterModalPart);
    this._modalTypeMap.set("AgnosticClue", ClueModalPart);
    this._modalTypeMap.set("AgnosticEvent", EventModalPart);
    this._modalTypeMap.set("AgnosticFaction", FactionModalPart);
    this._modalTypeMap.set("AgnosticLocation", LocationModalPart);
    this._modalTypeMap.set("AgnosticNonPlayerCharacter", NonPlayerCharacterModalPart);
    this._modalTypeMap.set("AgnosticMusic", MusicModalPart);
    this._modalTypeMap.set("AgnosticSession", SessionModalPart);
    this._modalTypeMap.set("AgnosticSubplot", SubplotModalPart);
    this._modalTypeMap.set("AgnosticSceneTypeDescription", SubplotModalPart);
  }
  create(settings, type, modal) {
    let modalKey = CampaignSetting[settings] + ComponentType[type];
    if (!this._modalTypeMap.has(modalKey))
      modalKey = CampaignSetting[0 /* Agnostic */] + ComponentType[type];
    if (!this._modalTypeMap.has(modalKey))
      throw new Error("Type of modal " + CampaignSetting[settings] + ComponentType[type] + " cannot be found");
    return new (this._modalTypeMap.get(modalKey))(this.app, modal);
  }
};

// src/models/abstracts/AbstractSubModel.ts
var AbstractSubModel = class extends AbstractRpgManager {
  constructor(app2, currentComponent) {
    super(app2);
    this.currentComponent = currentComponent;
  }
};

// src/responses/abstracts/AbstractResponse.ts
var AbstractResponse = class extends AbstractRpgManager {
  constructor(app2, currentComponent) {
    super(app2);
    this.currentComponent = currentComponent;
  }
  addTitle(title) {
    this.title = title;
  }
};

// src/responses/enums/ResponseType.ts
var ResponseType = /* @__PURE__ */ ((ResponseType2) => {
  ResponseType2[ResponseType2["Table"] = 0] = "Table";
  ResponseType2[ResponseType2["Breadcrumb"] = 1] = "Breadcrumb";
  ResponseType2[ResponseType2["Header"] = 2] = "Header";
  ResponseType2[ResponseType2["AbtPlot"] = 3] = "AbtPlot";
  ResponseType2[ResponseType2["StoryCirclePlot"] = 4] = "StoryCirclePlot";
  ResponseType2[ResponseType2["RawCharacterRecordSheet"] = 5] = "RawCharacterRecordSheet";
  ResponseType2[ResponseType2["ActHeader"] = 6] = "ActHeader";
  ResponseType2[ResponseType2["AdventureHeader"] = 7] = "AdventureHeader";
  ResponseType2[ResponseType2["CampaignHeader"] = 8] = "CampaignHeader";
  ResponseType2[ResponseType2["CharacterHeader"] = 9] = "CharacterHeader";
  ResponseType2[ResponseType2["ClueHeader"] = 10] = "ClueHeader";
  ResponseType2[ResponseType2["EventHeader"] = 11] = "EventHeader";
  ResponseType2[ResponseType2["FactionHeader"] = 12] = "FactionHeader";
  ResponseType2[ResponseType2["LocationHeader"] = 13] = "LocationHeader";
  ResponseType2[ResponseType2["MusicHeader"] = 14] = "MusicHeader";
  ResponseType2[ResponseType2["SceneHeader"] = 15] = "SceneHeader";
  ResponseType2[ResponseType2["SessionHeader"] = 16] = "SessionHeader";
  ResponseType2[ResponseType2["SubplotHeader"] = 17] = "SubplotHeader";
  return ResponseType2;
})(ResponseType || {});

// src/responses/ResponseHeader.ts
var ResponseHeader = class extends AbstractResponse {
  constructor(app2, currentComponent) {
    super(app2, currentComponent);
    this.responseType = 2 /* Header */;
    this.elements = [];
    this.images = [];
  }
  addElement(element) {
    this.elements.push(element);
  }
};

// src/responses/ResponseHeaderElement.ts
var ResponseHeaderElement = class extends AbstractResponse {
  constructor(app2, currentComponent, title, content, type, additionalInformation = void 0) {
    super(app2, currentComponent);
    this.title = title;
    this.type = type;
    this.additionalInformation = additionalInformation;
    this.value = this.factories.contents.create(content, 4 /* Markdown */);
  }
};

// src/models/abstracts/AbstractHeaderSubModel.ts
var AbstractHeaderSubModel = class extends AbstractSubModel {
  initialiseData(relationship) {
    if (relationship.component === void 0)
      return false;
    this.data = relationship.component;
    this.synopsis = '<span class="rpgm-missing">Synopsis missing</span>';
    this.synopsisTitle = "Synopsis";
    return true;
  }
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      const response = new ResponseHeader(this.app, this.currentComponent);
      response.link = this.factories.contents.create(this.data.link, 2 /* Link */);
      response.name = this.data.file.basename;
      if (this.data.synopsis != null && this.data.synopsis != "") {
        this.synopsis = this.data.synopsis;
      }
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, this.synopsisTitle, this.synopsis, 1 /* Long */, { editableField: "data.synopsis" }));
      return response;
    });
  }
  completeData(response) {
    response.images = this.data.images;
    return response;
  }
};

// src/plots/enums/AbtStage.ts
var AbtStage = /* @__PURE__ */ ((AbtStage2) => {
  AbtStage2[AbtStage2["Need"] = 0] = "Need";
  AbtStage2[AbtStage2["And"] = 1] = "And";
  AbtStage2[AbtStage2["But"] = 2] = "But";
  AbtStage2[AbtStage2["Therefore"] = 3] = "Therefore";
  return AbtStage2;
})(AbtStage || {});

// src/components/components/act/models/ActHeaderSubModel.ts
var ActHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(ActHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 4 /* Act */;
      response.responseType = 6 /* ActHeader */;
      if (this.settings.usePlotStructures) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "ABT Stage", this.data.abtStage !== void 0 ? AbtStage[this.data.abtStage] : "", 6 /* AbtSelector */, {
          id: this.data.id,
          file: this.data.file
        }));
      }
      if (this.settings.useSceneAnalyser) {
        const analyser = this.factories.analyser.createAct(this.data, this.data.abtStage);
        if (analyser.scenesCount > 0) {
          response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Analyser", this.data.abtStage !== void 0 ? AbtStage[this.data.abtStage] : "", 11 /* SceneAnalyser */, {
            id: this.data.id,
            file: this.data.file,
            sceneAnalyser: analyser
          }));
        }
      }
      response.metadata = { actId: this.data.id, sourceMeta: additionalInformation };
      return this.completeData(response);
    });
  }
};

// src/components/abstracts/AbstractComponentData.ts
var import_obsidian9 = require("obsidian");
var _AbstractComponentData = class extends AbstractRpgManager {
  constructor(app2, campaignSettings, id, file) {
    super(app2);
    this.campaignSettings = campaignSettings;
    this.id = id;
    this.file = file;
    this.metadata = {};
    this.stage = 3 /* Element */;
    this.version = void 0;
    _AbstractComponentData.initialiseRoots(this.app);
  }
  static initialiseRoots(app2) {
    const file = app2.vault.getAbstractFileByPath("/");
    this.root = app2.vault.getResourcePath(file);
    if (this.root.includes("?"))
      this.root = this.root.substring(0, this.root.lastIndexOf("?"));
    if (!this.root.endsWith("/"))
      this.root += "/";
  }
  get campaign() {
    if (this.id.type === 1 /* Campaign */)
      return this;
    return this.database.readSingle(1 /* Campaign */, this.id);
  }
  get alias() {
    var _a;
    const response = [];
    const metadata = this.app.metadataCache.getFileCache(this.file);
    if (metadata == null)
      return response;
    if (((_a = metadata.frontmatter) == null ? void 0 : _a.alias) != void 0) {
      metadata.frontmatter.alias.forEach((alias) => {
        response.push(alias);
      });
    }
    return response;
  }
  get synopsis() {
    var _a, _b;
    return (_b = (_a = this.metadata) == null ? void 0 : _a.data) == null ? void 0 : _b.synopsis;
  }
  get images() {
    var _a, _b, _c, _d;
    const response = [];
    if (((_b = (_a = this.metadata) == null ? void 0 : _a.data) == null ? void 0 : _b.images) != void 0 && Array.isArray((_d = (_c = this.metadata) == null ? void 0 : _c.data) == null ? void 0 : _d.images)) {
      this.metadata.data.images.forEach((imageMetadata) => {
        const image = this.factories.image.create(imageMetadata.path, imageMetadata.caption);
        if (image !== void 0)
          response.push(image);
      });
    }
    return response;
  }
  get isComplete() {
    var _a, _b;
    return ((_b = (_a = this.metadata) == null ? void 0 : _a.data) == null ? void 0 : _b.complete) !== false;
  }
  _getImage(basename) {
    const folder = this.settings.imagesFolder !== void 0 && this.settings.imagesFolder !== "" ? this.settings.imagesFolder : this.app.vault.config.attachmentFolderPath;
    const initialFolder = this.app.vault.getAbstractFileByPath(folder);
    if (initialFolder == void 0 || !(initialFolder instanceof import_obsidian9.TFolder))
      return void 0;
    const response = this._getImageFromFolder(basename, initialFolder);
    if (response === void 0)
      return void 0;
    if (_AbstractComponentData.root === void 0)
      _AbstractComponentData.initialiseRoots(this.app);
    return _AbstractComponentData.root + response;
  }
  _getImageFromFolder(basename, folder) {
    const filesInFolder = this.app.vault.getFiles().filter((file) => file.parent === folder && file.basename.toLowerCase() === basename.toLowerCase() && _AbstractComponentData.imageExtensions.includes(file.extension));
    if (filesInFolder.length !== 0)
      return filesInFolder[0].path;
    const subFolders = folder.children.filter((file) => file instanceof import_obsidian9.TFolder);
    for (let index = 0; index < subFolders.length; index++) {
      const subFolder = subFolders[index];
      if (subFolder instanceof import_obsidian9.TFolder) {
        const image = this._getImageFromFolder(basename, subFolder);
        if (image !== void 0)
          return image;
      }
    }
    return void 0;
  }
};
var AbstractComponentData = _AbstractComponentData;
AbstractComponentData.imageExtensions = ["jpeg", "jpg", "png", "webp"];

// src/plots/AbtPlot.ts
var AbtPlot = class {
  constructor(_metadata) {
    this._metadata = _metadata;
  }
  get and() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.abt) == null ? void 0 : _b.and) != null ? _c : "";
  }
  get but() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.abt) == null ? void 0 : _b.but) != null ? _c : "";
  }
  get isEmpty() {
    return this.need === "" && this.and === "" && this.but === "" && this.therefore === "";
  }
  get need() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.abt) == null ? void 0 : _b.need) != null ? _c : "";
  }
  get therefore() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.abt) == null ? void 0 : _b.therefore) != null ? _c : "";
  }
};

// src/plots/StoryCirclePlot.ts
var StoryCirclePlot = class {
  constructor(_metadata) {
    this._metadata = _metadata;
  }
  get change() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.change) != null ? _c : "";
  }
  get find() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.find) != null ? _c : "";
  }
  get go() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.go) != null ? _c : "";
  }
  get isEmpty() {
    return this.you === "" && this.need === "" && this.go === "" && this.search === "" && this.find === "" && this.take === "" && this.return === "" && this.change === "";
  }
  get need() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.need) != null ? _c : "";
  }
  get return() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.return) != null ? _c : "";
  }
  get search() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.search) != null ? _c : "";
  }
  get take() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.take) != null ? _c : "";
  }
  get you() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata.plot) == null ? void 0 : _a.storycircle) == null ? void 0 : _b.you) != null ? _c : "";
  }
};

// src/relationships/enums/RelationshipType.ts
var RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {
  RelationshipType2[RelationshipType2["Reversed"] = 1] = "Reversed";
  RelationshipType2[RelationshipType2["Bidirectional"] = 2] = "Bidirectional";
  RelationshipType2[RelationshipType2["Unidirectional"] = 4] = "Unidirectional";
  RelationshipType2[RelationshipType2["Parent"] = 8] = "Parent";
  RelationshipType2[RelationshipType2["Child"] = 16] = "Child";
  RelationshipType2[RelationshipType2["Hierarchy"] = 32] = "Hierarchy";
  RelationshipType2[RelationshipType2["Undefined"] = 64] = "Undefined";
  return RelationshipType2;
})(RelationshipType || {});

// node_modules/ts-md5/dist/esm/md5.js
var Md5 = class {
  constructor() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state = new Int32Array(4);
    this._buffer = new ArrayBuffer(68);
    this._buffer8 = new Uint8Array(this._buffer, 0, 68);
    this._buffer32 = new Uint32Array(this._buffer, 0, 17);
    this.start();
  }
  static hashStr(str, raw = false) {
    return this.onePassHasher.start().appendStr(str).end(raw);
  }
  static hashAsciiStr(str, raw = false) {
    return this.onePassHasher.start().appendAsciiStr(str).end(raw);
  }
  static _hex(x) {
    const hc = Md5.hexChars;
    const ho = Md5.hexOut;
    let n2;
    let offset2;
    let j;
    let i;
    for (i = 0; i < 4; i += 1) {
      offset2 = i * 8;
      n2 = x[i];
      for (j = 0; j < 8; j += 2) {
        ho[offset2 + 1 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
        ho[offset2 + 0 + j] = hc.charAt(n2 & 15);
        n2 >>>= 4;
      }
    }
    return ho.join("");
  }
  static _md5cycle(x, k) {
    let a = x[0];
    let b = x[1];
    let c = x[2];
    let d = x[3];
    a += (b & c | ~b & d) + k[0] - 680876936 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[1] - 389564586 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[2] + 606105819 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[4] - 176418897 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[7] - 45705983 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[10] - 42063 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[13] - 40341101 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & d | c & ~d) + k[1] - 165796510 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[11] + 643717713 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[0] - 373897302 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[5] - 701558691 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[10] + 38016083 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[15] - 660478335 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[4] - 405537848 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[9] + 568446438 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[3] - 187363961 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[2] - 51403784 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b ^ c ^ d) + k[5] - 378558 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[14] - 35309556 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[7] - 155497632 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[13] + 681279174 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[0] - 358537222 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[3] - 722521979 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[6] + 76029189 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[9] - 640364487 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[12] - 421815835 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[15] + 530742520 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[2] - 995338651 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    x[0] = a + x[0] | 0;
    x[1] = b + x[1] | 0;
    x[2] = c + x[2] | 0;
    x[3] = d + x[3] | 0;
  }
  start() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state.set(Md5.stateIdentity);
    return this;
  }
  appendStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let code;
    let i;
    for (i = 0; i < str.length; i += 1) {
      code = str.charCodeAt(i);
      if (code < 128) {
        buf8[bufLen++] = code;
      } else if (code < 2048) {
        buf8[bufLen++] = (code >>> 6) + 192;
        buf8[bufLen++] = code & 63 | 128;
      } else if (code < 55296 || code > 56319) {
        buf8[bufLen++] = (code >>> 12) + 224;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      } else {
        code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
        if (code > 1114111) {
          throw new Error("Unicode standard supports code points up to U+10FFFF");
        }
        buf8[bufLen++] = (code >>> 18) + 240;
        buf8[bufLen++] = code >>> 12 & 63 | 128;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      }
      if (bufLen >= 64) {
        this._dataLength += 64;
        Md5._md5cycle(this._state, buf32);
        bufLen -= 64;
        buf32[0] = buf32[16];
      }
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendAsciiStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i;
    let j = 0;
    for (; ; ) {
      i = Math.min(str.length - j, 64 - bufLen);
      while (i--) {
        buf8[bufLen++] = str.charCodeAt(j++);
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendByteArray(input) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i;
    let j = 0;
    for (; ; ) {
      i = Math.min(input.length - j, 64 - bufLen);
      while (i--) {
        buf8[bufLen++] = input[j++];
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  getState() {
    const s2 = this._state;
    return {
      buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
      buflen: this._bufferLength,
      length: this._dataLength,
      state: [s2[0], s2[1], s2[2], s2[3]]
    };
  }
  setState(state) {
    const buf = state.buffer;
    const x = state.state;
    const s2 = this._state;
    let i;
    this._dataLength = state.length;
    this._bufferLength = state.buflen;
    s2[0] = x[0];
    s2[1] = x[1];
    s2[2] = x[2];
    s2[3] = x[3];
    for (i = 0; i < buf.length; i += 1) {
      this._buffer8[i] = buf.charCodeAt(i);
    }
  }
  end(raw = false) {
    const bufLen = this._bufferLength;
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    const i = (bufLen >> 2) + 1;
    this._dataLength += bufLen;
    const dataBitsLen = this._dataLength * 8;
    buf8[bufLen] = 128;
    buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
    buf32.set(Md5.buffer32Identity.subarray(i), i);
    if (bufLen > 55) {
      Md5._md5cycle(this._state, buf32);
      buf32.set(Md5.buffer32Identity);
    }
    if (dataBitsLen <= 4294967295) {
      buf32[14] = dataBitsLen;
    } else {
      const matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
      if (matches === null) {
        return;
      }
      const lo = parseInt(matches[2], 16);
      const hi = parseInt(matches[1], 16) || 0;
      buf32[14] = lo;
      buf32[15] = hi;
    }
    Md5._md5cycle(this._state, buf32);
    return raw ? this._state : Md5._hex(this._state);
  }
};
Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
Md5.hexChars = "0123456789abcdef";
Md5.hexOut = [];
Md5.onePassHasher = new Md5();
if (Md5.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
  throw new Error("Md5 self test failed.");
}

// src/relationships/RelationshipList.ts
var RelationshipList = class {
  constructor() {
    this.relationships = [];
  }
  _getIndexOfExistingRelationship(path2) {
    for (let index = 0; index < this.relationships.length; index++) {
      if (this.relationships[index].path === path2) {
        return index;
      }
    }
    return -1;
  }
  existsAlready(component) {
    return this.getByPath(component.file.path) !== void 0;
  }
  add(relationship, checkExistence = true) {
    const indexOfExistingRelationship = this._getIndexOfExistingRelationship(relationship.path);
    if (!checkExistence) {
      if (indexOfExistingRelationship !== -1)
        this.relationships.splice(indexOfExistingRelationship, 1);
      this.relationships.push(relationship);
      return;
    }
    let existingRelationship = void 0;
    if (indexOfExistingRelationship !== -1)
      existingRelationship = this.getByPath(relationship.path);
    if (indexOfExistingRelationship !== -1 && existingRelationship !== void 0) {
      if (relationship.type !== 1 /* Reversed */ && (existingRelationship == null ? void 0 : existingRelationship.type) === 1 /* Reversed */ || relationship.type === existingRelationship.type) {
        if (indexOfExistingRelationship !== -1)
          this.relationships.splice(indexOfExistingRelationship, 1);
        this.relationships.push(relationship);
        return;
      }
    } else {
      this.relationships.push(relationship);
    }
  }
  getByPath(path2) {
    const matchingRelationships = this.relationships.filter((searchedRelationship) => searchedRelationship.path === path2);
    if (matchingRelationships.length !== 1)
      return void 0;
    return matchingRelationships[0];
  }
  filter(predicate, thisArg) {
    return this.relationships.filter(predicate);
  }
  forEach(callbackfn) {
    return this.relationships.forEach(callbackfn);
  }
  get stringified() {
    const response = [];
    for (let index = 0; index < this.relationships.length; index++) {
      const relationship = this.relationships[index];
      response.push({
        path: relationship.path,
        description: relationship.description,
        type: relationship.type.toString(),
        isInContent: relationship.isInContent.valueOf(),
        componentVersion: relationship.component !== void 0 ? relationship.component.version : 0
      });
    }
    return response;
  }
  md5() {
    const md5 = new Md5();
    md5.appendStr(JSON.stringify(this.stringified));
    return md5.end();
  }
};

// src/abstracts/AbstractRpgManagerError.ts
var AbstractRpgManagerError = class extends Error {
  constructor(app2, id) {
    super();
    this.app = app2;
    this.id = id;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
  getErrorTitle() {
    return void 0;
  }
  getErrorLinks() {
    return void 0;
  }
};

// src/errors/ComponentNotFoundError.ts
var ComponentNotFoundError = class extends AbstractRpgManagerError {
  showErrorMessage() {
    var _a;
    const response = "The tag `" + this.id.tag + "` refers to an outline that does not exist.\n";
    let check = "Please check you have the following Outlines:\n";
    (_a = this.id.possiblyNotFoundIds) == null ? void 0 : _a.forEach((id, type) => {
      check += " - " + ComponentType[type].toLowerCase() + " with an id of `" + id.toString() + "`\n";
    });
    return response + check;
  }
  showErrorActions() {
    var _a;
    let response = "The tag `" + this.id.tag + "` refers to a non-existing outline.\nThe following ids might be either missing or invalid:\n";
    (_a = this.id.possiblyNotFoundIds) == null ? void 0 : _a.forEach((id, type) => {
      response += " - " + ComponentType[type].toLowerCase() + " with an id of `" + id.toString() + "`\n";
    });
    return response;
  }
};

// src/components/abstracts/AbstractComponent.ts
var AbstractComponent = class extends AbstractComponentData {
  constructor() {
    super(...arguments);
    this._relationships = new RelationshipList();
  }
  readMetadata() {
    return __async(this, null, function* () {
      const fileManipulator = yield this.factories.fileManipulator.create(this.file);
      if (fileManipulator !== void 0) {
        this.fileManipulator = fileManipulator;
        return this.manipulators.codeblock.read(this.fileManipulator, this).then((metadata) => {
          this.metadata = metadata;
          this.initialiseData();
          return this.initialiseRelationships().then(() => {
            return;
          });
        }).catch((e) => {
          if (e.message === "INVALID YAML")
            return;
        });
      }
    });
  }
  initialiseData() {
    return __async(this, null, function* () {
      return;
    });
  }
  validateHierarchy() {
    try {
      this.campaign;
    } catch (e) {
      throw new ComponentNotFoundError(this.app, this.id);
    }
  }
  initialiseRelationships() {
    return __async(this, null, function* () {
      if (this.metadata.relationships !== void 0) {
        yield this.metadata.relationships.forEach((relationshipMetadata) => {
          if (relationshipMetadata.path !== this.file.path) {
            this._relationships.add(this.factories.relationship.createFromMetadata(relationshipMetadata), false);
          }
        });
      }
    });
  }
  get link() {
    return "[[" + this.file.basename + "]]";
  }
  getRelationships(database = void 0) {
    this._relationships.filter((relationship) => relationship.component === void 0).forEach((relationship) => {
      if (relationship.component === void 0) {
        const path2 = relationship.path;
        if (relationship.type !== 64 /* Undefined */) {
          relationship.component = (database != null ? database : this.database).readByPath(path2);
        } else {
          const maybeRelatedComponents = (database != null ? database : this.database).read((component) => component.file.basename === path2);
          if (maybeRelatedComponents.length === 1) {
            relationship.type = 4 /* Unidirectional */;
            relationship.component = maybeRelatedComponents[0];
            relationship.path = maybeRelatedComponents[0].file.path;
          }
        }
      }
    });
    return this._relationships;
  }
  get hasStoryCirclePlot() {
    var _a, _b;
    return ((_b = (_a = this.metadata) == null ? void 0 : _a.plot) == null ? void 0 : _b.storycircle) !== void 0;
  }
  get hasAbtPlot() {
    var _a, _b;
    return ((_b = (_a = this.metadata) == null ? void 0 : _a.plot) == null ? void 0 : _b.abt) !== void 0;
  }
  get abt() {
    return new AbtPlot({});
  }
  get storyCircle() {
    return new StoryCirclePlot({});
  }
  touch() {
    const md5 = new Md5();
    md5.appendStr(JSON.stringify(this.metadata));
    const metadataMd5 = md5.end();
    const relationshipsMd5 = this._relationships.md5();
    if (this._previousMetadata !== metadataMd5 || this._previousRelationships !== relationshipsMd5) {
      this._previousMetadata = metadataMd5;
      this._previousRelationships = relationshipsMd5;
      this._previousRelationshipsStringified = structuredClone(this._relationships.stringified);
      if (this.version === void 0)
        this.version = 0;
      this.version++;
      return true;
    }
    return false;
  }
};

// src/responses/ResponseData.ts
var ResponseData = class extends AbstractRpgManager {
  constructor() {
    super(...arguments);
    this.elements = [];
  }
  addSubModel(type, currentComponent, data, title = void 0, additionalInformation = void 0, position = void 0) {
    return __async(this, null, function* () {
      let relationships = [];
      let relationship;
      if (data instanceof AbstractComponent) {
        relationship = this.factories.relationship.create(32 /* Hierarchy */, data.file.path, void 0, data, true);
      } else if (data instanceof Array) {
        relationships = [];
        if (data.length > 0) {
          if (data[0] instanceof AbstractComponent) {
            data.forEach((component) => {
              relationships.push(this.factories.relationship.create(32 /* Hierarchy */, component.file.path, void 0, component, true));
            });
          } else {
            data.forEach((rel) => {
              relationships.push(rel);
            });
          }
        }
      }
      const element = yield this.factories.subModels.create(type, currentComponent, relationship != null ? relationship : relationships, title, additionalInformation);
      this.addElement(element, position);
    });
  }
  addElement(element, position = null) {
    if (element != null) {
      if (position == null) {
        this.elements.push(element);
      } else {
        this.elements.splice(position, 0, element);
      }
    }
  }
};

// src/responses/ResponseTable.ts
var ResponseTable = class extends AbstractResponse {
  constructor(app2, currentComponent) {
    super(app2, currentComponent);
    this.responseType = 0 /* Table */;
    this.class = null;
    this.headers = [];
    this.content = [];
    this.open = true;
  }
  addHeaders(headers) {
    this.headers = headers;
  }
  addContent(content) {
    this.content.push(content);
  }
};

// src/views/enums/TableField.ts
var tableFieldName = /* @__PURE__ */ new Map([
  [0 /* Index */, "Index"],
  [1 /* Image */, "Image"],
  [2 /* Name */, "Name"],
  [3 /* Age */, "Age"],
  [4 /* Synopsis */, "Synopsis"],
  [5 /* Found */, "Found"],
  [6 /* Date */, "Date"],
  [7 /* Url */, "Url"],
  [8 /* StoryCircleIndicator */, "Story Circle Indicator"],
  [11 /* Duration */, "Duration"],
  [12 /* SceneType */, "Type"],
  [13 /* SceneExciting */, "Exciting?"]
]);

// src/responses/ResponseTableElement.ts
var ResponseTableElement = class {
  constructor(component = void 0, relationship) {
    this.component = component;
    this.relationship = relationship;
    this.elements = [];
  }
  addElement(content) {
    this.elements.push(content);
  }
};

// src/models/abstracts/AbstractTableSubModel.ts
var AbstractTableSubModel = class extends AbstractSubModel {
  generateData(relationships, title, additionalInformation) {
    return __async(this, null, function* () {
      if (relationships.length === 0)
        return null;
      const response = new ResponseTable(this.app, this.currentComponent);
      response.open = this.advancedSettings.defaultVisible;
      response.addTitle(title ? title : this.advancedSettings.title);
      response.addHeaders(this.generateHeader(this.advancedSettings.fields));
      let index = 0;
      relationships.forEach((relationship) => {
        const component = relationship.component;
        if (component !== void 0) {
          index++;
          response.addContent(this.generateContent(index, this.advancedSettings.fields, component, relationship));
        }
      });
      return response;
    });
  }
  generateHeader(fields) {
    const response = [];
    fields.forEach((listElement) => {
      if (listElement.checked) {
        const content = this.generateHeaderElement(listElement.field);
        if (content !== void 0)
          response.push(content);
      }
    });
    return response;
  }
  generateHeaderElement(fieldType) {
    switch (fieldType) {
      case 0 /* Index */:
        return this.factories.contents.create("#", 0 /* String */, true);
      case 6 /* Date */:
        return this.factories.contents.create("Date", 0 /* String */, true);
      case 1 /* Image */:
        return this.factories.contents.create("", 0 /* String */, true);
      case 2 /* Name */:
        return this.factories.contents.create("Name", 0 /* String */);
      case 4 /* Synopsis */:
        return this.factories.contents.create("Synopsis", 0 /* String */);
      case 7 /* Url */:
        return this.factories.contents.create("Url", 0 /* String */);
    }
    return this.factories.contents.create("", 0 /* String */);
  }
  generateContent(index, fields, component, relationship) {
    const response = new ResponseTableElement(component, relationship);
    fields.forEach((listElement) => {
      if (listElement.checked) {
        const content = this.generateContentElement(index, listElement.field, component, relationship);
        if (content !== void 0) {
          response.addElement(content);
        }
      }
    });
    return response;
  }
  generateContentElement(index, fieldType, component, relationship) {
    switch (fieldType) {
      case 2 /* Name */:
        return this.factories.contents.create(component.link, 2 /* Link */);
      case 1 /* Image */:
        return this.factories.contents.create(component.images, 5 /* Image */, true);
      case 4 /* Synopsis */:
        return this.factories.contents.create(relationship.description !== "" && relationship.description != void 0 ? relationship.description : component.synopsis, 4 /* Markdown */, false, void 0, true);
    }
    return this.factories.contents.create("", 0 /* String */);
  }
};

// src/components/components/location/models/LocationTableSubModel.ts
var LocationTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.LocationList;
  }
};

// src/components/components/faction/models/FactionTableSubModel.ts
var FactionTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.FactionList;
  }
};

// src/components/components/clue/models/ClueTableSubModel.ts
var ClueTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.ClueList;
  }
  generateHeaderElement(fieldType) {
    switch (fieldType) {
      case 5 /* Found */:
        return this.factories.contents.create("Found", 0 /* String */);
        break;
    }
    return super.generateHeaderElement(fieldType);
  }
  generateContentElement(index, fieldType, component, relationship) {
    var _a;
    const clue = component;
    switch (fieldType) {
      case 5 /* Found */:
        return this.factories.contents.create(clue.found !== void 0 ? (_a = clue.found) == null ? void 0 : _a.toDateString() : '<span class="rpgm-missing">no</span>', 7 /* Date */);
        break;
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/components/event/models/EventTableSubModel.ts
var EventTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.EventList;
  }
  generateContentElement(index, fieldType, component, relationship) {
    var _a;
    const event = component;
    switch (fieldType) {
      case 6 /* Date */:
        return this.factories.contents.create((_a = event.date) == null ? void 0 : _a.toDateString(), 7 /* Date */, true);
        break;
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/components/music/models/MusicTableSubModel.ts
var MusicTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.MusicList;
  }
  generateContentElement(index, fieldType, component, relationship) {
    var _a;
    const music = component;
    switch (fieldType) {
      case 7 /* Url */:
        return this.factories.contents.create((_a = music.url) != null ? _a : '<span class="rpgm-missing">No URL provided</span>', 4 /* Markdown */);
        break;
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/components/character/models/CharacterTableSubModel.ts
var CharacterTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.CharacterList;
  }
  generateHeaderElement(fieldType) {
    switch (fieldType) {
      case 3 /* Age */:
        return this.factories.contents.create("Age", 0 /* String */);
    }
    return super.generateHeaderElement(fieldType);
  }
  generateContentElement(index, fieldType, component, relationship) {
    var _a;
    const character = component;
    switch (fieldType) {
      case 2 /* Name */:
        return this.factories.contents.create(component.link + (character.isDead ? "\n_(Deceased)_" : ""), 2 /* Link */, true);
      case 3 /* Age */:
        return this.factories.contents.create((_a = character.age) == null ? void 0 : _a.toString(), 0 /* String */, true);
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/components/adventure/models/AdventureTableSubModel.ts
var AdventureTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.AdventureList;
  }
  generateContentElement(index, fieldType, component, relationship) {
    const adventure = component;
    switch (fieldType) {
      case 0 /* Index */:
        return this.factories.contents.create(adventure.id.adventureId, 1 /* Number */, true);
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/components/act/models/ActTableSubModel.ts
var ActTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.ActList;
  }
  generateContentElement(index, fieldType, component, relationship) {
    const act = component;
    switch (fieldType) {
      case 0 /* Index */:
        return this.factories.contents.create(act.id.actId, 1 /* Number */, true);
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/components/enums/SceneType.ts
var SceneType = /* @__PURE__ */ ((SceneType2) => {
  SceneType2[SceneType2["Action"] = 0] = "Action";
  SceneType2[SceneType2["Combat"] = 1] = "Combat";
  SceneType2[SceneType2["Encounter"] = 2] = "Encounter";
  SceneType2[SceneType2["Exposition"] = 3] = "Exposition";
  SceneType2[SceneType2["Investigation"] = 4] = "Investigation";
  SceneType2[SceneType2["Planning"] = 5] = "Planning";
  SceneType2[SceneType2["Preparation"] = 6] = "Preparation";
  SceneType2[SceneType2["Recap"] = 7] = "Recap";
  SceneType2[SceneType2["SocialCombat"] = 8] = "SocialCombat";
  return SceneType2;
})(SceneType || {});
var sceneTypeDescription = /* @__PURE__ */ new Map([
  [0 /* Action */, "Action: the pcs have to do something"],
  [1 /* Combat */, "Combat: fight scene"],
  [2 /* Encounter */, "Encounter: An NPC in involved"],
  [3 /* Exposition */, "Exposition: Storyteller showtime"],
  [4 /* Investigation */, "Investigation: Pcs analyse a scene"],
  [5 /* Planning */, "Planning: Pcs plans something"],
  [6 /* Preparation */, "Preparation: Pcs do something"],
  [7 /* Recap */, "Recap: Pcs talks amongst themselves"],
  [8 /* SocialCombat */, "Social Combat: PCs need to get something from NPCs"]
]);

// src/components/components/scene/models/SceneTableSubModel.ts
var SceneTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.SceneList;
  }
  generateHeaderElement(fieldType) {
    switch (fieldType) {
      case 11 /* Duration */:
        return this.factories.contents.create("Duration", 0 /* String */);
        break;
      case 12 /* SceneType */:
        if (!this.settings.useSceneAnalyser)
          return void 0;
        return this.factories.contents.create("Type", 0 /* String */);
        break;
      case 13 /* SceneExciting */:
        if (!this.settings.useSceneAnalyser)
          return void 0;
        return this.factories.contents.create("Exciting", 0 /* String */);
        break;
      case 8 /* StoryCircleIndicator */:
        if (!this.settings.usePlotStructures)
          return void 0;
        return this.factories.contents.create("", 0 /* String */);
        break;
    }
    return super.generateHeaderElement(fieldType);
  }
  generateContentElement(index, fieldType, component, relationship) {
    const scene = component;
    switch (fieldType) {
      case 0 /* Index */:
        return this.factories.contents.create(scene.isComplete ? index.toString() : "**" + index.toString() + "**", 4 /* Markdown */, true);
        break;
      case 2 /* Name */:
        return this.factories.contents.create(scene.link + (scene.isComplete ? "" : " _(incomplete)_"), 2 /* Link */);
        break;
      case 6 /* Date */:
        return this.factories.contents.create(scene.date != null ? scene.date.toDateString() : "", 7 /* Date */, true);
        break;
      case 11 /* Duration */:
        return this.factories.contents.create(scene.duration === "00:00" ? void 0 : scene.duration, 7 /* Date */, true);
        break;
      case 12 /* SceneType */:
        if (!this.settings.useSceneAnalyser)
          return void 0;
        return this.factories.contents.create((scene.sceneType === void 0 ? "" : SceneType[scene.sceneType]) + (scene.isActive ? " *" : ""), 7 /* Date */, true);
        break;
      case 13 /* SceneExciting */:
        if (!this.settings.useSceneAnalyser)
          return void 0;
        return this.factories.contents.create(scene.isExciting ? "yes" : "", 7 /* Date */, true);
        break;
      case 8 /* StoryCircleIndicator */:
        if (!this.settings.usePlotStructures)
          return void 0;
        return this.factories.contents.create("pieEighth", 6 /* SVG */, true, { storyCircleStage: scene.storyCircleStage });
        break;
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
  _formatTime(date) {
    if (date == null)
      return "";
    const hours = date.getHours();
    const minutes = date.getMinutes();
    return (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes);
  }
};

// src/components/components/session/models/SessionTableSubModel.ts
var SessionTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.SessionList;
  }
  generateContentElement(index, fieldType, component, relationship) {
    var _a;
    const session = component;
    switch (fieldType) {
      case 0 /* Index */:
        return this.factories.contents.create(session.id.sessionId, 0 /* String */, true);
        break;
      case 6 /* Date */:
        return this.factories.contents.create((_a = session.irl) == null ? void 0 : _a.toDateString(), 7 /* Date */, true);
        break;
    }
    return super.generateContentElement(index, fieldType, component, relationship);
  }
};

// src/databases/SorterComparisonElement.ts
var SorterComparisonElement = class {
  constructor(comparisonElement, sortType = 0 /* Ascending */) {
    this.comparisonElement = comparisonElement;
    this.sortType = sortType;
  }
};

// src/components/components/subplot/models/SubplotTableSubModel.ts
var SubplotTableSubModel = class extends AbstractTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.SubplotList;
  }
};

// src/components/components/character/models/NonPlayerCharacterTableSubModel.ts
var NonPlayerCharacterTableSubModel = class extends CharacterTableSubModel {
  constructor() {
    super(...arguments);
    this.advancedSettings = this.settings.advanced.Agnostic.NonPlayerCharacterList;
  }
};

// src/models/abstracts/AbstractModel.ts
var AbstractModel = class extends AbstractRpgManager {
  constructor(app2, currentComponent, source, sourcePath, sourceMeta) {
    super(app2);
    this.currentComponent = currentComponent;
    this.source = source;
    this.sourcePath = sourcePath;
    this.sourceMeta = sourceMeta;
    this.subModelsMap = /* @__PURE__ */ new Map();
    this.componentSortingMap = /* @__PURE__ */ new Map();
    this.relationshipSortingMap = /* @__PURE__ */ new Map();
    this.currentComponent.file.stat.mtime = Date.now();
    this.response = new ResponseData(this.app);
    this.subModelsMap.set(128 /* Location */, LocationTableSubModel);
    this.subModelsMap.set(1024 /* Faction */, FactionTableSubModel);
    this.subModelsMap.set(512 /* Clue */, ClueTableSubModel);
    this.subModelsMap.set(256 /* Event */, EventTableSubModel);
    this.subModelsMap.set(32 /* Character */, CharacterTableSubModel);
    this.subModelsMap.set(64 /* NonPlayerCharacter */, NonPlayerCharacterTableSubModel);
    this.subModelsMap.set(2048 /* Music */, MusicTableSubModel);
    this.subModelsMap.set(2 /* Adventure */, AdventureTableSubModel);
    this.subModelsMap.set(16 /* Session */, SessionTableSubModel);
    this.subModelsMap.set(4 /* Act */, ActTableSubModel);
    this.subModelsMap.set(8 /* Scene */, SceneTableSubModel);
    this.subModelsMap.set(4096 /* Subplot */, SubplotTableSubModel);
    this.componentSortingMap = /* @__PURE__ */ new Map();
    this.componentSortingMap.set(256 /* Event */, [new SorterComparisonElement((component) => component.date)]);
    this.componentSortingMap.set(1 /* Campaign */, [new SorterComparisonElement((component) => component.id.campaignId)]);
    this.componentSortingMap.set(16 /* Session */, [
      new SorterComparisonElement((component) => component.id.campaignId),
      new SorterComparisonElement((component) => component.id.adventureId)
    ]);
    this.componentSortingMap.set(2 /* Adventure */, [
      new SorterComparisonElement((component) => component.id.campaignId),
      new SorterComparisonElement((component) => component.id.adventureId)
    ]);
    this.componentSortingMap.set(4 /* Act */, [
      new SorterComparisonElement((component) => component.id.campaignId),
      new SorterComparisonElement((component) => component.id.adventureId),
      new SorterComparisonElement((component) => component.id.actId)
    ]);
    this.componentSortingMap.set(8 /* Scene */, [
      new SorterComparisonElement((component) => component.id.campaignId),
      new SorterComparisonElement((component) => component.id.adventureId),
      new SorterComparisonElement((component) => component.id.actId),
      new SorterComparisonElement((component) => component.id.sceneId)
    ]);
    this.relationshipSortingMap = /* @__PURE__ */ new Map();
    this.relationshipSortingMap.set(256 /* Event */, [new SorterComparisonElement((component) => component.component.date)]);
    this.relationshipSortingMap.set(1 /* Campaign */, [new SorterComparisonElement((component) => component.component.id.campaignId)]);
    this.relationshipSortingMap.set(16 /* Session */, [
      new SorterComparisonElement((component) => component.component.id.campaignId),
      new SorterComparisonElement((component) => component.component.id.adventureId)
    ]);
    this.relationshipSortingMap.set(2 /* Adventure */, [
      new SorterComparisonElement((component) => component.component.id.campaignId),
      new SorterComparisonElement((component) => component.component.id.adventureId)
    ]);
    this.relationshipSortingMap.set(4 /* Act */, [
      new SorterComparisonElement((component) => component.component.id.campaignId),
      new SorterComparisonElement((component) => component.component.id.adventureId),
      new SorterComparisonElement((component) => component.component.id.actId)
    ]);
    this.relationshipSortingMap.set(8 /* Scene */, [
      new SorterComparisonElement((component) => component.component.id.campaignId),
      new SorterComparisonElement((component) => component.component.id.adventureId),
      new SorterComparisonElement((component) => component.component.id.actId),
      new SorterComparisonElement((component) => component.component.id.sceneId)
    ]);
  }
  addList(type, data, sortByLatestUsage = false) {
    return __async(this, null, function* () {
      if (sortByLatestUsage) {
        data;
      }
      return yield this._add(type, void 0, data, void 0, sortByLatestUsage);
    });
  }
  addRelationships(type, requiredRelationshipType = void 0, title = void 0, sortByLatestUsage = false) {
    return __async(this, null, function* () {
      return yield this._add(type, requiredRelationshipType, void 0, title, sortByLatestUsage);
    });
  }
  _add(type, requiredRelationshipType, component = void 0, title = void 0, sortByLatestUsage) {
    return __async(this, null, function* () {
      var _a;
      if (requiredRelationshipType === void 0)
        requiredRelationshipType = 1 /* Reversed */ | 2 /* Bidirectional */ | 4 /* Unidirectional */;
      if (requiredRelationshipType === 4 /* Unidirectional */)
        requiredRelationshipType = 4 /* Unidirectional */ | 2 /* Bidirectional */;
      const subModel = this.subModelsMap.get(type);
      if (component === void 0) {
        component = this.currentComponent.getRelationships().filter((relationship) => relationship.component !== void 0 && relationship.component.id.type === type && (requiredRelationshipType === void 0 || (requiredRelationshipType & relationship.type) === relationship.type));
      }
      if (Array.isArray(component)) {
        let sorter = void 0;
        if (((_a = component[0]) == null ? void 0 : _a.component) !== void 0) {
          if (sortByLatestUsage) {
            sorter = [
              new SorterComparisonElement((relationship) => relationship.component.file.stat.mtime, 1 /* Descending */)
            ];
          } else {
            sorter = this.relationshipSortingMap.get(type);
            if (sorter === void 0)
              sorter = [new SorterComparisonElement((relationship) => relationship.component.file.basename)];
          }
        } else {
          if (sortByLatestUsage) {
            sorter = [
              new SorterComparisonElement((component2) => component2.file.stat.mtime, 1 /* Descending */)
            ];
          } else {
            sorter = this.componentSortingMap.get(type);
            if (sorter === void 0)
              sorter = [new SorterComparisonElement((component2) => component2.file.basename)];
          }
        }
        if (sorter !== void 0)
          component = component.sort(this.factories.sorter.create(sorter));
      }
      if (subModel !== void 0) {
        yield this.response.addSubModel(subModel, this.currentComponent, component, title);
      }
    });
  }
};

// src/models/HeaderModel.ts
var HeaderModel = class extends AbstractModel {
  generateData() {
    return __async(this, null, function* () {
      if (this.currentComponent.id.type !== 1 /* Campaign */)
        yield this.response.addElement(this.factories.breadcrumb.create(this.currentComponent));
      yield this.response.addSubModel(this.factories.models.createSubModel(this.currentComponent.campaignSettings, this.currentComponent.id.type, "Header"), this.currentComponent, this.currentComponent);
      return this.response;
    });
  }
};

// src/components/components/campaign/models/CampaignHeaderSubModel.ts
var CampaignHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      if (additionalInformation === void 0)
        additionalInformation = {};
      additionalInformation.adventures = this.database.readList(2 /* Adventure */, this.currentComponent.id).sort(this.factories.sorter.create([
        new SorterComparisonElement((component) => component.file.stat.mtime, 1 /* Descending */)
      ]));
      additionalInformation.acts = this.database.readList(4 /* Act */, this.currentComponent.id);
      if (this.data.currentAdventureId != void 0 && this.data.currentAdventureId !== "") {
        const currentAdventureId = +this.data.currentAdventureId.split("/")[2];
        additionalInformation.acts = additionalInformation.acts.filter((act) => act.id.adventureId === currentAdventureId);
      }
      additionalInformation.acts.sort(this.factories.sorter.create([
        new SorterComparisonElement((component) => component.file.stat.mtime, 1 /* Descending */)
      ]));
      additionalInformation.sessions = this.database.readList(16 /* Session */, this.currentComponent.id).sort(this.factories.sorter.create([
        new SorterComparisonElement((component) => component.file.stat.mtime, 1 /* Descending */)
      ]));
      let response = yield __superGet(CampaignHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 1 /* Campaign */;
      response.responseType = 8 /* CampaignHeader */;
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Current Date", this.data.date != null ? this.data.date.toDateString() : void 0, 13 /* DateSelector */, {
        yamlIdentifier: "data.date",
        date: this.data.date,
        placeholder: "Select the current date in the campaign"
      }));
      response.metadata = { campaignId: this.data.id, sourceMeta: additionalInformation };
      return this.completeData(response);
    });
  }
};

// src/components/components/adventure/models/AdventureHeaderSubModel.ts
var AdventureHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(AdventureHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 2 /* Adventure */;
      response.responseType = 7 /* AdventureHeader */;
      response.metadata = { adventureId: this.data.id, sourceMeta: additionalInformation };
      return this.completeData(response);
    });
  }
};

// src/plots/enums/StoryCircleStage.ts
var StoryCircleStage = /* @__PURE__ */ ((StoryCircleStage2) => {
  StoryCircleStage2[StoryCircleStage2["You"] = 0] = "You";
  StoryCircleStage2[StoryCircleStage2["Need"] = 1] = "Need";
  StoryCircleStage2[StoryCircleStage2["Go"] = 2] = "Go";
  StoryCircleStage2[StoryCircleStage2["Search"] = 3] = "Search";
  StoryCircleStage2[StoryCircleStage2["Find"] = 4] = "Find";
  StoryCircleStage2[StoryCircleStage2["Take"] = 5] = "Take";
  StoryCircleStage2[StoryCircleStage2["Return"] = 6] = "Return";
  StoryCircleStage2[StoryCircleStage2["Change"] = 7] = "Change";
  return StoryCircleStage2;
})(StoryCircleStage || {});

// src/components/components/scene/models/SceneHeaderSubModel.ts
var SceneHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      if (!this.initialiseData(relationship))
        return null;
      this.synopsisTitle = "Scene Goal";
      const sessions = this.database.read((session) => session.id.type === 16 /* Session */ && session.id.campaignId === this.data.id.campaignId).sort(this.factories.sorter.create([
        new SorterComparisonElement((session) => session.id.sessionId, 1 /* Descending */)
      ]));
      let response = yield __superGet(SceneHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 8 /* Scene */;
      response.responseType = 15 /* SceneHeader */;
      let trigger = (_a = this.data) == null ? void 0 : _a.trigger;
      if (this.data.trigger == null || this.data.trigger === "")
        trigger = '<span class="rpgm-missing">Scene trigger missing</span>';
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Trigger", trigger, 1 /* Long */, { editableField: "data.trigger" }));
      let action = (_b = this.data) == null ? void 0 : _b.action;
      if (this.data.action == null || this.data.action === "")
        action = '<span class="rpgm-missing">Scene action missing</span>';
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Action", action, 1 /* Long */, { editableField: "data.action" }));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Date", this.data.date, 13 /* DateSelector */));
      if (sessions.length > 0) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Session", this.data.session === void 0 ? "" : (_e = (_d = (_c = this.data.session) == null ? void 0 : _c.id) == null ? void 0 : _d.sessionId) == null ? void 0 : _e.toString(), 4 /* SessionSelection */, {
          sceneId: this.data.id,
          file: this.data.file,
          sessions
        }));
      }
      if (this.settings.usePlotStructures) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Story Circle Stage", this.data.storyCircleStage !== void 0 ? this.data.storyCircleStage : "", 5 /* StoryCircleSelector */, {
          sceneId: this.data.id,
          file: this.data.file
        }));
      }
      if (this.settings.useSceneAnalyser) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Type", this.data.sceneType !== void 0 ? this.data.sceneType : "", 7 /* SceneTypeSelector */, {
          sceneId: this.data.id,
          file: this.data.file
        }));
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "External actions?", this.data.isExciting, 8 /* SceneExcitment */, {
          sceneId: this.data.id,
          file: this.data.file
        }));
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Run", this.data.isCurrentlyRunning, 9 /* SceneRun */));
        if (this.data.isCurrentlyRunning || this.data.currentDuration > 0)
          response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Duration", "", 10 /* SceneRunTime */));
      }
      if (this.settings.useSceneAnalyser && this.data.sceneType !== void 0 && this.data.storyCircleStage !== void 0) {
        let stage = void 0;
        switch (this.data.storyCircleStage) {
          case 0 /* You */:
          case 1 /* Need */:
            stage = 0 /* Need */;
            break;
          case 2 /* Go */:
          case 3 /* Search */:
            stage = 1 /* And */;
            break;
          case 4 /* Find */:
          case 5 /* Take */:
            stage = 2 /* But */;
            break;
          case 6 /* Return */:
          case 7 /* Change */:
            stage = 3 /* Therefore */;
            break;
        }
        if (stage !== void 0) {
          if (additionalInformation == null)
            additionalInformation = {};
          additionalInformation.analyser = this.factories.analyser.createScene(this.data, stage);
        }
      }
      response.metadata = { actId: this.data.id, sourceMeta: additionalInformation };
      return this.completeData(response);
    });
  }
};

// src/components/components/session/models/SessionHeaderSubModel.ts
var SessionHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(SessionHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 16 /* Session */;
      response.responseType = 16 /* SessionHeader */;
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scenes", "", 3 /* ScenesSelection */, { session: this.data }));
      if (this.settings.usePlotStructures) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "ABT Stage", this.data.abtStage !== void 0 ? AbtStage[this.data.abtStage] : "", 6 /* AbtSelector */, {
          id: this.data.id,
          file: this.data.file
        }));
      }
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Session Date", this.data.irl, 13 /* DateSelector */));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Target Duration", this.data.targetDuration, 14 /* DurationSelector */));
      if (response.metadata === void 0)
        response.metadata = {};
      response.metadata.isSceneNoteListAvailable = this.data.isSceneNoteListAvailable;
      if (this.data.isSceneNoteListAvailable) {
        response.metadata.scenes = this.database.read((scene) => {
          var _a;
          return scene.id.type === 8 /* Scene */ && scene.id.campaignId === this.currentComponent.campaign.id.campaignId && ((_a = scene.session) == null ? void 0 : _a.id.sessionId) === this.data.id.sessionId;
        }).sort(this.factories.sorter.create([
          new SorterComparisonElement((scene) => scene.id.adventureId),
          new SorterComparisonElement((scene) => scene.id.actId),
          new SorterComparisonElement((scene) => scene.id.sceneId)
        ]));
      }
      if (this.settings.useSceneAnalyser) {
        const analyser = this.factories.analyser.createSession(this.data, this.data.abtStage);
        if (analyser.scenesCount > 0) {
          response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Scene Analyser", this.data.abtStage !== void 0 ? AbtStage[this.data.abtStage] : "", 11 /* SceneAnalyser */, {
            id: this.data.id,
            file: this.data.file,
            sceneAnalyser: analyser
          }));
        }
      }
      return this.completeData(response);
    });
  }
};

// src/components/components/subplot/models/SubplotHeaderSubModel.ts
var SubplotHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(SubplotHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 4096 /* Subplot */;
      response.responseType = 17 /* SubplotHeader */;
      return this.completeData(response);
    });
  }
};

// src/components/components/character/models/CharacterHeaderSubModel.ts
var CharacterHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      var _a;
      if (!this.initialiseData(relationship))
        return null;
      if (this.data.synopsis != null && this.data.synopsis !== "") {
        this.synopsis = "";
        this.synopsis += this.data.file.path.toString();
        const pronoun = this.data.pronoun;
        if (pronoun != null) {
          this.synopsis += this.factories.pronouns.readPronoun(pronoun);
        }
        this.synopsis += this.data.isDead ? " was " : " is ";
        this.synopsis += this.data.synopsis;
      }
      let response = yield __superGet(CharacterHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 32 /* Character */;
      response.responseType = 9 /* CharacterHeader */;
      let goals = (_a = this.data) == null ? void 0 : _a.goals;
      if (this.data.goals == null || this.data.goals === "")
        goals = '<span class="rpgm-missing">Goals missing</span>';
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Goals", goals, 1 /* Long */, { editableField: "data.goals" }));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Pronoun", this.data.pronoun, 12 /* Pronoun */));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Birth", this.data.dob != null ? this.data.dob.toDateString() : void 0, 13 /* DateSelector */, {
        yamlIdentifier: "data.dob",
        date: this.data.dob,
        placeholder: "Select the birth date of the character"
      }));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Death", this.data.death != null ? this.data.death.toDateString() : void 0, 13 /* DateSelector */, {
        yamlIdentifier: "data.death",
        date: this.data.death,
        placeholder: "Select the death date of the character"
      }));
      if (this.data.age != null || this.data.death != null) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Status", this.data.death ? "Dead" : "Alive", 0 /* Short */));
      }
      if (this.data.death != null) {
        let death = this.data.death.toDateString();
        if (this.data.age != null) {
          death += " at age " + this.data.age;
        }
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Death", death, 0 /* Short */));
      } else if (this.data.age != null) {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Age", this.data.age.toString(), 0 /* Short */));
      }
      return this.completeData(response);
    });
  }
};

// src/components/components/clue/models/ClueHeaderSubModel.ts
var ClueHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(ClueHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 512 /* Clue */;
      response.responseType = 10 /* ClueHeader */;
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Found", this.data.found !== void 0 ? "Yes" : "No", 0 /* Short */));
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Discovery date", this.data.found != null ? this.data.found.toDateString() : void 0, 13 /* DateSelector */, {
        yamlIdentifier: "data.found",
        date: this.data.found,
        placeholder: "Clue discovery date"
      }));
      return this.completeData(response);
    });
  }
};

// src/components/components/event/models/EventHeaderSubModel.ts
var EventHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(EventHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 256 /* Event */;
      response.responseType = 11 /* EventHeader */;
      response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Event date", this.data.date != null ? this.data.date.toDateString() : void 0, 13 /* DateSelector */, {
        yamlIdentifier: "data.date",
        date: this.data.date,
        placeholder: "Select the event date"
      }));
      return this.completeData(response);
    });
  }
};

// src/components/components/location/models/LocationHeaderSubModel.ts
var LocationHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(LocationHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 128 /* Location */;
      response.responseType = 13 /* LocationHeader */;
      if (this.data.address != null && this.data.address != "") {
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "Address", this.data.address, 0 /* Short */, { editableField: "data.address" }));
      }
      return this.completeData(response);
    });
  }
};

// src/components/components/faction/models/FactionHeaderSubModel.ts
var FactionHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(FactionHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 1024 /* Faction */;
      response.responseType = 12 /* FactionHeader */;
      return this.completeData(response);
    });
  }
};

// src/components/components/music/models/MusicHeaderSubModel.ts
var MusicHeaderSubModel = class extends AbstractHeaderSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.initialiseData(relationship))
        return null;
      let response = yield __superGet(MusicHeaderSubModel.prototype, this, "generateData").call(this, relationship, title, additionalInformation);
      if (response === null)
        response = new ResponseHeader(this.app, this.currentComponent);
      response.type = 2048 /* Music */;
      response.responseType = 14 /* MusicHeader */;
      if (this.data.images.length === 0) {
        response.imgSrc = yield this.data.getThumbnail();
      } else if (this.data.images.length > 0) {
        response.imgSrc = this.data.images[0].src;
      }
      if (this.data.url !== void 0)
        response.addElement(new ResponseHeaderElement(this.app, this.currentComponent, "link", this.data.url, 1 /* Long */, { editableField: "data.url" }));
      return this.completeData(response);
    });
  }
};

// src/plots/models/AbtPlotSubModel.ts
var AbtPlotSubModel = class extends AbstractSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (!this.currentComponent.hasAbtPlot || this.currentComponent.abt.isEmpty)
        return null;
      const response = new ResponseTable(this.app, this.currentComponent);
      response.title = "ABT Plot";
      response.class = "rpgm-plot";
      const needContent = new ResponseTableElement(void 0, relationship);
      needContent.addElement(this.factories.contents.create("**NEED** ", 4 /* Markdown */, true));
      needContent.addElement(this.factories.contents.create(additionalInformation.need ? additionalInformation.need : "", 4 /* Markdown */));
      response.addContent(needContent);
      const andContent = new ResponseTableElement(void 0, relationship);
      andContent.addElement(this.factories.contents.create("**AND** ", 4 /* Markdown */, true));
      andContent.addElement(this.factories.contents.create(additionalInformation.and ? additionalInformation.and : "", 4 /* Markdown */));
      response.addContent(andContent);
      const butContent = new ResponseTableElement(void 0, relationship);
      butContent.addElement(this.factories.contents.create("**BUT** ", 4 /* Markdown */, true));
      butContent.addElement(this.factories.contents.create(additionalInformation.but ? additionalInformation.but : "", 4 /* Markdown */));
      response.addContent(butContent);
      const thereforeContent = new ResponseTableElement(void 0, relationship);
      thereforeContent.addElement(this.factories.contents.create("**THEREFORE** ", 4 /* Markdown */, true));
      thereforeContent.addElement(this.factories.contents.create(additionalInformation.therefore ? additionalInformation.therefore : "", 4 /* Markdown */));
      response.addContent(thereforeContent);
      return response;
    });
  }
};

// src/plots/models/StoryCirclePlotSubModel.ts
var StoryCirclePlotSubModel = class extends AbstractSubModel {
  generateData(relationship, title, additionalInformation) {
    return __async(this, null, function* () {
      if (additionalInformation == null || (additionalInformation.you == null || additionalInformation.need == null || additionalInformation.go == null || additionalInformation.search == null || additionalInformation.find == null || additionalInformation.take == null || additionalInformation.return == null || additionalInformation.change == null) || additionalInformation.you === "" && additionalInformation.need === "" && additionalInformation.go === "" && additionalInformation.search === "" && additionalInformation.find === "" && additionalInformation.take === "" && additionalInformation.return === "" && additionalInformation.change === "")
        return null;
      if (relationship.component === void 0)
        return null;
      const response = new ResponseTable(this.app, this.currentComponent);
      response.title = "Story Circle Plot";
      response.class = "rpgm-plot";
      const youContent = new ResponseTableElement(void 0, relationship);
      youContent.addElement(this.factories.contents.create("**YOU** ", 4 /* Markdown */, true));
      youContent.addElement(this.factories.contents.create(additionalInformation.you ? additionalInformation.you : "", 4 /* Markdown */));
      response.addContent(youContent);
      const needContent = new ResponseTableElement(void 0, relationship);
      needContent.addElement(this.factories.contents.create("**NEED** ", 4 /* Markdown */, true));
      needContent.addElement(this.factories.contents.create(additionalInformation.need ? additionalInformation.need : "", 4 /* Markdown */));
      response.addContent(needContent);
      const goContent = new ResponseTableElement(void 0, relationship);
      goContent.addElement(this.factories.contents.create("**GO** ", 4 /* Markdown */, true));
      goContent.addElement(this.factories.contents.create(additionalInformation.go ? additionalInformation.go : "", 4 /* Markdown */));
      response.addContent(goContent);
      const searchContent = new ResponseTableElement(void 0, relationship);
      searchContent.addElement(this.factories.contents.create("**SEARCH** ", 4 /* Markdown */, true));
      searchContent.addElement(this.factories.contents.create(additionalInformation.search ? additionalInformation.search : "", 4 /* Markdown */));
      response.addContent(searchContent);
      const findContent = new ResponseTableElement(void 0, relationship);
      findContent.addElement(this.factories.contents.create("**FIND** ", 4 /* Markdown */, true));
      findContent.addElement(this.factories.contents.create(additionalInformation.find ? additionalInformation.find : "", 4 /* Markdown */));
      response.addContent(findContent);
      const takeContent = new ResponseTableElement(void 0, relationship);
      takeContent.addElement(this.factories.contents.create("**TAKE** ", 4 /* Markdown */, true));
      takeContent.addElement(this.factories.contents.create(additionalInformation.take ? additionalInformation.take : "", 4 /* Markdown */));
      response.addContent(takeContent);
      const returnContent = new ResponseTableElement(void 0, relationship);
      returnContent.addElement(this.factories.contents.create("**RETURN** ", 4 /* Markdown */, true));
      returnContent.addElement(this.factories.contents.create(additionalInformation.return ? additionalInformation.return : "", 4 /* Markdown */));
      response.addContent(returnContent);
      const changeContent = new ResponseTableElement(void 0, relationship);
      changeContent.addElement(this.factories.contents.create("**CHANGE** ", 4 /* Markdown */, true));
      changeContent.addElement(this.factories.contents.create(additionalInformation.change ? additionalInformation.change : "", 4 /* Markdown */));
      response.addContent(changeContent);
      return response;
    });
  }
};

// src/models/ListModel.ts
var ListModel = class extends AbstractModel {
  generateData() {
    return __async(this, null, function* () {
      if (this.currentComponent.id.type === 16 /* Session */)
        this._updateRelationshipsList();
      for (let listCounter = 0; listCounter < Object.keys(this.sourceMeta).length; listCounter++) {
        const name = Object.keys(this.sourceMeta)[listCounter];
        const componentType = this.factories.componentType.createComponentType(name.slice(0, -1));
        let elements = this.sourceMeta[name];
        if (elements == void 0)
          elements = {
            relationship: void 0,
            title: void 0
          };
        if (!Array.isArray(elements))
          elements = [elements];
        for (let elementCount = 0; elementCount < elements.length; elementCount++) {
          const element = elements[elementCount];
          if (element !== void 0) {
            const relationshipType = element.relationship != null ? this.factories.relationshipType.createRelationshipType(element.relationship) : void 0;
            if (relationshipType === 32 /* Hierarchy */ && (this.currentComponent.id.type !== 16 /* Session */ || componentType === 8 /* Scene */)) {
              yield this.addList(componentType, this._generateComponentList(componentType));
            } else {
              yield this.addRelationships(componentType, relationshipType, element.title === "" ? void 0 : element.title);
            }
          }
        }
      }
      return this.response;
    });
  }
  _generateComponentList(type) {
    if (this.currentComponent.id.type !== 16 /* Session */)
      return this.database.readList(type, this.currentComponent.id);
    return this.database.read((scene) => {
      var _a;
      return scene.id.type === 8 /* Scene */ && scene.id.campaignId === this.currentComponent.campaign.id.campaignId && ((_a = scene.session) == null ? void 0 : _a.id.sessionId) === this.currentComponent.id.sessionId;
    }).sort(this.factories.sorter.create([
      new SorterComparisonElement((scene) => scene.id.adventureId),
      new SorterComparisonElement((scene) => scene.id.actId),
      new SorterComparisonElement((scene) => scene.id.sceneId)
    ]));
  }
  _updateRelationshipsList() {
    if (this.currentComponent.id.type === 16 /* Session */) {
      const scenes = this.database.read((scene) => {
        var _a;
        return scene.id.type === 8 /* Scene */ && scene.id.campaignId === this.currentComponent.campaign.id.campaignId && ((_a = scene.session) == null ? void 0 : _a.id.sessionId) === this.currentComponent.id.sessionId;
      }).sort(this.factories.sorter.create([
        new SorterComparisonElement((scene) => scene.id.adventureId),
        new SorterComparisonElement((scene) => scene.id.actId),
        new SorterComparisonElement((scene) => scene.id.sceneId)
      ]));
      for (let sceneIndex = 0; sceneIndex < scenes.length; sceneIndex++) {
        scenes[sceneIndex].getRelationships().forEach((relationship) => {
          if (relationship.component !== void 0 && relationship.component.stage !== 0 /* Plot */ && relationship.component.stage !== 2 /* Run */ && this.currentComponent.getRelationships().filter((internalRelationship) => internalRelationship.path === relationship.path).length === 0 && relationship.type === 4 /* Unidirectional */) {
            this.factories.relationship.create(32 /* Hierarchy */, relationship.path, void 0, relationship.component, false, this.currentComponent.getRelationships());
          }
        });
      }
    }
  }
};

// src/models/factories/ModelFactory.ts
var ModelFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
    this._subModels = /* @__PURE__ */ new Map([
      [this._createSubModelIdentifier(0 /* Agnostic */, 1 /* Campaign */, "Header"), CampaignHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 2 /* Adventure */, "Header"), AdventureHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 4 /* Act */, "Header"), ActHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 8 /* Scene */, "Header"), SceneHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 16 /* Session */, "Header"), SessionHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 4096 /* Subplot */, "Header"), SubplotHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 32 /* Character */, "Header"), CharacterHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 64 /* NonPlayerCharacter */, "Header"), CharacterHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 512 /* Clue */, "Header"), ClueHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 256 /* Event */, "Header"), EventHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 128 /* Location */, "Header"), LocationHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 1024 /* Faction */, "Header"), FactionHeaderSubModel],
      [this._createSubModelIdentifier(0 /* Agnostic */, 2048 /* Music */, "Header"), MusicHeaderSubModel],
      [this._createSubModelIdentifier(void 0, void 0, "AbtPlot"), AbtPlotSubModel],
      [this._createSubModelIdentifier(void 0, void 0, "StoryCirclePlot"), StoryCirclePlotSubModel]
    ]);
    this._modelTypeMap = /* @__PURE__ */ new Map([
      ["AgnosticHeader", HeaderModel],
      ["AgnosticList", ListModel]
    ]);
  }
  create(settings, modelName, currentComponent, source, sourcePath, sourceMeta) {
    let modelKey = CampaignSetting[settings] + modelName;
    if (!this._modelTypeMap.has(modelKey))
      modelKey = CampaignSetting[0 /* Agnostic */] + modelName;
    if (!this._modelTypeMap.has(modelKey))
      throw new Error("Type of interfaces " + CampaignSetting[settings] + modelName + " cannot be found");
    return new (this._modelTypeMap.get(modelKey))(this.app, currentComponent, source, sourcePath, sourceMeta);
  }
  createSubModel(settings, type, subModelName) {
    if (this._subModels.has(this._createSubModelIdentifier(settings, type, subModelName))) {
      return this._subModels.get(this._createSubModelIdentifier(settings, type, subModelName));
    } else {
      return this._subModels.get(this._createSubModelIdentifier(0 /* Agnostic */, type, subModelName));
    }
  }
  _createSubModelIdentifier(settings, type, subModelName) {
    return (settings !== void 0 ? settings.toString() : "") + "." + (type !== void 0 ? type.toString() : "") + "." + subModelName;
  }
};

// src/components/enums/Pronoun.ts
var Pronoun = /* @__PURE__ */ ((Pronoun2) => {
  Pronoun2[Pronoun2["they"] = 0] = "they";
  Pronoun2[Pronoun2["she"] = 1] = "she";
  Pronoun2[Pronoun2["he"] = 2] = "he";
  Pronoun2[Pronoun2["it"] = 3] = "it";
  Pronoun2[Pronoun2["ae"] = 4] = "ae";
  Pronoun2[Pronoun2["e"] = 5] = "e";
  Pronoun2[Pronoun2["per"] = 6] = "per";
  Pronoun2[Pronoun2["ve"] = 7] = "ve";
  Pronoun2[Pronoun2["xe"] = 8] = "xe";
  Pronoun2[Pronoun2["ze"] = 9] = "ze";
  return Pronoun2;
})(Pronoun || {});

// src/components/factories/PronounFactory.ts
var PronounFactory = class extends AbstractFactory {
  createPronoun(readablePronoun) {
    readablePronoun = readablePronoun.toLowerCase();
    return Pronoun[readablePronoun];
  }
  createReadablePronoun(pronoun) {
    return Pronoun[pronoun].toString().toLowerCase();
  }
  readPronoun(pronoun) {
    switch (pronoun) {
      case 0 /* they */:
        return "They / Them / Themself";
        break;
      case 1 /* she */:
        return "She / Her / Herself";
        break;
      case 2 /* he */:
        return "He / Him / Himself";
        break;
      case 3 /* it */:
        return "It / Its / Itself";
        break;
      case 4 /* ae */:
        return "(f)Ae / (f)Aer / (f)Aerself";
        break;
      case 5 /* e */:
        return "E(Ey) / Em / Eirelf";
        break;
      case 6 /* per */:
        return "Per / Per / Perself";
        break;
      case 7 /* ve */:
        return "Ve / Ver / Verself";
        break;
      case 8 /* xe */:
        return "Xe / Xem / Xemself";
        break;
      case 9 /* ze */:
        return "Ze(Zie) / Hir / Hirself";
        break;
    }
  }
};

// src/helpers/FileContentManager.ts
var import_obsidian10 = require("obsidian");
var FileContentManager = class {
  constructor(_app, _templateFileName) {
    this._app = _app;
    this._templateFileName = _templateFileName;
  }
  parse() {
    return __async(this, null, function* () {
      const templateFile = this._app.vault.getAbstractFileByPath(this._templateFileName);
      const content = yield this._app.vault.read(templateFile);
      const templateContentLines = content.split("\n").map(String);
      let frontmatterContent = "";
      let frontMatterStarted = false;
      let frontMatterCompleted = false;
      templateContentLines.forEach((content2) => {
        if (!frontMatterCompleted) {
          if (content2 === "---") {
            if (frontMatterStarted) {
              frontMatterCompleted = true;
            } else {
              frontMatterStarted = true;
            }
          } else {
            if (frontMatterStarted && !frontMatterCompleted) {
              frontmatterContent += content2 + "\n";
            }
          }
        } else if (!frontMatterStarted) {
          frontMatterStarted = true;
          frontMatterCompleted = true;
          if (this.templateContent === void 0)
            this.templateContent = "";
          this.templateContent += content2 + "\n";
        } else {
          if (this.templateContent === void 0)
            this.templateContent = "";
          this.templateContent += content2 + "\n";
        }
      });
      if (frontmatterContent !== "") {
        this.templateFrontMatter = (0, import_obsidian10.parseYaml)(frontmatterContent);
      }
    });
  }
};

// src/templates/abstracts/AbstractTemplate.ts
var AbstractTemplate = class extends AbstractRpgManager {
  constructor(app2, name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation) {
    super(app2);
    this.name = name;
    this.campaignId = campaignId;
    this.adventureId = adventureId;
    this.actId = actId;
    this.sceneId = sceneId;
    this.sessionId = sessionId;
    this.additionalInformation = additionalInformation;
    if (campaignId !== void 0)
      this.id = this.factories.id.create(this.type, campaignId, adventureId, actId, sceneId, sessionId);
  }
};

// src/components/components/campaign/templates/CampaignNotesTemplateFactory.ts
var CampaignNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Campaign Notes\n - \n\n---\n";
  }
};

// src/components/components/adventure/templates/AdventureNotesTemplateFactory.ts
var AdventureNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Adventure Notes\n - \n\n---\n";
  }
};

// src/components/components/character/templates/CharacterNotesTemplateFactory.ts
var CharacterNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Player Character Notes\n - \n\n---\n";
  }
};

// src/components/components/character/templates/NonPlayerCharacterNotesTemplateFactory.ts
var NonPlayerCharacterNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Non Player Character Notes\n - \n\n### Non Player Character Story\n - \n\n---\n";
  }
};

// src/components/components/clue/templates/ClueNotesTemplateFactory.ts
var ClueNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Clue Details\n - \n\n---\n";
  }
};

// src/components/components/location/templates/LocationNotesTemplateFactory.ts
var LocationNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Location Details\n - \n\n---\n";
  }
};

// src/components/components/faction/templates/FactionNotesTemplateFactory.ts
var FactionNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Faction Details\n - \n\n---\n";
  }
};

// src/components/components/event/templates/EventNotesTemplateFactory.ts
var EventNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Event Details\n - \n\n---\n";
  }
};

// src/components/components/act/templates/ActNotesTemplateFactory.ts
var ActNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Act Notes\n - \n\n---\n";
  }
};

// src/components/components/scene/templates/SceneNotesTemplateFactory.ts
var SceneNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Scene Notes\n - \n\n---\n";
  }
};

// src/components/components/session/templates/SessionNotesTemplateFactory.ts
var SessionNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    const characters = this.database.read((character) => character.id.type === 32 /* Character */ && character.id.campaignId === this.campaignId);
    let possibleRecappers = "";
    (characters || []).forEach((character) => {
      possibleRecappers += character.link + "/";
    });
    possibleRecappers = possibleRecappers.substring(0, possibleRecappers.length - 1);
    let response = "---\n### Session Notes\n\nPrevious Session Recap: " + possibleRecappers + "\n\n### Storyteller Diary\n-\n\n### End of Session Feedbacks\n";
    response += this._generateFeedback("Storyteller");
    (characters || []).forEach((character) => {
      response += this._generateFeedback(character.link);
    });
    response += "---\n";
    return response;
  }
  _generateFeedback(characterName) {
    return characterName + "\n- **Notes**: \n- **Wish**: \n- **Rose**: \n\n";
  }
};

// src/components/components/subplot/templates/SubplotNotesTemplateFactory.ts
var SubplotNotesTemplateFactory = class extends AbstractTemplate {
  getContent() {
    return "---\n### Subplot Notes\n - \n\n---\n";
  }
};

// src/helpers/YamlHelper.ts
var YamlHelper = class {
  static stringify(yaml) {
    let response = "";
    response = this._stringify(yaml, 0).join("\n") + "\n";
    return response;
  }
  static _stringify(yaml, indent, isArray = false) {
    const response = [];
    if (isArray) {
      for (let index = 0; index < yaml.length; index++) {
        const value = yaml[index];
        if (value == null) {
          response.push("");
        } else {
          switch (typeof value) {
            case "object":
              response.push(...this._stringify(value, indent + 1));
              break;
            case "number":
            case "boolean":
              response.push(value.toString());
              break;
            case "undefined":
              break;
            default:
              response.push('"' + value + '"');
              break;
          }
        }
      }
    } else {
      Object.entries(yaml).forEach(([key, value], index) => {
        const yamlKey = "  ".repeat(indent) + key + ": ";
        if (value == null) {
          response.push(yamlKey);
        } else if (Array.isArray(value)) {
          const yamlDataType = this._dataType(value);
          switch (yamlDataType) {
            case 0 /* Basic */:
              response.push(yamlKey + "[" + this._stringify(value, 0, true).join(",") + "]");
              break;
            case 2 /* Object */:
              response.push(yamlKey);
              for (let index2 = 0; index2 < value.length; index2++) {
                const arrayReponse = this._stringify(value[index2], 0, false);
                for (let responseIndex = 0; responseIndex < arrayReponse.length; responseIndex++) {
                  if (responseIndex === 0) {
                    arrayReponse[responseIndex] = "  ".repeat(indent + 1) + "- " + arrayReponse[responseIndex];
                  } else {
                    arrayReponse[responseIndex] = "  ".repeat(indent + 2) + arrayReponse[responseIndex];
                  }
                }
                response.push(...arrayReponse);
              }
              break;
          }
        } else {
          switch (typeof value) {
            case "object":
              response.push(yamlKey);
              response.push(...this._stringify(value, indent + 1));
              break;
            case "number":
            case "boolean":
              response.push(yamlKey + value);
              break;
            default:
              response.push(yamlKey + '"' + value + '"');
              break;
          }
        }
      });
    }
    return response;
  }
  static _dataType(values) {
    for (let index = 0; index < values.length; index++) {
      if (typeof values[index] === "object") {
        if (Array.isArray(values[index]))
          return 1 /* Array */;
        return 2 /* Object */;
      }
    }
    return 0 /* Basic */;
  }
};

// src/templates/abstracts/AbstractComponentTemplateFactory.ts
var AbstractComponentTemplateFactory = class extends AbstractRpgManager {
  constructor(app2, templateName, name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation) {
    super(app2);
    this.templateName = templateName;
    this.name = name;
    this.campaignId = campaignId;
    this.adventureId = adventureId;
    this.actId = actId;
    this.sceneId = sceneId;
    this.sessionId = sessionId;
    this.additionalInformation = additionalInformation;
  }
  generateData() {
    return __async(this, null, function* () {
      let templateFrontmatter;
      let templateContent;
      if (this.templateName != null && this.templateName != "") {
        if (this.templateName.startsWith("internal")) {
          switch (ComponentType[this.templateName.substring(8)]) {
            case 1 /* Campaign */:
              this.internalTemplate = new CampaignNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 2 /* Adventure */:
              this.internalTemplate = new AdventureNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 4 /* Act */:
              this.internalTemplate = new ActNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 8 /* Scene */:
              this.internalTemplate = new SceneNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 16 /* Session */:
              this.internalTemplate = new SessionNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 32 /* Character */:
              this.internalTemplate = new CharacterNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 64 /* NonPlayerCharacter */:
              this.internalTemplate = new NonPlayerCharacterNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 512 /* Clue */:
              this.internalTemplate = new ClueNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 128 /* Location */:
              this.internalTemplate = new LocationNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 1024 /* Faction */:
              this.internalTemplate = new FactionNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 256 /* Event */:
              this.internalTemplate = new EventNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
            case 4096 /* Subplot */:
              this.internalTemplate = new SubplotNotesTemplateFactory(this.app, this.name, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.additionalInformation);
              break;
          }
        } else {
          const templateContentManager = new FileContentManager(this.app, this.templateName);
          yield templateContentManager.parse();
          templateFrontmatter = templateContentManager.templateFrontMatter;
          templateContent = templateContentManager.templateContent;
        }
      }
      const frontmatter = {
        alias: [],
        tags: []
      };
      this.addFrontmatterData(frontmatter);
      this._mergeFrontmatters(frontmatter, templateFrontmatter);
      const dataCodeblock = this.generateDataCodeBlock();
      const initialCodeblock = this.generateInitialCodeBlock();
      const lastCodeblock = this.generateLastCodeBlock();
      if (this.internalTemplate !== void 0) {
        templateContent = this.internalTemplate.getContent();
      }
      const idCodeBlock = this.generateRpgManagerIDCodeBlock(this.generateID());
      return this._generateResponse(frontmatter, dataCodeblock, initialCodeblock, templateContent, lastCodeblock, idCodeBlock);
    });
  }
  _generateResponse(frontmatter, dataCodebBlock, initialCodeBlock, mainContent, lastCodeBlock, idCodeBlock) {
    let response;
    const frontmatterString = YamlHelper.stringify(frontmatter);
    const frontmatterParsedString = frontmatterString.replaceAll("{}", "");
    response = "---\n" + frontmatterParsedString + "---\n";
    response += dataCodebBlock;
    response += initialCodeBlock;
    response += mainContent != null ? mainContent : "\n";
    if (lastCodeBlock !== void 0)
      response += lastCodeBlock;
    response += idCodeBlock;
    return response;
  }
  _mergeFrontmatters(frontmatter, additionalFrontMatter) {
    if (additionalFrontMatter != null) {
      Object.entries(frontmatter).forEach(([frontmatterElementName, frontmatterElementValue]) => {
        if (typeof frontmatterElementValue !== "object") {
          if (additionalFrontMatter[frontmatterElementName] != null)
            frontmatter[frontmatterElementName] = additionalFrontMatter[frontmatterElementName];
        } else {
          if (this._isArray(frontmatterElementValue)) {
            if (additionalFrontMatter[frontmatterElementName] != null) {
              if (this._isArray(additionalFrontMatter[frontmatterElementName])) {
                Object.entries(additionalFrontMatter[frontmatterElementName]).forEach(([additionalFrontmatterElementName, additionalFrontmatterElementValue]) => {
                  let index;
                  Object.entries(frontmatterElementValue).forEach(([frontmatterSubElementName, frontmatterSubElementValue]) => {
                    if (additionalFrontmatterElementValue === frontmatterSubElementValue)
                      index = +frontmatterSubElementName;
                  });
                  if (index === void 0) {
                    if (!additionalFrontmatterElementValue.startsWith("rpgm/template/") && this.tagHelper.getTemplateDataType([additionalFrontmatterElementValue]) === void 0) {
                      frontmatterElementValue[frontmatterElementValue.length] = additionalFrontmatterElementValue;
                    }
                  }
                });
              } else {
                this._mergeFrontmatters(frontmatterElementValue, additionalFrontMatter[frontmatterElementName]);
              }
            }
          } else {
            this._mergeFrontmatters(frontmatterElementValue, additionalFrontMatter[frontmatterElementName]);
          }
        }
        if (typeof frontmatter[frontmatterElementValue] === "object" && additionalFrontMatter[frontmatterElementName] != null) {
          frontmatter[frontmatterElementName] = additionalFrontMatter[frontmatterElementName];
        }
      });
      Object.entries(additionalFrontMatter).forEach(([name, childFrontmatter]) => {
        if (frontmatter[name] == null) {
          if (typeof childFrontmatter === "string") {
            if (!childFrontmatter.startsWith("rpgm/template"))
              frontmatter[name] = childFrontmatter;
          } else {
            frontmatter[name] = childFrontmatter;
          }
        }
      });
    }
  }
  _isArray(list) {
    let response = false;
    Object.entries(list).forEach(([index, value]) => {
      if (!isNaN(+index)) {
        response = true;
      }
    });
    return response;
  }
  addFrontmatterData(frontmatter) {
  }
  generateDataCodeBlock() {
    return "";
  }
  generateInitialCodeBlock() {
    return "";
  }
  generateLastCodeBlock() {
    return void 0;
  }
  generateID() {
    return "";
  }
  generateRpgManagerDataCodeBlock(metadata) {
    let response = "```RpgManagerData\n";
    response += YamlHelper.stringify(metadata);
    response += "```\n";
    return response.replaceAll("''", "").replaceAll('""', "").replaceAll("{}", "");
  }
  generateRpgManagerCodeBlock(metadata) {
    let response = "```RpgManager\n";
    response += YamlHelper.stringify(metadata);
    response += "```\n";
    return response.replaceAll("''", "").replaceAll('""', "").replaceAll("{}", "");
  }
  generateRpgManagerIDCodeBlock(id) {
    const metadata = {
      id,
      checksum: Md5.hashStr(id)
    };
    let response = "```RpgManagerID\n";
    response += "### DO NOT EDIT MANUALLY IF NOT INSTRUCTED TO DO SO ###\n";
    response += YamlHelper.stringify(metadata);
    response += "```\n";
    return response;
  }
};

// src/components/components/campaign/templates/CampaignTemplateFactory.ts
var CampaignTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      plot: {
        abt: {
          need: "",
          and: "",
          but: "",
          therefore: ""
        },
        storycircle: {
          you: "",
          need: "",
          go: "",
          search: "",
          find: "",
          take: "",
          return: "",
          change: ""
        }
      },
      data: {
        date: "",
        synopsis: "",
        complete: false,
        currentAdventureId: "",
        currentActId: "",
        currentSessionId: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateLastCodeBlock() {
    const metadata = {
      models: {
        lists: {
          pcs: {
            relationship: "hierarchy"
          },
          subplots: {
            relationship: "hierarchy"
          },
          adventures: {
            relationship: "hierarchy"
          },
          acts: {
            relationship: "hierarchy"
          },
          sessions: {
            relationship: "hierarchy"
          },
          events: {
            relationship: "hierarchy"
          },
          npcs: {
            relationship: "hierarchy"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 1 /* Campaign */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/adventure/templates/AdventureTemplateFactory.ts
var AdventureTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      plot: {
        abt: {
          need: "",
          and: "",
          but: "",
          therefore: ""
        },
        storycircle: {
          you: "",
          need: "",
          go: "",
          search: "",
          find: "",
          take: "",
          return: "",
          change: ""
        }
      },
      data: {
        synopsis: "",
        complete: false
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateLastCodeBlock() {
    const metadata = {
      models: {
        lists: {
          acts: {
            relationship: "hierarchy"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 2 /* Adventure */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId + "/" + this.adventureId;
  }
};

// src/components/components/act/templates/ActTemplateFactory.ts
var ActTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      plot: {
        abt: {
          need: "",
          and: "",
          but: "",
          therefore: ""
        },
        storycircle: {
          you: "",
          need: "",
          go: "",
          search: "",
          find: "",
          take: "",
          return: "",
          change: ""
        }
      },
      data: {
        synopsis: "",
        complete: false,
        abtStage: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateLastCodeBlock() {
    const metadata = {
      models: {
        lists: {
          scenes: {
            relationship: "hierarchy"
          },
          pcs: {
            relationship: "unidirectional"
          },
          npcs: {
            relationship: "unidirectional"
          },
          clues: {
            relationship: "unidirectional"
          },
          locations: {
            relationship: "unidirectional"
          },
          factions: {
            relationship: "unidirectional"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 4 /* Act */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId + "/" + this.adventureId + "/" + this.actId;
  }
};

// src/components/components/scene/templates/SceneTemplateFactory.ts
var SceneTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        sessionId: 0,
        action: "",
        trigger: "",
        date: "",
        sceneType: "",
        isActedUpon: false,
        duration: 0,
        durations: [],
        storyCircleStage: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateLastCodeBlock() {
    const metadata = {
      models: {
        lists: {
          musics: {
            relationship: "unidirectional"
          },
          pcs: {
            relationship: "unidirectional"
          },
          npcs: {
            relationship: "unidirectional"
          },
          factions: {
            relationship: "unidirectional"
          },
          clues: {
            relationship: "unidirectional"
          },
          locations: {
            relationship: "unidirectional"
          },
          events: {
            relationship: "unidirectional"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 8 /* Scene */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId + "/" + this.adventureId + "/" + this.actId + "/" + this.sceneId;
  }
};

// src/components/components/character/templates/CharacterTemplateFactory.ts
var CharacterTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        dob: "",
        death: "",
        goals: "",
        pronoun: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          pcs: {
            relationship: "unidirectional"
          },
          npcs: {
            relationship: "unidirectional"
          },
          factions: {},
          locations: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 32 /* Character */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/character/templates/NonPlayerCharacterTemplateFactory.ts
var NonPlayerCharacterTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        death: "",
        dob: "",
        goals: "",
        pronoun: "",
        complete: false
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          subplots: {},
          pcs: {
            relationship: "unidirectional"
          },
          npcs: {
            relationship: "unidirectional"
          },
          factions: {},
          locations: {},
          events: {},
          clues: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 64 /* NonPlayerCharacter */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/location/templates/LocationTemplateFactory.ts
var LocationTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        address: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          pcs: {},
          npcs: {},
          events: {},
          clues: {},
          locations: [
            {
              relationship: "parent",
              title: "Inside"
            },
            {
              relationship: "child",
              title: "Contains"
            }
          ]
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 128 /* Location */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/event/templates/EventTemplateFactory.ts
var EventTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        date: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          subplots: {},
          pcs: {},
          npcs: {},
          clues: {},
          locations: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 256 /* Event */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/clue/templates/ClueTemplateFactory.ts
var ClueTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        found: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          subplots: {},
          pcs: {},
          npcs: {},
          locations: {},
          clues: {},
          events: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 512 /* Clue */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/faction/templates/FactionTemplateFactory.ts
var FactionTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          pcs: {},
          npcs: {},
          locations: {},
          subplots: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 1024 /* Faction */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/music/templates/MusicTemplateFactory.ts
var MusicTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        url: ""
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          musics: [
            {
              relationship: "parent",
              title: "Part of playlists"
            },
            {
              relationship: "child",
              title: "Songs"
            }
          ]
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 2048 /* Music */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/components/components/session/templates/SessionTemplateFactory.ts
var SessionTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      data: {
        synopsis: "",
        complete: false,
        irl: void 0,
        abtStage: void 0
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          scenes: {
            relationship: "hierarchy"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateLastCodeBlock() {
    const metadata = {
      models: {
        lists: {
          subplots: {
            relationship: "hierarchy"
          },
          musics: {
            relationship: "hierarchy"
          },
          pcs: {
            relationship: "hierarchy"
          },
          npcs: {
            relationship: "hierarchy"
          },
          factions: {
            relationship: "hierarchy"
          },
          clues: {
            relationship: "hierarchy"
          },
          locations: {
            relationship: "hierarchy"
          },
          events: {
            relationship: "hierarchy"
          }
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 16 /* Session */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId + "/" + this.sessionId;
  }
};

// src/components/components/subplot/templates/SubplotTemplateFactory.ts
var SubplotTemplateFactory = class extends AbstractComponentTemplateFactory {
  generateDataCodeBlock() {
    const metadata = {
      plot: {
        abt: {
          need: "",
          and: "",
          but: "",
          therefore: ""
        },
        storycircle: {
          you: "",
          need: "",
          go: "",
          search: "",
          find: "",
          take: "",
          return: "",
          change: ""
        }
      },
      data: {
        synopsis: "",
        complete: false
      }
    };
    return this.generateRpgManagerDataCodeBlock(metadata);
  }
  generateInitialCodeBlock() {
    const metadata = {
      models: {
        header: true,
        lists: {
          events: {},
          clues: {},
          factions: {},
          npcs: {},
          locations: {}
        }
      }
    };
    return this.generateRpgManagerCodeBlock(metadata);
  }
  generateID() {
    return 4096 /* Subplot */ + "-" + 0 /* Agnostic */ + "-" + this.campaignId;
  }
};

// src/templates/factories/TemplateFactory.ts
var TemplateFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
    this._templateTypeMap = /* @__PURE__ */ new Map();
    this._templateTypeMap.set("AgnosticCampaign", CampaignTemplateFactory);
    this._templateTypeMap.set("AgnosticAdventure", AdventureTemplateFactory);
    this._templateTypeMap.set("AgnosticAct", ActTemplateFactory);
    this._templateTypeMap.set("AgnosticScene", SceneTemplateFactory);
    this._templateTypeMap.set("AgnosticSession", SessionTemplateFactory);
    this._templateTypeMap.set("AgnosticCharacter", CharacterTemplateFactory);
    this._templateTypeMap.set("AgnosticNonPlayerCharacter", NonPlayerCharacterTemplateFactory);
    this._templateTypeMap.set("AgnosticLocation", LocationTemplateFactory);
    this._templateTypeMap.set("AgnosticEvent", EventTemplateFactory);
    this._templateTypeMap.set("AgnosticClue", ClueTemplateFactory);
    this._templateTypeMap.set("AgnosticFaction", FactionTemplateFactory);
    this._templateTypeMap.set("AgnosticMusic", MusicTemplateFactory);
    this._templateTypeMap.set("AgnosticSubplot", SubplotTemplateFactory);
  }
  create(settings, type, templateName, name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation = null) {
    let templateKey = CampaignSetting[settings] + ComponentType[type];
    if (!this._templateTypeMap.has(templateKey))
      templateKey = CampaignSetting[0 /* Agnostic */] + ComponentType[type];
    if (!this._templateTypeMap.has(templateKey))
      throw new Error("Type of template " + CampaignSetting[settings] + ComponentType[type] + " cannot be found");
    return new (this._templateTypeMap.get(templateKey))(this.app, templateName, name, campaignId, adventureId, actId, sceneId, sessionId, additionalInformation);
  }
};

// src/helpers/EditorSelector.ts
var import_obsidian11 = require("obsidian");
var EditorSelector = class {
  static focusOnDataKey(app2, currentComponent, dataId = void 0) {
    var _a;
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian11.MarkdownView);
    if (activeView == null)
      return;
    const metadata = app2.metadataCache.getFileCache(currentComponent.file);
    if (metadata == null || metadata.sections === void 0 || ((_a = metadata.sections) == null ? void 0 : _a.length) === 0)
      return;
    for (let index = 0; index < metadata.sections.length; index++) {
      const editor = activeView.editor;
      if (metadata.sections[index].type === "code" && editor.getLine(metadata.sections[index].position.start.line) === "```RpgManagerData") {
        let metadataKeyStart = void 0;
        let metadataKeyEnd = void 0;
        if (dataId !== void 0) {
          const metadataPositions = this._findDataIdPosition(metadata.sections[index].position.start.line + 1, metadata.sections[index].position.end.line, editor, dataId);
          if (metadataPositions !== void 0) {
            metadataKeyStart = metadataPositions.from;
            metadataKeyEnd = metadataPositions.to;
          }
        }
        if (metadataKeyStart === void 0) {
          metadataKeyStart = { line: metadata.sections[index].position.start.line + 2, ch: 0 };
          metadataKeyEnd = { line: metadata.sections[index].position.end.line, ch: 0 };
        }
        if (metadataKeyStart !== void 0 && metadataKeyEnd !== void 0)
          return this._setPositionsAndScroll(editor, metadataKeyStart, metadataKeyEnd);
      }
    }
  }
  static focusOnDataRelationshipDescription(app2, currentComponent, path2) {
    var _a;
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian11.MarkdownView);
    if (activeView == null)
      return;
    const metadata = app2.metadataCache.getFileCache(currentComponent.file);
    if (metadata == null || metadata.sections === void 0 || ((_a = metadata.sections) == null ? void 0 : _a.length) === 0)
      return;
    for (let index = 0; index < metadata.sections.length; index++) {
      const editor = activeView.editor;
      if (metadata.sections[index].type === "code" && editor.getLine(metadata.sections[index].position.start.line) === "```RpgManagerData") {
        const dataYaml = metadata.sections !== void 0 ? metadata.sections[index] : void 0;
        let metadataKeyStart = void 0;
        let metadataKeyEnd = void 0;
        if (dataYaml === void 0) {
          metadataKeyStart = { line: metadata.sections[index].position.start.line + 2, ch: 0 };
          metadataKeyEnd = { line: metadata.sections[index].position.end.line, ch: 0 };
          return this._setPositionsAndScroll(editor, metadataKeyStart, metadataKeyEnd);
        } else {
          let relationshipsStarted = false;
          for (let lineIndex = dataYaml.position.start.line + 1; lineIndex < dataYaml.position.end.line; lineIndex++) {
            if (editor.getLine(lineIndex).trim().toLowerCase() === "relationships:") {
              relationshipsStarted = true;
              continue;
            }
            if (!relationshipsStarted)
              continue;
            if (editor.getLine(lineIndex).trim().toLowerCase().startsWith("- type:")) {
              const startOfPath = editor.getLine(lineIndex + 1).indexOf("path: ");
              if (startOfPath !== -1 && editor.getLine(lineIndex + 1).substring(startOfPath + 6).trim() === path2) {
                const startOfDescription = editor.getLine(lineIndex + 2).indexOf("description: ");
                if (startOfDescription !== -1) {
                  return this._setCoordinatesAndScroll(editor, lineIndex + 2, startOfDescription + 13, lineIndex + 2, editor.getLine(lineIndex + 2).length);
                } else {
                  let relatioshipContent = editor.getRange({ line: lineIndex, ch: 0 }, { line: lineIndex + 2, ch: 0 });
                  relatioshipContent += " ".repeat(startOfPath) + "description: \n";
                  editor.replaceRange(relatioshipContent, { line: lineIndex, ch: 0 }, { line: lineIndex + 2, ch: 0 });
                  return this._setCoordinatesAndScroll(editor, lineIndex + 2, startOfPath + 13, lineIndex + 2, startOfPath + 13);
                }
              }
            }
          }
          let newRelationship = "";
          if (!relationshipsStarted)
            newRelationship += "relationships:\n";
          newRelationship += "  - type: unidirectional\n    path: " + path2 + "\n    description: \n```\n";
          editor.replaceRange(newRelationship, { line: dataYaml.position.end.line, ch: 0 }, { line: dataYaml.position.end.line + 1, ch: 0 });
          return this._setCoordinatesAndScroll(editor, dataYaml.position.end.line + 2, 17, dataYaml.position.end.line + 2, 17);
        }
      }
    }
  }
  static _setCoordinatesAndScroll(editor, startLine, startCharacter, endLine, endCharacter) {
    const metadataKeyStart = { line: startLine, ch: startCharacter };
    const metadataKeyEnd = { line: endLine, ch: endCharacter };
    return this._setPositionsAndScroll(editor, metadataKeyStart, metadataKeyEnd);
  }
  static _setPositionsAndScroll(editor, start, end) {
    editor.setSelection(start, end);
    editor.scrollIntoView({ from: start, to: end }, true);
    editor.focus();
  }
  static _findDataIdPosition(start, end, editor, dataId) {
    const arr = editor.getRange({ line: start, ch: 0 }, { line: end, ch: 0 }).split("\n");
    const arrKey = dataId.split(".");
    let startLine = 0;
    while (arrKey.length !== 0) {
      let breakMe = true;
      for (let index = startLine; index < arr.length; index++) {
        if (arr[index].trimStart().startsWith(arrKey[0] + ":")) {
          if (arrKey.length === 1) {
            const startingPosition = arr[index].indexOf(arrKey[0] + ":") + arrKey[0].length + 2;
            const text = arr[index].substring(startingPosition);
            let response = void 0;
            if (text[0] === '"') {
              response = {
                from: { line: start + index, ch: startingPosition + 1 },
                to: { line: start + index, ch: arr[index].length - 1 }
              };
            } else {
              response = {
                from: { line: start + index, ch: startingPosition },
                to: { line: start + index, ch: arr[index].length }
              };
            }
            return response;
          } else {
            arrKey.shift();
            startLine = index + 1;
            breakMe = false;
            break;
          }
        }
      }
      if (breakMe)
        break;
    }
    return void 0;
  }
};

// src/views/abstracts/AbstractSubModelView.ts
var AbstractSubModelView = class extends AbstractRpgManager {
  constructor(app2, sourcePath) {
    super(app2);
    this.sourcePath = sourcePath;
  }
  addEditorIcon(cellEl, currentComponent, identifier) {
    this._createEditorButton(cellEl).addEventListener("click", () => {
      EditorSelector.focusOnDataKey(this.app, currentComponent, identifier);
    });
  }
  addRelationshipEditorIcon(cellEl, currentComponent, identifier) {
    this._createEditorButton(cellEl).addEventListener("click", () => {
      EditorSelector.focusOnDataRelationshipDescription(this.app, currentComponent, identifier);
    });
  }
  _createEditorButton(containerEl) {
    containerEl.addClass("editable");
    const response = document.createElement("span");
    response.addClass("editorIcon");
    response.textContent = "</>";
    containerEl.prepend(response);
    return response;
  }
};

// src/views/subViews/TableView.ts
var import_obsidian12 = require("obsidian");
var TableView = class extends AbstractSubModelView {
  render(container, data) {
    const divContainer = container.createDiv();
    if (data.title != null) {
      const headerEl = divContainer.createEl("h3", { cls: "rpgm-table-header" });
      const arrowEl = headerEl.createSpan();
      arrowEl.style.marginRight = "10px";
      (0, import_obsidian12.setIcon)(arrowEl, "openClose");
      const arrowIconEl = arrowEl.children[0];
      if (data.open) {
        arrowIconEl.style.transform = "rotate(90deg)";
      }
      headerEl.createSpan({ text: data.title });
      headerEl.addEventListener("click", () => {
        if (this._tableEl.style.display === "none") {
          this._tableEl.style.display = "";
          arrowIconEl.style.transform = "rotate(90deg)";
        } else {
          this._tableEl.style.display = "none";
          arrowIconEl.style.transform = "rotate(0deg)";
        }
      });
      if (data.class === "rpgm-plot") {
        const titleEditor = headerEl.createEl("span", { cls: "rpgm-td-edit", text: "edit" });
        titleEditor.addEventListener("click", () => {
          EditorSelector.focusOnDataKey(this.app, data.currentComponent);
        });
      }
    }
    if (data.create !== void 0) {
      const createButtonEl = divContainer.createEl("button", { cls: "create-button" });
      let id;
      switch (data.create) {
        case 2 /* Adventure */:
          createButtonEl.textContent = "Create act from Adventure Plot";
          createButtonEl.addEventListener("click", () => {
            if (data.campaignId !== void 0 && data.adventureId !== void 0) {
              id = this.factories.id.create(2 /* Adventure */, data.campaignId, data.adventureId);
              if (id !== void 0) {
                const previousAdventure = this.database.readSingle(2 /* Adventure */, id, data.adventureId - 1);
                let nextActId = 1;
                if (previousAdventure != null) {
                  const previousAdventureActs = this.database.readList(4 /* Act */, id, previousAdventure.id.adventureId);
                  previousAdventureActs.forEach((act) => {
                    var _a, _b;
                    if (nextActId <= ((_a = act.id.actId) != null ? _a : 0))
                      nextActId = ((_b = act.id.actId) != null ? _b : 0) + 1;
                  });
                }
                data.content.forEach((element) => {
                  const content = element.elements[1];
                  if (data.campaignId != null) {
                    this.factories.files.silentCreate(4 /* Act */, "Act " + nextActId, data.campaignId, data.adventureId, nextActId, void 0, void 0, {
                      synopsis: content.content
                    });
                  }
                  nextActId++;
                });
              }
              createButtonEl.style.display = "none";
            }
          });
          break;
      }
    }
    this._tableEl = divContainer.createEl("table");
    this._tableEl.addClass("rpgm-table");
    this._tableEl.style.display = data.open ? "" : "none";
    if (data.class != null) {
      this._tableEl.addClass(data.class);
    }
    if (data.headers != null && data.headers.length > 0) {
      const header = this._tableEl.createEl("tr");
      data.headers.forEach((content) => {
        const cell = header.createEl("th");
        content.fillContent(cell, this.sourcePath);
        if (content.isInLine) {
          cell.addClass("inline");
        }
      });
    }
    const tableBodyElement = this._tableEl.createTBody();
    data.content.forEach((element) => {
      const row = tableBodyElement.insertRow();
      row.addClass("hoverable");
      const isRowEditable = element.relationship !== void 0 && (element.relationship.type !== 8 /* Parent */ && element.relationship.type !== 32 /* Hierarchy */);
      if (isRowEditable)
        row.addClass("editable");
      element.elements.forEach((content) => {
        const cell = row.insertCell();
        if (content instanceof DateContent)
          cell.style.fontSize = "0.7em";
        if (content instanceof ImageContent)
          cell.addClass("image");
        content.fillContent(cell, this.sourcePath);
        if (content.isInLine)
          cell.addClass("inline");
        if (content.isEditable && isRowEditable)
          cell.addClass("editable");
        if (content.isEditable && isRowEditable) {
          this.addRelationshipEditorIcon(cell, data.currentComponent, element.relationship.path);
        }
      });
    });
  }
};

// src/views/subViews/BreadcrumbView.ts
var import_obsidian17 = require("obsidian");

// src/abstracts/AbstractRpgManagerModal.ts
var import_obsidian13 = require("obsidian");
var AbstractRpgManagerModal = class extends import_obsidian13.Modal {
  constructor(app2) {
    super(app2);
    this.app = app2;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
};

// src/relationships/modals/RelationshipsSelectionModal.ts
var import_obsidian14 = require("obsidian");
var RelationshipsSelectionModal = class extends AbstractRpgManagerModal {
  constructor(app2, _currentComponent) {
    super(app2);
    this._currentComponent = _currentComponent;
    this._availableRelationships = /* @__PURE__ */ new Map([
      [1 /* Campaign */, []],
      [2 /* Adventure */, [64 /* NonPlayerCharacter */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */, 256 /* Event */, 32 /* Character */]],
      [4 /* Act */, [64 /* NonPlayerCharacter */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */, 256 /* Event */, 32 /* Character */]],
      [8 /* Scene */, [64 /* NonPlayerCharacter */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */, 256 /* Event */, 32 /* Character */]],
      [16 /* Session */, []],
      [4096 /* Subplot */, [64 /* NonPlayerCharacter */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */, 256 /* Event */, 4096 /* Subplot */]],
      [32 /* Character */, [64 /* NonPlayerCharacter */, 32 /* Character */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */]],
      [64 /* NonPlayerCharacter */, [64 /* NonPlayerCharacter */, 32 /* Character */, 1024 /* Faction */, 128 /* Location */, 512 /* Clue */, 256 /* Event */, 4096 /* Subplot */]],
      [512 /* Clue */, [512 /* Clue */, 256 /* Event */, 128 /* Location */, 1024 /* Faction */, 64 /* NonPlayerCharacter */, 4096 /* Subplot */]],
      [256 /* Event */, [256 /* Event */, 512 /* Clue */, 128 /* Location */, 1024 /* Faction */, 64 /* NonPlayerCharacter */, 4096 /* Subplot */]],
      [1024 /* Faction */, [1024 /* Faction */, 128 /* Location */, 256 /* Event */, 512 /* Clue */, 4096 /* Subplot */]],
      [128 /* Location */, [128 /* Location */, 1024 /* Faction */, 32 /* Character */, 64 /* NonPlayerCharacter */, 512 /* Clue */, 256 /* Event */]],
      [2048 /* Music */, [2048 /* Music */]]
    ]);
    this._relationshipTypeAllowedChildren = /* @__PURE__ */ new Map([
      [512 /* Clue */, true],
      [256 /* Event */, true],
      [1024 /* Faction */, true],
      [128 /* Location */, true],
      [2048 /* Music */, true]
    ]);
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "var(--modal-max-width)";
    const relationshipsModalEl = contentEl.createDiv({ cls: "rpgm-modal-relationships" });
    relationshipsModalEl.createEl("h2", { text: "Relationship Selector" });
    const relationshipShortlistenersContainerEl = relationshipsModalEl.createDiv({ cls: "clearfix" });
    this._requiredRelationshipType(relationshipShortlistenersContainerEl);
    this._componentSearcher(relationshipShortlistenersContainerEl);
    this._relationshipsEl = relationshipsModalEl.createDiv({ cls: "relationships", text: "" });
    this._addElementsToList();
  }
  _requiredRelationshipType(contentEl) {
    const relationshipSelectorEl = contentEl.createDiv({ cls: "relationship-select" });
    relationshipSelectorEl.createDiv().createEl("label", { text: "Select the type of component" });
    this._relationshipTypeSelectorEl = relationshipSelectorEl.createEl("select");
    this._relationshipTypeSelectorEl.createEl("option", {
      text: "Existing Relationships",
      value: ""
    });
    const availableRelationships = this._availableRelationships.get(this._currentComponent.id.type);
    if (availableRelationships !== void 0 && availableRelationships.length > 0) {
      availableRelationships.forEach((type) => {
        this._relationshipTypeSelectorEl.createEl("option", {
          text: ComponentType[type] + "s",
          value: type.toString()
        });
      });
      this._relationshipTypeSelectorEl.addEventListener("change", () => {
        this._relationshipsEl.empty();
        let value = void 0;
        if (this._relationshipTypeSelectorEl.value !== "")
          value = +this._relationshipTypeSelectorEl.value;
        this._addElementsToList(value);
      });
    }
  }
  _componentSearcher(contentEl) {
    const componentSearchContainerEl = contentEl.createDiv({ cls: "relationship-select" });
    const searchTitle = this._relationshipTypeSelectorEl.value === "" ? "Search a specific Component" : "Search a specific " + ComponentType[this._relationshipTypeSelectorEl.value];
    componentSearchContainerEl.createDiv().createEl("label", { text: searchTitle });
    const searchTermEl = componentSearchContainerEl.createEl("input", { type: "text" });
    searchTermEl.addEventListener("keyup", () => {
      this._relationshipsEl.empty();
      let value = void 0;
      if (this._relationshipTypeSelectorEl.value !== "")
        value = +this._relationshipTypeSelectorEl.value;
      this._addElementsToList(value, searchTermEl.value);
    });
  }
  _addElementsToList(type, searchTerm) {
    const relationshipsTableEl = this._relationshipsEl.createEl("table").createTBody();
    const components = this.search(type, searchTerm);
    components.forEach((component) => {
      var _a, _b;
      if (component.id !== this._currentComponent.id) {
        const relationships = this._currentComponent.getRelationships().filter((relationship2) => {
          var _a2;
          return ((_a2 = relationship2.component) == null ? void 0 : _a2.file.basename) === component.file.basename;
        });
        const relationship = (_a = relationships[0]) != null ? _a : void 0;
        const rowEl = relationshipsTableEl.insertRow();
        const checkboxEl = rowEl.insertCell().createEl("input");
        checkboxEl.type = "checkbox";
        checkboxEl.value = component.file.path;
        checkboxEl.id = component.file.basename;
        if (relationship !== void 0) {
          checkboxEl.checked = true;
          if (relationship.isInContent || relationship.type === 8 /* Parent */)
            checkboxEl.disabled = true;
        }
        if (relationship !== void 0)
          checkboxEl.checked = true;
        const imageCellEl = rowEl.insertCell();
        if (component.images.length > 0) {
          const img = new Image(40, 40);
          img.onload = (evt) => {
            img.style.objectFit = "cover";
            imageCellEl.append(img);
          };
          img.src = component.images[0].src;
        }
        const relationshipTypeSelectorEl = this._addRelationshipTypeSelector(component, relationship, rowEl.insertCell(), checkboxEl);
        const titleCell = rowEl.insertCell();
        titleCell.addClass("label");
        const checkboxLabel = titleCell.createEl("label", { text: component.file.basename });
        checkboxLabel.htmlFor = component.file.basename;
        if (relationship !== void 0) {
          if (relationship.isInContent) {
            titleCell.createEl("br");
            titleCell.createSpan({ text: "relationship in the notes cannot be removed" });
          } else if (relationship.type === 8 /* Parent */) {
            titleCell.createEl("br");
            titleCell.createSpan({ text: "parent element can only be removed from the parent" });
          } else if (relationship.description != void 0 && relationship.description !== "") {
            titleCell.createEl("br");
            titleCell.createSpan({ text: "removing this relationship deletes its description" });
          }
        }
        const synopsisEl = rowEl.insertCell();
        synopsisEl.addClass("description");
        import_obsidian14.MarkdownRenderer.renderMarkdown(relationship !== void 0 && relationship.description != void 0 && relationship.description !== "" ? relationship.description : (_b = component.synopsis) != null ? _b : "", synopsisEl, "", null);
        checkboxEl.addEventListener("change", () => {
          this._addOrRemoveElementRelationship(checkboxEl, relationshipTypeSelectorEl, component, relationship);
        });
      }
    });
  }
  _addRelationshipTypeSelector(component, relationship, containerEl, checkboxEl) {
    containerEl.addClass("selector");
    const availableRelationshipsType = /* @__PURE__ */ new Map();
    if (this._currentComponent.id.type !== component.id.type)
      availableRelationshipsType.set(2 /* Bidirectional */, this.factories.relationshipType.createReadableRelationshipType(2 /* Bidirectional */));
    availableRelationshipsType.set(4 /* Unidirectional */, this.factories.relationshipType.createReadableRelationshipType(4 /* Unidirectional */));
    if (this._currentComponent.id.type === component.id.type && this._relationshipTypeAllowedChildren.has(component.id.type))
      availableRelationshipsType.set(16 /* Child */, this.factories.relationshipType.createReadableRelationshipType(16 /* Child */));
    const relationshipTypeSelectorEl = containerEl.createEl("select");
    if (availableRelationshipsType.size === 1) {
      const [singleValue] = availableRelationshipsType.values();
      relationshipTypeSelectorEl.createEl("option", {
        text: singleValue,
        value: singleValue
      }).selected = true;
    } else {
      let isFirst = true;
      availableRelationshipsType.forEach((relationshipTypeDescription, relationshipType) => {
        const currentOptionEl = relationshipTypeSelectorEl.createEl("option", {
          text: relationshipTypeDescription,
          value: relationshipTypeDescription
        });
        if (isFirst) {
          currentOptionEl.selected = true;
          isFirst = false;
        } else if (relationship !== void 0 && relationship.type === relationshipType)
          currentOptionEl.selected = true;
        if (relationship !== void 0 && relationship.type === 8 /* Parent */) {
          relationshipTypeSelectorEl.createEl("option", {
            text: "parent",
            value: "parent"
          }).selected = true;
        }
      });
    }
    if (relationship !== void 0 && relationship.type === 8 /* Parent */)
      relationshipTypeSelectorEl.disabled = true;
    relationshipTypeSelectorEl.addEventListener("change", () => {
      if (checkboxEl.checked === false)
        checkboxEl.checked = true;
      this._addOrRemoveElementRelationship(checkboxEl, relationshipTypeSelectorEl, component, relationship);
    });
    return relationshipTypeSelectorEl;
  }
  _addOrRemoveElementRelationship(checkboxEl, relationshipTypeSelectorEl, relatedComponent, existingRelationship) {
    if (checkboxEl.checked) {
      const relationshipType = relationshipTypeSelectorEl.value === "" ? 2 /* Bidirectional */ : this.factories.relationshipType.createRelationshipType(relationshipTypeSelectorEl.value);
      const newRelationship = this.factories.relationship.create(relationshipType, relatedComponent.file.path, existingRelationship == null ? void 0 : existingRelationship.description, relatedComponent, false, this._currentComponent.getRelationships());
      this.manipulators.codeblock.addOrUpdateRelationship(newRelationship);
    } else {
      this.manipulators.codeblock.removeRelationship(relatedComponent.file.path);
    }
  }
  onClose() {
    super.onClose();
  }
  search(type, term) {
    let components = [];
    if (type !== void 0) {
      components = this.database.readList(type, this._currentComponent.id).sort(this.factories.sorter.create([
        new SorterComparisonElement((component) => this._currentComponent.getRelationships().existsAlready(component), 1 /* Descending */),
        new SorterComparisonElement((component) => component.file.stat.mtime, 1 /* Descending */)
      ]));
    } else {
      components = this.database.recordset.filter((component) => this._currentComponent.getRelationships().existsAlready(component)).sort(this.factories.sorter.create([
        new SorterComparisonElement((component) => component.file.stat.mtime, 1 /* Descending */)
      ]));
    }
    if (term === void 0)
      return components;
    const matches = /* @__PURE__ */ new Map();
    const query = (0, import_obsidian14.prepareQuery)(term);
    components.forEach((component) => {
      component.alias.forEach((alias) => {
        if (alias.toLowerCase().startsWith(term.toLowerCase()))
          matches.set(component.id, { component });
      });
      if (!matches.has(component.id)) {
        const fuzzySearchResult = (0, import_obsidian14.fuzzySearch)(query, component.file.basename + " " + component.synopsis);
        if (fuzzySearchResult != null && fuzzySearchResult.matches !== null)
          matches.set(component.id, { component, result: fuzzySearchResult });
      }
    });
    if (matches.size === 0)
      return [];
    const resultArray = [];
    matches.forEach((value) => {
      resultArray.push(value);
    });
    resultArray.sort((a, b) => {
      var _a, _b, _c, _d;
      if (a.result === void 0 && b.result !== void 0)
        return -1;
      if (a.result !== void 0 && b.result === void 0)
        return 1;
      if (a.result === void 0 && b.result === void 0)
        return 0;
      if (a.result !== void 0 && b.result !== void 0) {
        if (((_a = a.result) == null ? void 0 : _a.score) !== void 0 && ((_b = b.result) == null ? void 0 : _b.score) === void 0)
          return -1;
        if (((_c = a.result) == null ? void 0 : _c.score) === void 0 && ((_d = b.result) == null ? void 0 : _d.score) !== void 0)
          return 1;
        return b.result.score - a.result.score;
      }
      return 0;
    });
    const response = [];
    resultArray.forEach((value) => {
      response.push(value.component);
    });
    return response;
  }
};

// src/modals/abstracts/AbstractModal.ts
var AbstractModal = class extends AbstractRpgManagerModal {
  constructor() {
    super(...arguments);
    this.maxWidth = false;
  }
  onOpen() {
    var _a;
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rpgm-modal");
    if (this.maxWidth)
      this.modalEl.style.width = "var(--modal-max-width)";
    const mainContainer = contentEl.createDiv({ cls: "rpgm-modal-container" });
    mainContainer.createEl("h2", { text: (_a = this.title) != null ? _a : "RPG Manager" });
    this.rpgmContainerEl = mainContainer.createDiv({ cls: "rpgm-modal-main-container" });
  }
};

// src/databases/DatabaseInitialiser.ts
var import_obsidian16 = require("obsidian");

// src/modals/DatabaseErrorModal.ts
var import_obsidian15 = require("obsidian");
var DatabaseErrorModal = class extends AbstractRpgManagerModal {
  constructor(app2, _misconfiguredTags, _singleError = void 0, _singleErrorFile = void 0) {
    super(app2);
    this._misconfiguredTags = _misconfiguredTags;
    this._singleError = _singleError;
    this._singleErrorFile = _singleErrorFile;
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h1", { cls: "error", text: "RPG Manager Error" });
    if (this._singleError !== void 0 && this._singleErrorFile !== void 0 && this._misconfiguredTags === void 0) {
      this._misconfiguredTags = /* @__PURE__ */ new Map();
      this._misconfiguredTags.set(this._singleErrorFile, this._singleError);
    }
    if (this._misconfiguredTags === void 0)
      this._misconfiguredTags = /* @__PURE__ */ new Map();
    contentEl.createEl("p", { text: "One or more of the tags that define an outline or an element are not correctly configured and can't be read!" });
    contentEl.createEl("p", { text: "Please double check the errors and correct them." });
    this._misconfiguredTags.forEach((error, file) => {
      var _a;
      const errorEl = contentEl.createEl("div");
      const title = (_a = error.getErrorTitle()) != null ? _a : file.basename;
      import_obsidian15.MarkdownRenderer.renderMarkdown("**" + title + "**\n" + error.showErrorMessage(), errorEl, file.path, null);
    });
    const viewErrorsButtonEl = contentEl.createEl("button", { text: "Fix errors" });
    viewErrorsButtonEl.addEventListener("click", () => {
      this.app.plugins.getPlugin("rpg-manager").factories.views.showObsidianView("rpgm-error-view" /* Errors */, [this._misconfiguredTags]);
      this.close();
    });
  }
  onClose() {
    super.onClose();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/errors/TagMisconfiguredError.ts
var TagMisconfiguredError = class extends AbstractRpgManagerError {
  showErrorMessage() {
    var _a, _b;
    let response = "The tag `" + this.id.tag + "` is misconfigured\nThe correct tag should be ";
    let requiredId = "";
    switch (this.id.type) {
      case 8 /* Scene */:
        requiredId = "/{sceneId}" + requiredId;
      case 4 /* Act */:
        requiredId = "/{actId}" + requiredId;
      case 2 /* Adventure */:
        requiredId = "/{adventureId}" + requiredId;
      default:
        requiredId = "/{campaignId}" + requiredId;
    }
    response += "`" + ((_a = this.tagHelper.dataSettings.get(this.id.type)) != null ? _a : "") + requiredId + "`\n";
    (_b = this.id.invalidIds) == null ? void 0 : _b.forEach((status, type) => {
      response += " - {" + ComponentType[type].toLowerCase() + "Id} is " + (status === 2 /* Missing */ ? "missing" : "not a valid numeric id") + "\n";
    });
    return response;
  }
  showErrorActions() {
    var _a;
    let response = "The tag `" + this.id.tag + "` is invalid.\nThe following ids are either missing or invalid:\n";
    (_a = this.id.invalidIds) == null ? void 0 : _a.forEach((status, type) => {
      response += " - `{" + ComponentType[type].toLowerCase() + "Id}` is " + (status === 2 /* Missing */ ? "missing" : "not a valid numeric id") + "\n";
    });
    return response;
  }
};

// src/errors/ComponentDuplicatedError.ts
var ComponentDuplicatedError = class extends AbstractRpgManagerError {
  constructor(app2, idMap, _duplication, _duplicated = void 0) {
    super(app2, idMap);
    this._duplication = _duplication;
    this._duplicated = _duplicated;
  }
  getErrorTitle() {
    return "Duplicated outline id";
  }
  showErrorMessage() {
    var _a;
    let response = "";
    if (this._duplication.length > 1) {
      this._duplication.forEach((component) => {
        response += " - " + component.file.basename + "\n";
      });
    } else if (this._duplicated !== void 0) {
      response += " - " + this._duplication[0].file.basename + "\n - " + ((_a = this._duplicated) == null ? void 0 : _a.file.basename) + "\n";
    }
    return response;
  }
  showErrorActions() {
    const response = "Two or more outlines have the same tag. The identifier of the outline must be unique\nPlease change one of the following:\n";
    return response;
  }
  getErrorLinks() {
    var _a;
    const response = [];
    if (this._duplication.length > 1) {
      this._duplication.forEach((component) => {
        response.push(component.file.path);
      });
    } else if (this._duplicated !== void 0) {
      response.push(this._duplication[0].file.path);
      response.push((_a = this._duplicated) == null ? void 0 : _a.file.path);
    }
    return response;
  }
};

// src/loggers/enums/LogMessageType.ts
var LogMessageType = /* @__PURE__ */ ((LogMessageType2) => {
  LogMessageType2[LogMessageType2["System"] = 1] = "System";
  LogMessageType2[LogMessageType2["Database"] = 2] = "Database";
  LogMessageType2[LogMessageType2["DatabaseInitialisation"] = 4] = "DatabaseInitialisation";
  LogMessageType2[LogMessageType2["ComponentInitialisation"] = 8] = "ComponentInitialisation";
  LogMessageType2[LogMessageType2["Updater"] = 16] = "Updater";
  LogMessageType2[LogMessageType2["TagUpdates"] = 32] = "TagUpdates";
  LogMessageType2[LogMessageType2["SessionSceneLink"] = 64] = "SessionSceneLink";
  LogMessageType2[LogMessageType2["Model"] = 128] = "Model";
  LogMessageType2[LogMessageType2["TagManagement"] = 256] = "TagManagement";
  LogMessageType2[LogMessageType2["Performance"] = 512] = "Performance";
  return LogMessageType2;
})(LogMessageType || {});

// src/errors/InvalidIdChecksumError.ts
var InvalidIdChecksumError = class extends AbstractRpgManagerError {
  showErrorActions() {
    return "Please regenerate the component identifier through the available tool";
  }
  showErrorMessage() {
    var _a;
    return "The ID used in the " + (((_a = this.id) == null ? void 0 : _a.type) !== void 0 ? ComponentType[this.id.type] : "file") + " has been changed manually and is invalid";
  }
};

// src/databases/DatabaseInitialiser.ts
var DatabaseInitialiser = class {
  static initialise(app2) {
    return __async(this, null, function* () {
      this._app = app2;
      this._misconfiguredTags = yield /* @__PURE__ */ new Map();
      this._factories = this._app.plugins.getPlugin("rpg-manager").factories;
      this._tagHelper = this._app.plugins.getPlugin("rpg-manager").tagHelper;
      const group = this._factories.logger.createGroup();
      const response = yield this._factories.database.create();
      group.add(this._factories.logger.createInfo(4 /* DatabaseInitialisation */, "Database Initialised"));
      const components = [];
      const markdownFiles = app2.vault.getMarkdownFiles();
      let componentCounter = 0;
      for (let index = 0; index < markdownFiles.length; index++) {
        try {
          yield this.createComponent(markdownFiles[index]).then((component) => {
            if (component === void 0)
              return void 0;
            if (component.stage == 0 /* Plot */ || component.stage === 2 /* Run */) {
              let error = void 0;
              try {
                const duplicate = response.readSingle(component.id.type, component.id);
                error = new ComponentDuplicatedError(this._app, component.id, [duplicate], component);
              } catch (e) {
              }
              if (error !== void 0)
                throw error;
            }
            response.create(component);
            components.push(component);
            componentCounter++;
          });
        } catch (e) {
          this._misconfiguredTags.set(markdownFiles[index], e);
        }
      }
      group.add(this._factories.logger.createInfo(4 /* DatabaseInitialisation */, componentCounter + " Components created"));
      yield Promise.all(components);
      const metadata = [];
      yield components.forEach((component) => {
        try {
          metadata.push(component.readMetadata());
        } catch (e) {
          this._misconfiguredTags.set(component.file, e);
        }
      });
      Promise.all(metadata).then(() => {
        group.add(this._factories.logger.createInfo(4 /* DatabaseInitialisation */, "Data read for " + metadata.length + " Components"));
        this._initialiseRelationships(response).then(() => {
          group.add(this._factories.logger.createInfo(4 /* DatabaseInitialisation */, "Relationships created"));
          this._validateComponents(response).then(() => {
            group.add(this._factories.logger.createInfo(4 /* DatabaseInitialisation */, "Components Validated"));
            response.ready();
            if (this._misconfiguredTags.size > 0) {
              new DatabaseErrorModal(this._app, this._misconfiguredTags).open();
            }
            this._factories.logger.group(group);
          });
        });
      });
      return response;
    });
  }
  static _validateComponents(database) {
    return __async(this, null, function* () {
      database.recordset.forEach((component) => {
        try {
          component.validateHierarchy();
        } catch (e) {
          database.delete(component);
          this._misconfiguredTags.set(component.file, e);
        }
      });
    });
  }
  static readID(file) {
    return __async(this, null, function* () {
      const metadata = this._app.metadataCache.getFileCache(file);
      if (metadata == void 0)
        return void 0;
      if (metadata.sections == void 0 || metadata.sections.length === 0)
        return void 0;
      const content = yield this._app.vault.read(file);
      const contentArray = content.split("\n");
      for (let sectionIndex = 0; sectionIndex < metadata.sections.length; sectionIndex++) {
        const section = metadata.sections[sectionIndex];
        if (section.type === "code" && contentArray[section.position.start.line] === "```RpgManagerID") {
          const rpgManagerIdContent = contentArray.slice(section.position.start.line + 1, section.position.end.line);
          const rpgManagerID = (0, import_obsidian16.parseYaml)(rpgManagerIdContent.join("\n"));
          const response = this._factories.id.createFromID(rpgManagerID.id);
          if (Md5.hashStr(rpgManagerID.id) !== rpgManagerID.checksum)
            throw new InvalidIdChecksumError(this._app, response);
          return response;
        }
      }
      return void 0;
    });
  }
  static createComponent(file) {
    return __async(this, null, function* () {
      const id = yield this.readID(file);
      if (id === void 0)
        return void 0;
      if (!id.isValid)
        throw new TagMisconfiguredError(this._app, id);
      return yield this._factories.component.create(id.campaignSettings, file, id);
    });
  }
  static _initialiseRelationships(database) {
    return __async(this, null, function* () {
      const relationshipsInitialisation = [];
      database.recordset.forEach((component) => {
        relationshipsInitialisation.push(component.initialiseRelationships());
      });
      return Promise.all(relationshipsInitialisation).then(() => {
        for (let index = 0; index < database.recordset.length; index++) {
          const relationships = database.recordset[index].getRelationships(database).relationships;
          for (let relationshipIndex = 0; relationshipIndex < relationships.length; relationshipIndex++) {
            if (relationships[relationshipIndex].component !== void 0) {
              this._factories.relationship.createFromReverse(database.recordset[index], relationships[relationshipIndex]);
            }
          }
        }
        for (let index = 0; index < database.recordset.length; index++) {
          database.recordset[index].touch();
        }
        return;
      });
    });
  }
  static reinitialiseRelationships(component, database) {
    return __async(this, null, function* () {
      return component.initialiseRelationships().then(() => {
        const relationships = component.getRelationships();
        if (component.touch()) {
          relationships.forEach((relationship) => {
            if (relationship.component === void 0)
              this._factories.relationship.createFromReverse(component, relationship);
          });
          database.recordset.forEach((component2) => {
            component2.getRelationships(database);
            component2.touch();
          });
        }
        return;
      });
    });
  }
};
DatabaseInitialiser._misconfiguredTags = /* @__PURE__ */ new Map();

// src/modals/IdSwitcherModal.ts
var IdSwitcherModal = class extends AbstractModal {
  constructor(app2, _file) {
    super(app2);
    this._file = _file;
    this.title = "Component ID Updater";
  }
  onClose() {
    super.onClose();
    this.rpgmContainerEl.empty();
  }
  onOpen() {
    super.onOpen();
    DatabaseInitialiser.readID(this._file).then((id) => {
      this._processId(id);
    }).catch((e) => {
      if (e.id !== void 0)
        this._processId(e.id);
    });
  }
  _processId(id) {
    return __async(this, null, function* () {
      this._id = id;
      const descriptorEl = this.rpgmContainerEl.createDiv();
      descriptorEl.textContent = "Use this form to change the position of the " + ComponentType[this._id.type] + ' "' + this._file.basename + '" in the Campaign hierarchy';
      const formEl = this.rpgmContainerEl.createDiv();
      const buttonContainerEl = this.rpgmContainerEl.createDiv();
      this._updateButtonEl = buttonContainerEl.createEl("button", { text: "Update the identifier" });
      this._updateButtonEl.disabled = true;
      this._updateButtonEl.addEventListener("click", this._save.bind(this));
      if (this._id.type === 1 /* Campaign */) {
        const newCampaignId = this._proposeNewId(1 /* Campaign */);
        this._newId = this.factories.id.create(1 /* Campaign */, newCampaignId, void 0, void 0, void 0, void 0, void 0, this._id.campaignSettings);
        this._addIdSelector(formEl, newCampaignId.toString());
        this._updateButtonEl.disabled = false;
      } else {
        this._addSelector(formEl, 1 /* Campaign */);
      }
    });
  }
  _addIdSelector(containerId, newId) {
    containerId.createDiv({ cls: "input-title", text: "New ID" });
    containerId.createEl("div", { text: "The proposed new ID is " + newId + " but you can change it if you want" });
    this._newIdEl = containerId.createEl("input", { type: "text" });
    this._errorIdEl = containerId.createSpan({ text: "The selected ID is already in use. Please select a different one" });
    this._errorIdEl.style.display = "none";
    this._newIdEl.value = newId;
    this._newIdEl.addEventListener("keyup", this._validateNewId.bind(this));
  }
  _validateNewId() {
    switch (this._newId.type) {
      case 1 /* Campaign */:
        this._newId = this.factories.id.create(1 /* Campaign */, +this._newIdEl.value, void 0, void 0, void 0, void 0, void 0, this._id.campaignSettings);
        break;
      case 2 /* Adventure */:
        this._newId = this.factories.id.create(2 /* Adventure */, this._newId.campaignId, +this._newIdEl.value, void 0, void 0, void 0, void 0, this._id.campaignSettings);
        break;
      case 4 /* Act */:
        this._newId = this.factories.id.create(4 /* Act */, this._newId.campaignId, this._newId.adventureId, +this._newIdEl.value, void 0, void 0, void 0, this._id.campaignSettings);
        break;
      case 8 /* Scene */:
        this._newId = this.factories.id.create(8 /* Scene */, this._newId.campaignId, this._newId.adventureId, this._newId.actId, +this._newIdEl.value, void 0, void 0, this._id.campaignSettings);
        break;
      case 16 /* Session */:
        this._newId = this.factories.id.create(16 /* Session */, +this._newIdEl.value, void 0, void 0, void 0, +this._newIdEl.value, void 0, this._id.campaignSettings);
        break;
      default:
        return;
    }
    try {
      this.database.readSingle(this._newId.type, this._newId);
      this._updateButtonEl.disabled = true;
      this._errorIdEl.style.display = "";
    } catch (e) {
      this._updateButtonEl.disabled = false;
      this._errorIdEl.style.display = "none";
    }
  }
  _save() {
    return __async(this, null, function* () {
      this.manipulators.codeblock.replaceID(this._file, this._newId.stringID);
      this.close();
    });
  }
  _addSelector(containerEl, type, campaignId = void 0, adventureId = void 0, actId = void 0, sessionId = void 0) {
    const selectorContainerEl = containerEl.createDiv();
    selectorContainerEl.createDiv({
      cls: "input-title",
      text: "Select the " + ComponentType[type] + " the " + ComponentType[this._id.type] + " belongs to"
    });
    const typeSelectorEl = selectorContainerEl.createDiv().createEl("select");
    typeSelectorEl.createEl("option", { value: "", text: "" }).selected;
    this._fillSelector(typeSelectorEl, type, campaignId, adventureId, actId, sessionId);
  }
  _fillSelector(selectorEl, type, campaignId = void 0, adventureId = void 0, actId = void 0, sessionId = void 0) {
    var _a;
    const components = this._loadPossibleChildren(type, campaignId, adventureId, actId);
    const subContainerEl = (_a = selectorEl.parentElement) == null ? void 0 : _a.createDiv();
    components.forEach((component) => {
      selectorEl.createEl("option", { text: component.file.basename, value: component.id.id.toString() });
    });
    if (subContainerEl !== void 0) {
      selectorEl.addEventListener("change", () => {
        subContainerEl.empty();
        let hasLoadedSomethingElse = false;
        let hasMissingValidId = false;
        let idValues = void 0;
        switch (type) {
          case 1 /* Campaign */:
            if (this._id.type === 2 /* Adventure */) {
              try {
                idValues = { type: 2 /* Adventure */, campaignId: +selectorEl.value, adventureId: this._id.adventureId };
                if (!this._isExistingIdValid(2 /* Adventure */, +selectorEl.value))
                  hasMissingValidId = true;
              } catch (e) {
                idValues = { type: 2 /* Adventure */, campaignId: +selectorEl.value };
                hasMissingValidId = true;
              }
            } else if (this._id.type === 16 /* Session */) {
              try {
                idValues = { type: 2 /* Adventure */, campaignId: +selectorEl.value, sessionId: this._id.sessionId };
                if (!this._isExistingIdValid(16 /* Session */, +selectorEl.value))
                  hasMissingValidId = true;
              } catch (e) {
                idValues = { type: 2 /* Adventure */, campaignId: +selectorEl.value };
                hasMissingValidId = true;
              }
            } else if (this._id.type === 4 /* Act */ || this._id.type === 8 /* Scene */) {
              hasLoadedSomethingElse = true;
              this._addSelector(subContainerEl, 2 /* Adventure */, +selectorEl.value);
            } else {
              idValues = { type: this._id.type, campaignId: +selectorEl.value };
            }
            break;
          case 2 /* Adventure */:
            if (this._id.type === 4 /* Act */) {
              try {
                idValues = { type: 4 /* Act */, campaignId: campaignId != null ? campaignId : 0, adventureId: +selectorEl.value, actId: this._id.actId };
                if (!this._isExistingIdValid(4 /* Act */, campaignId, +selectorEl.value))
                  hasMissingValidId = true;
              } catch (e) {
                idValues = { type: 4 /* Act */, campaignId: campaignId != null ? campaignId : 0, adventureId: +selectorEl.value };
                hasMissingValidId = true;
              }
            } else if (this._id.type === 8 /* Scene */) {
              hasLoadedSomethingElse = true;
              this._addSelector(subContainerEl, 4 /* Act */, campaignId, +selectorEl.value);
            }
            break;
          case 4 /* Act */:
            if (this._id.type === 8 /* Scene */) {
              try {
                idValues = { type: 8 /* Scene */, campaignId: campaignId != null ? campaignId : 0, adventureId, actId: +selectorEl.value, sceneId: this._id.sceneId };
                if (!this._isExistingIdValid(8 /* Scene */, campaignId, adventureId, +selectorEl.value))
                  hasMissingValidId = true;
              } catch (e) {
                idValues = { type: 8 /* Scene */, campaignId: campaignId != null ? campaignId : 0, adventureId, actId: +selectorEl.value };
                hasMissingValidId = true;
              }
            } else {
              hasLoadedSomethingElse = true;
              this._addSelector(subContainerEl, 8 /* Scene */, campaignId, adventureId, +selectorEl.value);
            }
            break;
        }
        if (!hasLoadedSomethingElse) {
          if (idValues !== void 0) {
            if (hasMissingValidId) {
              const newId = this._proposeNewId(idValues.type, idValues.campaignId, idValues.adventureId, idValues.actId);
              switch (idValues.type) {
                case 1 /* Campaign */:
                  idValues.campaignId = newId;
                  break;
                case 2 /* Adventure */:
                  idValues.adventureId = newId;
                  break;
                case 4 /* Act */:
                  idValues.actId = newId;
                  break;
                case 8 /* Scene */:
                  idValues.sceneId = newId;
                  break;
                case 16 /* Session */:
                  idValues.sessionId = newId;
                  break;
              }
              this._addIdSelector(subContainerEl, newId.toString());
            } else {
              let newId = void 0;
              switch (idValues.type) {
                case 1 /* Campaign */:
                  newId = idValues.campaignId;
                  break;
                case 2 /* Adventure */:
                  newId = idValues.adventureId;
                  break;
                case 4 /* Act */:
                  newId = idValues.actId;
                  break;
                case 8 /* Scene */:
                  newId = idValues.sceneId;
                  break;
                case 16 /* Session */:
                  newId = idValues.sessionId;
                  break;
              }
              if (newId !== void 0)
                this._addIdSelector(subContainerEl, newId.toString());
            }
            this._newId = this.factories.id.create(idValues.type, idValues.campaignId, idValues.adventureId, idValues.actId, idValues.sceneId, idValues.sessionId, void 0, this._id.campaignSettings);
            this._updateButtonEl.disabled = false;
          }
        }
      });
    }
  }
  _proposeNewId(type, campaignId = void 0, adventureId = void 0, actId = void 0) {
    let response = 1;
    let components;
    if (type === 8 /* Scene */) {
      components = this.database.read((component) => component.id.type === type && component.id.campaignId === campaignId && component.id.adventureId === adventureId && component.id.actId === actId);
    } else {
      components = this.database.read((component) => component.id.type === type && (campaignId !== void 0 ? component.id.campaignId === campaignId : true));
    }
    components.forEach((component) => {
      if (component.id.id >= response)
        response = component.id.id + 1;
    });
    return response;
  }
  _isExistingIdValid(type, campaignId = void 0, adventureId = void 0, actId = void 0) {
    const components = this._loadPossibleChildren(type, campaignId, adventureId, actId);
    const match2 = components.filter((component) => this._id.id === component.id.id);
    return match2.length === 0;
  }
  _loadPossibleChildren(type, campaignId = void 0, adventureId = void 0, actId = void 0) {
    return this.database.read((component) => component.id.type === type && (campaignId !== void 0 ? component.id.campaignId === campaignId : true) && (adventureId !== void 0 ? component.id.adventureId === adventureId : true) && (actId !== void 0 ? component.id.actId === actId : true));
  }
};

// src/galleries/modals/GalleryManagementModal.ts
var GalleryManagementModal = class extends AbstractModal {
  constructor(app2, _component) {
    super(app2);
    this._component = _component;
    this.title = "Gallery Manager";
  }
  onClose() {
    super.onClose();
    this.rpgmContainerEl.empty();
  }
  onOpen() {
    super.onOpen();
    this.modalEl.style.width = "var(--modal-max-width)";
    this._containerEl = this.rpgmContainerEl.createDiv({ cls: "gallery" });
    const view = this.factories.imageView.create(1 /* ModalNavigation */, this._component);
    view.render(this._containerEl);
  }
};

// src/views/subViews/BreadcrumbView.ts
var BreadcrumbView = class extends AbstractSubModelView {
  render(container, data) {
    if (data.component === void 0)
      return;
    this._currentComponent = data.component;
    const breadcrumbContainer = container.createDiv({ cls: "rpgm-breadcrumb" });
    breadcrumbContainer.createEl("h2").textContent = data.mainTitle;
    const breadcrumbLine = breadcrumbContainer.createDiv({ cls: "line" });
    this._renderBreadcrumb(breadcrumbContainer, breadcrumbLine, data);
    breadcrumbContainer.createDiv({ cls: "reset" });
    const relationshipAdderContainerEl = breadcrumbContainer.createDiv({ cls: "line spaced-line" });
    this._addFunctionality(relationshipAdderContainerEl, "Relationships", "Manage Relationship").addEventListener("click", () => {
      new RelationshipsSelectionModal(this.app, this._currentComponent).open();
    });
    this._addSeparator(relationshipAdderContainerEl);
    this._addFunctionality(relationshipAdderContainerEl, "Move", "Move your " + ComponentType[this._currentComponent.id.type]).addEventListener("click", () => {
      new IdSwitcherModal(this.app, this._currentComponent.file).open();
    });
    this._addSeparator(relationshipAdderContainerEl);
    this._addFunctionality(relationshipAdderContainerEl, "Images", "Gallery Manager").addEventListener("click", () => {
      new GalleryManagementModal(this.app, this._currentComponent).open();
    });
  }
  _addFunctionality(containerEl, title, description) {
    const crumb = containerEl.createDiv({ cls: "crumb" });
    crumb.createDiv({ cls: "title", text: title });
    const value = crumb.createDiv({ cls: "value" });
    return value.createSpan({ cls: "rpgm-edit-icon", text: description });
  }
  _addSeparator(containerEl) {
    const separator = containerEl.createDiv({ cls: "separator" });
    separator.createDiv({ cls: "title", text: " " });
    const separatorText = separator.createDiv({ cls: "value" });
    separatorText.createEl("p").textContent = "|";
  }
  _renderBreadcrumb(breadcrumb, line, data, isFirstLine = true) {
    let lineToUse = line;
    if (data.isInNewLine) {
      breadcrumb.createDiv({ cls: "reset" });
      lineToUse = breadcrumb.createDiv({ cls: "line" });
      isFirstLine = false;
    }
    const crumb = lineToUse.createDiv({ cls: "crumb" });
    crumb.createDiv({ cls: "title", text: data.title ? data.title : " " });
    const value = crumb.createDiv({ cls: "value" });
    if (data.function != null) {
      const functionLink = value.createEl("a");
      functionLink.textContent = data.linkText;
      functionLink.addEventListener("click", () => {
        if (data.functionParameters != null) {
          data.function(...data.functionParameters);
        } else {
          data.function();
        }
      });
    } else {
      let link = data.link;
      if (data.linkText != null) {
        if (link.indexOf("|") !== -1) {
          link = link.substring(0, link.indexOf("|") + 1) + data.linkText + "]]";
        } else {
          link = link.substring(0, link.indexOf("]]")) + "|" + data.linkText + "]]";
        }
      }
      import_obsidian17.MarkdownRenderer.renderMarkdown(link, value, this.sourcePath, null);
    }
    if (data.nextBreadcrumb != null) {
      if (data.nextBreadcrumb.isInNewLine === false) {
        const separator = lineToUse.createDiv({ cls: "separator" });
        separator.createDiv({ cls: "title", text: " " });
        const separatorText = separator.createDiv({ cls: "value" });
        separatorText.createEl("p").textContent = isFirstLine ? ">" : "|";
      }
      this._renderBreadcrumb(breadcrumb, lineToUse, data.nextBreadcrumb, isFirstLine);
    } else {
      breadcrumb.createDiv({ cls: "reset" });
    }
  }
};

// src/views/abstracts/AbstractPlotHeaderView.ts
var import_obsidian19 = require("obsidian");

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s2 = nth % 100;
    if (s2 > 3 && s2 < 21)
      return "th";
    switch (s2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0)
    e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path2 = event.composedPath();
      return path2[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function(date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function(date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
    s2 += arguments[i].length;
  for (var r = Array(s2), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self.onMouseOver = onMouseOver;
  self._createElement = createElement;
  self.createDay = createDay;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.updateValue = updateValue;
  self.open = open;
  self.redraw = redraw;
  self.set = set;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self.currentMonth;
        }
        if (yr === void 0) {
          yr = self.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self.element = self.input = element;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile)
      build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self);
  }
  function setCalendarWidth() {
    var config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self.calendarContainer !== void 0) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== void 0) {
          var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== void 0 ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      var defaultDate = self.config.minDate === void 0 || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      var defaults2 = getDefaultHours(self.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === void 0 || self.minuteElement === void 0)
      return;
    var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== void 0 ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== void 0) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    var limitMinHours = self.config.minTime !== void 0 || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    var limitMaxHours = self.config.maxTime !== void 0 || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (self.config.maxTime !== void 0 && self.config.minTime !== void 0 && self.config.minTime > self.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== void 0 ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self.config.minTime !== void 0 ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== void 0) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile)
      return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== void 0)
      self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
    if (self.secondElement !== void 0)
      self.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self[evt]);
        });
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self.daysContainer, "mouseover", function(e) {
        if (self.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind(self._input, "keydown", onKeyDown);
    if (self.calendarContainer !== void 0) {
      bind(self.calendarContainer, "keydown", onKeyDown);
    }
    if (!self.config.inline && !self.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self.config.clickOpens === true) {
      bind(self._input, "focus", self.open);
      bind(self._input, "click", self.open);
    }
    if (self.daysContainer !== void 0) {
      bind(self.monthNav, "click", onMonthNavClick);
      bind(self.monthNav, ["keyup", "increment"], onYearInput);
      bind(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0) {
      var selText = function(e) {
        return getEventTarget(e).select();
      };
      bind(self.timeContainer, ["increment"], updateTime);
      bind(self.timeContainer, "blur", updateTime, { capture: true });
      bind(self.timeContainer, "click", timeIncrement);
      bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== void 0)
        bind(self.secondElement, "focus", function() {
          return self.secondElement && self.secondElement.select();
        });
      if (self.amPM !== void 0) {
        bind(self.amPM, "click", function(e) {
          updateTime(e);
        });
      }
    }
    if (self.config.allowInput) {
      bind(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    var oldYear = self.currentYear;
    var oldMonth = self.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange2 && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    var customAppend = self.config.appendTo !== void 0 && self.config.appendTo.nodeType !== void 0;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode)
          self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
        else if (self.config.appendTo !== void 0)
          self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode)
          self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput)
          wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline)
      (self.config.appendTo !== void 0 ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      var month = self.daysContainer.children[m];
      var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self.selectedDateElem !== void 0 && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== void 0 && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth2 = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === void 0) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers)
      clearNode(self.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self.config.showMonths; i++) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self.config.minDate !== void 0 && self.currentYear === self.config.minDate.getFullYear() && month2 < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== void 0 && self.currentYear === self.config.maxDate.getFullYear() && month2 > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind(self.monthsDropdownContainer, "change", function(e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (var m = self.config.showMonths; m--; ) {
      var month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: function() {
        return self.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: function() {
        return self.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar)
      self.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr)
      self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer)
      self.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self.weekdayContainer);
    for (var i = self.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self.l10n.firstDayOfWeek;
    var weekdays2 = __spreadArrays(self.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays2.length) {
      weekdays2 = __spreadArrays(weekdays2.splice(firstDayOfWeek, weekdays2.length), weekdays2.splice(0, firstDayOfWeek));
    }
    for (var i = self.config.showMonths; i--; ) {
      self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays2.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true)
      return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self.input.value = "";
    if (self.altInput !== void 0)
      self.altInput.value = "";
    if (self.mobileInput !== void 0)
      self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      var _a = getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== void 0) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== void 0) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self._handlers.length; i--; ) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode)
        self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = void 0;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        var wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode)
        self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self.config.allowInput) {
          self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        }
        if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0 && self.input.value !== "" && self.input.value !== void 0) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1)
          self.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self.parseDate(date, void 0, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== void 0 ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== void 0 ? timeless : !self.maxDateHasTime) > 0)
      return false;
    if (!self.config.enable && self.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self._input;
    var valueChanged = self._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
    var allowInput = self.config.allowInput;
    var allowKeydown = self.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        self.close();
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement)
            self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== void 0 || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement)
              self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self.hourElement,
              self.minuteElement,
              self.secondElement,
              self.amPM
            ].concat(self.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange))
          minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange))
          maxRange = t;
      }
    }
    var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline)
      positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self._positionElement;
    }
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== void 0) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    var wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === void 0 || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function() {
          return self.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
      var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: function() {
        return self.config._enable;
      },
      set: function(dates) {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: function() {
        return self.config._disable;
      },
      set: function(dates) {
        self.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self.config, "minDate", {
      get: function() {
        return self.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: function() {
        return self.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self.config, "minTime", {
      get: function() {
        return self.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: function() {
        return self.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self.config[hook] !== void 0;
    }).forEach(function(hook) {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self.config.plugins.length; i++) {
      var pluginConf = self.config.plugins[i](self) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined")
      self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
    self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : void 0);
    tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static)
      return;
    self.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self.calendarContainer.style.left = left + "px";
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self.calendarContainer.style.left = centerLeft + "px";
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0)
      return;
    var target = t;
    var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single")
      self.selectedDates = [selectedDate];
    else if (self.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
        self.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self.selectedDateElem !== void 0 && self.hourElement === void 0) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== void 0)
      self.hourElement !== void 0 && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      var single = self.config.mode === "single" && !self.config.enableTime;
      var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self.config.clickOpens === true) {
          bind(self._input, "focus", self.open);
          bind(self._input, "click", self.open);
        } else {
          self._input.removeEventListener("focus", self.open);
          self._input.removeEventListener("click", self.open);
        }
      }
    ]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map(function(date) {
            return self.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map(function(date) {
            return self.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else
      self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self.config.mode === "range")
      self.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self.clear(triggerChange2);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self.parseDate(rule.from, void 0),
          to: self.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0)
      self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== void 0)
      self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== void 0)
      self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode)
        self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput)
      self._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate)
      self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate)
      self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step"))
      self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== void 0)
      self.altInput.type = "hidden";
    try {
      if (self.input.parentNode)
        self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {
    }
    bind(self.mobileInput, "change", function(e) {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true)
      return self.close();
    self.open(e);
  }
  function triggerEvent(event, data) {
    if (self.config === void 0)
      return;
    var hooks = self.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self.selectedDates.length; i++) {
      var selectedDate = self.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2)
      return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav)
      return;
    self.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== void 0 && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== void 0 && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
    return self.selectedDates.map(function(dObj) {
      return self.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
    }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self.mobileInput !== void 0 && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== void 0 ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== void 0) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self.prevMonthNav.contains(eventTarget);
    var isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self.hourElement);
      } else if (newValue > max) {
        newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// src/galleries/views/GalleryCarouselView.ts
var import_obsidian18 = require("obsidian");
var GalleryCarouselView = class extends AbstractRpgManager {
  constructor(app2, _images) {
    super(app2);
    this._images = _images;
    this._currentImage = 0;
    this._imagesCount = this._images.length;
    this._imageGroups = [];
  }
  render(containerEl) {
    const carouselContainerEl = containerEl.createDiv({ cls: "rpgm-image-carousel" });
    this._addImageNavigator(carouselContainerEl);
    const imagesContainerEl = carouselContainerEl.createDiv({ cls: "images" });
    this._images.forEach((image, index) => {
      this._addImageGroup(image, imagesContainerEl);
    });
    this._imageGroups[0].removeClass("invisible");
    this._imageCounterEl.textContent = "1/" + this._imagesCount.toString();
  }
  _addImageGroup(image, containerEl) {
    const imageGroupEl = containerEl.createDiv({ cls: "group invisible" });
    const imageContainerEl = imageGroupEl.createDiv({ cls: "container" });
    const imageEl = new Image();
    imageEl.onload = (evt) => {
      if (image.src.startsWith("http")) {
        const crsImageLink = imageContainerEl.createEl("a", { href: image.src });
        crsImageLink.append(imageEl);
      } else {
        imageContainerEl.append(imageEl);
      }
    };
    imageEl.src = image.src;
    const imageCaptionEl = imageGroupEl.createDiv({ cls: "container" });
    if (image.caption !== "") {
      import_obsidian18.MarkdownRenderer.renderMarkdown(image.caption, imageCaptionEl, "", null);
    }
    this._imageGroups.push(imageGroupEl);
  }
  _addImageNavigator(containerEl) {
    const imageNavigatorContainerEl = containerEl.createDiv({ cls: "navigator" });
    if (this._images.length > 0) {
      const previousImageNavigatorEl = imageNavigatorContainerEl.createDiv({ cls: "previous", text: "<<" });
      previousImageNavigatorEl.addEventListener("click", this._movePrevious.bind(this));
      const nextImageNavigatorEl = imageNavigatorContainerEl.createDiv({ cls: "next", text: ">>" });
      nextImageNavigatorEl.addEventListener("click", this._moveNext.bind(this));
      this._imageCounterEl = imageNavigatorContainerEl.createDiv({ cls: "counter" });
    }
    imageNavigatorContainerEl.createDiv({ cls: "reset" });
  }
  _movePrevious() {
    this._imageGroups[this._currentImage].addClass("invisible");
    if (this._currentImage === 0) {
      this._currentImage = this._imagesCount - 1;
    } else {
      this._currentImage--;
    }
    this._imageGroups[this._currentImage].removeClass("invisible");
    this._imageCounterEl.textContent = (this._currentImage + 1).toString() + "/" + this._imagesCount.toString();
  }
  _moveNext() {
    this._imageGroups[this._currentImage].addClass("invisible");
    if (this._currentImage === this._imagesCount - 1) {
      this._currentImage = 0;
    } else {
      this._currentImage++;
    }
    this._imageGroups[this._currentImage].removeClass("invisible");
    this._imageCounterEl.textContent = (this._currentImage + 1).toString() + "/" + this._imagesCount.toString();
  }
};

// src/views/abstracts/AbstractHeaderView.ts
var AbstractHeaderView = class extends AbstractSubModelView {
  constructor() {
    super(...arguments);
    this._isInternalRender = false;
  }
  internalRender(container, data) {
    this._isInternalRender = true;
    this._executeRender(container, data);
  }
  render(container, data) {
    this._executeRender(container, data);
  }
  _executeRender(container, data) {
    this.currentComponent = data.currentComponent;
    const crs = container.createDiv({ cls: "rpgm-header-info" });
    this.headerTitleEl = crs.createDiv({ cls: "title" });
    data.link.fillContent(this.headerTitleEl, this.sourcePath);
    if (!this.currentComponent.isComplete) {
      const completerEl = this.headerTitleEl.createDiv();
      const completeButtonEl = completerEl.createEl("button", { cls: "actionButton", text: "Mark this component as completed" });
      completeButtonEl.addEventListener("click", () => {
        this.manipulators.codeblock.update("data.complete", true);
      });
    }
    this.headerContainerEl = crs.createDiv({ cls: "container" });
    this.headerInfoEl = this.headerContainerEl.createDiv({ cls: "info" });
    this.infoTableEl = this.headerInfoEl.createEl("table", { cls: "rpgm-headless-table" }).createTBody();
    if (data.images.length > 0) {
      new GalleryCarouselView(this.app, data.images).render(this.headerContainerEl);
    } else {
      this.headerInfoEl.addClass("info-large");
    }
    if (!this._isInternalRender) {
      data.elements.forEach((element) => {
        const containerEl = this.createContainerEl(element);
        element.value.fillContent(containerEl, this.sourcePath);
      });
    }
    this.headerContainerEl.createDiv({ cls: "reset" });
  }
  createContainerEl(element, fn = void 0, additionalParams = void 0) {
    var _a;
    let tableRowEl = this.infoTableEl.insertRow();
    const titleCellEl = tableRowEl.insertCell();
    titleCellEl.addClass("title");
    titleCellEl.textContent = element.title;
    if (element.type === 1 /* Long */) {
      titleCellEl.colSpan = 2;
      tableRowEl = this.infoTableEl.insertRow();
    }
    const response = tableRowEl.insertCell();
    response.addClass("content");
    if (fn !== void 0) {
      let subContent;
      if (additionalParams === void 0) {
        subContent = fn(response, element);
      } else {
        subContent = fn(response, ...additionalParams);
      }
      if (subContent !== void 0) {
        const subRowEl = this.infoTableEl.insertRow();
        subRowEl.insertCell().textContent = "";
        const subRowContentEl = subRowEl.insertCell();
        subRowContentEl.addClass("subcontent");
        if (typeof subContent === "function") {
          if (additionalParams === void 0) {
            subContent(subRowContentEl, element);
          } else {
            subContent(subRowContentEl, ...additionalParams);
          }
        } else {
          subContent.fillContent(subRowContentEl, this.sourcePath);
        }
      }
    } else {
      if (((_a = element.additionalInformation) == null ? void 0 : _a.editableField) !== void 0)
        this.addEditorIcon(response, element.currentComponent, element.additionalInformation.editableField);
      if (element.type === 1 /* Long */) {
        response.colSpan = 2;
      } else {
        response.addClass("contentShort");
      }
    }
    return response;
  }
  addDateSelector(contentEl, data) {
    if (data.additionalInformation === void 0)
      return;
    const options = {
      allowInput: true,
      dateFormat: "Y-m-d",
      altInput: true,
      onChange: (selectedDate, dateStr, instance) => {
        this.manipulators.codeblock.update(data.additionalInformation.yamlIdentifier, dateStr);
      }
    };
    if (data.additionalInformation.date !== void 0)
      options.defaultDate = data.additionalInformation.date;
    const flatpickrEl = contentEl.createEl("input", { cls: "flatpickr", type: "text" });
    flatpickrEl.placeholder = data.additionalInformation.placeholder;
    flatpickrEl.readOnly = true;
    esm_default(flatpickrEl, options);
  }
};

// src/views/abstracts/AbstractStoryCircleStageSelectorView.ts
var AbstractStoryCircleStageSelectorView = class extends AbstractHeaderView {
  addStoryCircleStageSelector(contentEl, data) {
    var _a;
    const sceneId = (_a = data.additionalInformation) == null ? void 0 : _a.sceneId;
    if (sceneId !== void 0) {
      const storyCircleSelectorEl = contentEl.createEl("select");
      storyCircleSelectorEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
      Object.keys(StoryCircleStage).filter((v) => isNaN(Number(v))).forEach((type, index) => {
        const storyCircleOptionEl = storyCircleSelectorEl.createEl("option", {
          text: type,
          value: type
        });
        if (data.value.content === StoryCircleStage[type])
          storyCircleOptionEl.selected = true;
      });
      storyCircleSelectorEl.addEventListener("change", (e) => {
        const file = data.additionalInformation.file;
        if (file !== void 0) {
          this.manipulators.codeblock.update("data.storyCircleStage", storyCircleSelectorEl.value.toLowerCase());
        }
      });
    }
  }
};

// src/views/abstracts/AbstractPlotHeaderView.ts
var AbstractPlotHeaderView = class extends AbstractStoryCircleStageSelectorView {
  _addPlotElement(name, value, tableEl, identifier) {
    const row = tableEl.createEl("tr");
    row.createEl("td", { cls: "header", text: name });
    const valueRowEl = row.createEl("td");
    import_obsidian19.MarkdownRenderer.renderMarkdown(value, valueRowEl, this.sourcePath, null);
    this.addEditorIcon(valueRowEl, this.currentComponent, identifier);
  }
  addAbtPlot(plot) {
    const plotEl = this.headerContainerEl.createDiv({ cls: "rpgm-plot-container" });
    const headerEl = plotEl.createEl("h3", { cls: "rpgm-table-header" });
    headerEl.createSpan({ text: "ABT Plot" });
    const tableEl = plotEl.createEl("table");
    tableEl.addClass("rpgm-table");
    this._addPlotElement("need", plot.need, tableEl, "plot.abt.need");
    this._addPlotElement("and", plot.and, tableEl, "plot.abt.and");
    this._addPlotElement("but", plot.but, tableEl, "plot.abt.but");
    this._addPlotElement("therefore", plot.therefore, tableEl, "plot.abt.therefore");
  }
  addStoryCirclePlot(plot) {
    const plotEl = this.headerContainerEl.createDiv({ cls: "rpgm-plot-container" });
    const headerEl = plotEl.createEl("h3", { cls: "rpgm-table-header" });
    headerEl.createSpan({ text: "Story Circle Plot" });
    const tableEl = plotEl.createEl("table");
    tableEl.addClass("rpgm-table");
    this._addPlotElement("you", plot.you, tableEl, "plot.storycircle.you");
    this._addPlotElement("need", plot.need, tableEl, "plot.storycircle.need");
    this._addPlotElement("go", plot.go, tableEl, "plot.storycircle.go");
    this._addPlotElement("search", plot.search, tableEl, "plot.storycircle.search");
    this._addPlotElement("find", plot.find, tableEl, "plot.storycircle.find");
    this._addPlotElement("take", plot.take, tableEl, "plot.storycircle.take");
    this._addPlotElement("return", plot.return, tableEl, "plot.storycircle.return");
    this._addPlotElement("change", plot.change, tableEl, "plot.storycircle.change");
  }
  addAbtStageSelector(contentEl, data) {
    var _a;
    if (((_a = data.additionalInformation) == null ? void 0 : _a.id) !== void 0) {
      const abtSelectorEl = contentEl.createEl("select");
      abtSelectorEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
      Object.keys(AbtStage).filter((v) => isNaN(Number(v))).forEach((type, index) => {
        const abtOptionEl = abtSelectorEl.createEl("option", {
          text: type,
          value: type
        });
        if (data.value.content.toString() === type)
          abtOptionEl.selected = true;
      });
      abtSelectorEl.addEventListener("change", (e) => {
        const file = data.additionalInformation.file;
        if (file !== void 0) {
          this.manipulators.codeblock.update("data.abtStage", abtSelectorEl.value.toLowerCase());
        }
      });
    }
  }
};

// src/views/HeadlessTableView.ts
var HeadlessTableView = class extends AbstractRpgManager {
  constructor(app2, _sourcePath) {
    super(app2);
    this._sourcePath = _sourcePath;
    this.tableEl = document.createElement("table");
    this.tableEl.addClass("rpgm-headless-table");
  }
  addRow(element, fn, additionalParams = void 0) {
    const rowEl = this.tableEl.createEl("tr");
    rowEl.createEl("td", { cls: "header", text: typeof element === "string" ? element : element.title });
    const cellContentEl = rowEl.createEl("td", { cls: "content" });
    let subContent;
    if (additionalParams === void 0) {
      subContent = fn(cellContentEl, element);
    } else {
      subContent = fn(cellContentEl, ...additionalParams);
    }
    if (subContent !== void 0) {
      const subRowEl = this.tableEl.createEl("tr");
      subRowEl.createEl("td", { text: "" });
      const subRowContentEl = subRowEl.createEl("td", { cls: "subcontent" });
      if (typeof subContent === "function") {
        if (additionalParams === void 0) {
          subContent(subRowContentEl, element);
        } else {
          subContent(subRowContentEl, ...additionalParams);
        }
      } else {
        subContent.fillContent(subRowContentEl, this._sourcePath);
      }
    }
  }
};

// src/components/components/act/views/ActHeaderView.ts
var ActHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 5 /* StoryCircleSelector */:
          headlessTable.addRow(element, this.addStoryCircleStageSelector.bind(this));
          break;
        case 6 /* AbtSelector */:
          headlessTable.addRow(element, this.addAbtStageSelector.bind(this));
          if (this.currentComponent.abtStage !== void 0) {
            this._analyser = element.additionalInformation.sceneAnalyser;
          }
          break;
        case 11 /* SceneAnalyser */:
          this._analyser = element.additionalInformation.sceneAnalyser;
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
    if (this._analyser !== void 0) {
      this._analyser.render(0 /* Extended */, this.headerContainerEl);
    }
    if (this.settings.usePlotStructures && data.currentComponent.hasAbtPlot && !data.currentComponent.abt.isEmpty) {
      this.addAbtPlot(data.currentComponent.abt);
    }
    if (this.settings.usePlotStructures && data.currentComponent.hasStoryCirclePlot && !data.currentComponent.storyCircle.isEmpty) {
      this.addStoryCirclePlot(data.currentComponent.storyCircle);
    }
  }
};

// src/components/components/adventure/views/AdventureHeaderView.ts
var AdventureHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    super.render(container, data);
    if (this.settings.usePlotStructures && data.currentComponent.hasAbtPlot && !data.currentComponent.abt.isEmpty) {
      this.addAbtPlot(data.currentComponent.abt);
    }
    if (this.settings.usePlotStructures && data.currentComponent.hasStoryCirclePlot && !data.currentComponent.storyCircle.isEmpty) {
      this.addStoryCirclePlot(data.currentComponent.storyCircle);
    }
  }
};

// src/components/components/campaign/views/CampaignHeaderView.ts
var import_obsidian20 = require("obsidian");
var CampaignHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    super.internalRender(container, data);
    if (this.currentComponent.images.length > 0) {
      this.headerTitleEl.empty();
      this.headerTitleEl.addClass("rpgm-header");
      this.headerInfoEl.addClass("info-large");
      if (this.imageContainterEl !== void 0)
        this.headerContainerEl.removeChild(this.imageContainterEl);
      this.headerTitleEl.style.backgroundImage = "url('" + this.currentComponent.images[0].src + "')";
      const overlay = this.headerTitleEl.createDiv({ cls: "rpgm-header-overlay" });
      overlay.createDiv({ cls: "rpgm-header-title", text: this.currentComponent.file.basename });
      overlay.createDiv({ cls: "rpgm-current-date", text: this.currentComponent.date !== null ? (_a = this.currentComponent.date) == null ? void 0 : _a.toDateString() : "" });
    }
    if (this.currentComponent.date !== void 0) {
      this.headerTitleEl.createEl("a", { cls: "subtitle", text: "View Campaign Timeline", href: "#" }).addEventListener("click", () => {
        this.factories.views.showObsidianView("rpgm-timeline-view" /* Timeline */, [data.metadata.campaignId]);
      });
    }
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 13 /* DateSelector */:
          this.createContainerEl(element, this.addDateSelector.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    if (((_c = (_b = data.metadata) == null ? void 0 : _b.sourceMeta) == null ? void 0 : _c.adventures) !== void 0) {
      headlessTable.addRow("Current Adventure", this._addCurrentComponentSelector.bind(this), ["adventure", this.currentComponent.currentAdventureId, (_e = (_d = data.metadata) == null ? void 0 : _d.sourceMeta) == null ? void 0 : _e.adventures]);
    }
    if (((_g = (_f = data.metadata) == null ? void 0 : _f.sourceMeta) == null ? void 0 : _g.acts) !== void 0) {
      headlessTable.addRow("Current Act", this._addCurrentComponentSelector.bind(this), ["act", this.currentComponent.currentActId, (_i = (_h = data.metadata) == null ? void 0 : _h.sourceMeta) == null ? void 0 : _i.acts]);
    }
    if (((_k = (_j = data.metadata) == null ? void 0 : _j.sourceMeta) == null ? void 0 : _k.sessions) !== void 0) {
      headlessTable.addRow("Current Session", this._addCurrentComponentSelector.bind(this), ["session", this.currentComponent.currentSessionId, (_m = (_l = data.metadata) == null ? void 0 : _l.sourceMeta) == null ? void 0 : _m.sessions]);
    }
    this.headerInfoEl.appendChild(headlessTable.tableEl);
    if (this.settings.usePlotStructures && data.currentComponent.hasAbtPlot && !data.currentComponent.abt.isEmpty) {
      this.addAbtPlot(data.currentComponent.abt);
    }
    if (this.settings.usePlotStructures && data.currentComponent.hasStoryCirclePlot && !data.currentComponent.storyCircle.isEmpty) {
      this.addStoryCirclePlot(data.currentComponent.storyCircle);
    }
  }
  _addCurrentComponentSelector(contentEl, type, currentComponent, components) {
    const componentSelectorEl = contentEl.createEl("select");
    componentSelectorEl.id = type;
    componentSelectorEl.style.width = "100%";
    componentSelectorEl.createEl("option", {
      text: "",
      value: ""
    }).selected = true;
    components.forEach((component) => {
      const componentOptionEl = componentSelectorEl.createEl("option", {
        text: component.file.basename,
        value: component.id.stringValue
      });
      if (currentComponent === component.id.stringValue) {
        componentOptionEl.selected = true;
      }
    });
    componentSelectorEl.addEventListener("change", (e) => {
      const file = this.currentComponent.file;
      if (file !== void 0) {
        this.manipulators.codeblock.update("data.current" + type[0].toUpperCase() + type.substring(1).toLowerCase() + "Id", componentSelectorEl.value);
      }
    });
    return (contentEl2, type2, currentComponent2, components2) => {
      let link = void 0;
      components2.forEach((component) => {
        if (currentComponent2 === component.id.stringValue)
          link = component.link;
      });
      if (link !== void 0) {
        import_obsidian20.MarkdownRenderer.renderMarkdown(link, contentEl2, "", null);
      } else {
        contentEl2.textContent = "";
      }
    };
  }
};

// src/components/components/character/views/CharacterHeaderView.ts
var CharacterHeaderView = class extends AbstractHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 13 /* DateSelector */:
          this.createContainerEl(element, this.addDateSelector.bind(this));
          break;
        case 12 /* Pronoun */:
          headlessTable.addRow(element, this._addPronoun.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
  }
  _addPronoun(contentEl, data) {
    const pronounSelectorEl = contentEl.createEl("select");
    pronounSelectorEl.createEl("option", {
      text: "",
      value: ""
    }).selected = true;
    Object.keys(Pronoun).filter((v) => isNaN(Number(v))).forEach((type, index) => {
      const pronoun = Pronoun[type];
      const pronounOptionEl = pronounSelectorEl.createEl("option", {
        text: this.factories.pronouns.readPronoun(pronoun),
        value: type.toLowerCase()
      });
      if (data.value.content === pronoun) {
        pronounOptionEl.selected = true;
      }
    });
    pronounSelectorEl.addEventListener("change", (e) => {
      const file = this.currentComponent.file;
      if (file !== void 0) {
        this.manipulators.codeblock.update("data.pronoun", pronounSelectorEl.value);
      }
    });
    return void 0;
  }
};

// src/components/components/clue/views/ClueHeaderView.ts
var ClueHeaderView = class extends AbstractHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 13 /* DateSelector */:
          this.createContainerEl(element, this.addDateSelector.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
  }
};

// src/components/components/event/views/EventHeaderView.ts
var EventHeaderView = class extends AbstractHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 13 /* DateSelector */:
          this.createContainerEl(element, this.addDateSelector.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
  }
};

// src/components/components/faction/views/FactionHeaderView.ts
var FactionHeaderView = class extends AbstractHeaderView {
};

// src/components/components/location/views/LocationHeaderView.ts
var LocationHeaderView = class extends AbstractHeaderView {
};

// src/components/components/music/views/MusicHeaderView.ts
var MusicHeaderView = class extends AbstractHeaderView {
};

// src/components/components/scene/views/SceneHeaderView.ts
var import_obsidian22 = require("obsidian");

// src/modals/SceneTypeDescriptionModal.ts
var import_obsidian21 = require("obsidian");
var sceneTypeDescription2 = [
  {
    title: "Action",
    description: "*The player characters DO something*\nAn **Action** scene type is a scene in which the player characters need to **DO** something.From building, to searching or studying, this type of scene requires the player characters to be active.",
    isActive: true
  },
  {
    title: "Combat",
    description: "*The player characters fight*\nA **Combat** scene type is a scene in which the player characters engage in a fight.",
    isActive: true
  },
  {
    title: "Encounter",
    description: "*The player characters meet someone*\nAn **Encounter** scene type is a scene in which the player characters have a social encounter with one or more NPCs. These type of scenes are usually for social gatherings, to receive information, but they do not include the player characters having to obtain something: for that there is the **Social Combat** type od scenes",
    isActive: true
  },
  {
    title: "Exposition",
    description: "*The storyteller introduce a change of scenery*\nAn **Exposition** scene type is a storyteller-lead scene in which the storyteller present something to the player characters. These type of scenes are generally short in duration and are very useful to introduce a change.",
    isActive: false
  },
  {
    title: "Investigation",
    description: "*The player characters obtain information from the surrounding environment*\nAn **Investigation** scene type is a scene in which the player characters must obtain some information from the surrounding environment. These type of scenes are similar to the **Social Combat**, but do not include NPCs from which to collect the information, hence are less social and more active",
    isActive: true
  },
  {
    title: "Planning",
    description: "*The player characters decide what to do next*\nA **Planning** scene type is a player character-lead scene in which the player characters plan how to move and take a decision. Often, these type of scenes are focussed on decisions alone.",
    isActive: false
  },
  {
    title: "Preparation",
    description: "*The player characters prepare what they need to do something*\nA **Praparation** scene type is a player character-lead scene in which the player characters do something after having gone through a **Planning**, as the **Preparation** scenes should not include decisions.The difference with an **Action** scene is that thhe **Preparation** scenes are mainly driven by the player characters, while the **Action** ones include external involvement.",
    isActive: false
  },
  {
    title: "Recap",
    description: "*The player characters discuss amongst themselves*\nA **Recap** scene type is a player character-lead scene in which the player characters recap something they have done. THe scene is similar to the **Planning**, but does not involve any type of decision process.",
    isActive: false
  },
  {
    title: "Social Combat",
    description: "*The player characters obtain information from an NPC*\nA **Social Combat** scene type is a scene in which the player characters must obtain something from an NPC through a discussion. The goal is to `win the argument` adn it is normally performed through persuasion, intimidation or fast talk.",
    isActive: true
  }
];
var SceneTypeDescriptionModal = class extends AbstractRpgManagerModal {
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rpgm-modal");
    this._sceneTypeDescriptionsEl = contentEl.createDiv({ cls: "rpgm-modal-scene-descriptions" });
    this._sceneTypeDescriptionsEl.createEl("h1", { text: "Scene Types" });
    sceneTypeDescription2.forEach((sceneTypeInformation) => {
      this._displaySceneTypeInformation(sceneTypeInformation);
    });
  }
  _displaySceneTypeInformation(sceneTypeInformation) {
    const descriptionContainerEl = this._sceneTypeDescriptionsEl.createDiv("description-container");
    descriptionContainerEl.createEl("h2", { text: sceneTypeInformation.title });
    const descriptionEl = descriptionContainerEl.createDiv();
    descriptionContainerEl.createSpan({ text: "This is " + (sceneTypeInformation.isActive ? "" : "NOT ") + 'an "active" type of scene' });
    import_obsidian21.MarkdownRenderer.renderMarkdown(sceneTypeInformation.description, descriptionEl, "", null);
  }
  onClose() {
    super.onClose();
  }
};

// src/components/components/scene/views/SceneHeaderView.ts
var SceneHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    var _a, _b;
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 5 /* StoryCircleSelector */:
          headlessTable.addRow(element, this.addStoryCircleStageSelector.bind(this));
          break;
        case 4 /* SessionSelection */:
          headlessTable.addRow(element, this._addSessionSelector.bind(this));
          break;
        case 7 /* SceneTypeSelector */:
          headlessTable.addRow(element, this._addSceneTypeSelector.bind(this));
          break;
        case 8 /* SceneExcitment */:
          headlessTable.addRow(element, this.addSceneExcitmentSelector.bind(this));
          break;
        case 9 /* SceneRun */:
          headlessTable.addRow(element, this._runScene.bind(this));
          break;
        case 10 /* SceneRunTime */:
          headlessTable.addRow(element, this._sceneRunTime.bind(this));
          break;
        case 13 /* DateSelector */:
          headlessTable.addRow(element, this._addSceneDateSelector.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
    if (((_b = (_a = data.metadata) == null ? void 0 : _a.sourceMeta) == null ? void 0 : _b.analyser) !== void 0) {
      data.metadata.sourceMeta.analyser.render(2 /* Scene */, this.headerContainerEl);
    }
  }
  _addSceneDateSelector(contentEl, data) {
    const options = {
      allowInput: true,
      dateFormat: "Y-m-d",
      altInput: true,
      onChange: (selectedDate, dateStr, instance) => {
        this.manipulators.codeblock.update("data.date", dateStr);
      }
    };
    if (this.currentComponent.date !== void 0)
      options.defaultDate = this.currentComponent.date;
    const flatpickrEl = contentEl.createEl("input", { cls: "flatpickr", type: "text" });
    flatpickrEl.placeholder = "Select the Scene Date";
    flatpickrEl.readOnly = true;
    esm_default(flatpickrEl, options);
  }
  _sceneRunTime(contentEl, data) {
    const durationEl = contentEl.createSpan({ text: this._countOngoingDuration() });
    if (this.currentComponent.isCurrentlyRunning) {
      setInterval(() => {
        durationEl.textContent = this._countOngoingDuration();
      }, 1e3);
    }
  }
  _countOngoingDuration() {
    var _a;
    let duration2 = (_a = this.currentComponent.currentDuration) != null ? _a : 0;
    if (this.currentComponent.lastStart !== void 0 && this.currentComponent.lastStart !== 0) {
      duration2 += Math.floor(Date.now() / 1e3) - this.currentComponent.lastStart;
    }
    const expectedHoursDuration = Math.floor(duration2 / 60);
    const expectedMinutesDuration = Math.floor(duration2 - expectedHoursDuration * 60);
    return (expectedHoursDuration < 10 ? "0" + expectedHoursDuration.toString() : expectedHoursDuration.toString()) + ":" + (expectedMinutesDuration < 10 ? "0" + expectedMinutesDuration.toString() : expectedMinutesDuration.toString());
  }
  _runScene(contentEl, data) {
    const startStopEl = contentEl.createEl("a", { href: "#", text: this.currentComponent.isCurrentlyRunning ? "stop" : "start" });
    startStopEl.addEventListener("click", (e) => {
      const editorPositions = /* @__PURE__ */ new Map();
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.view instanceof import_obsidian22.MarkdownView) {
          const editor = leaf.view.editor;
          editorPositions.set(editor, editor.getScrollInfo().top);
        }
      });
      e.preventDefault();
      if (this.currentComponent.isCurrentlyRunning) {
        this.factories.runningTimeManager.stopScene(this.currentComponent).then(() => {
          setTimeout(() => {
            this._refreshEditorsPosition(editorPositions);
          }, 0);
        });
      } else {
        this.factories.runningTimeManager.startScene(this.currentComponent).then(() => {
          setTimeout(() => {
            this._refreshEditorsPosition(editorPositions);
          }, 0);
        });
      }
    });
  }
  _refreshEditorsPosition(editorsPosition) {
    return __async(this, null, function* () {
      editorsPosition.forEach((position, editor) => {
        if (editor.getScrollInfo().top !== position) {
          editor.scrollTo(0, position);
        }
      });
    });
  }
  addSceneExcitmentSelector(contentEl, data) {
    var _a;
    if (((_a = data.additionalInformation) == null ? void 0 : _a.sceneId) !== void 0) {
      const sceneExcitementSelectorEl = contentEl.createEl("input");
      sceneExcitementSelectorEl.type = "checkbox";
      if (data.value.content === true)
        sceneExcitementSelectorEl.checked = true;
      sceneExcitementSelectorEl.addEventListener("change", (e) => {
        const file = data.additionalInformation.file;
        if (file !== void 0) {
          this.manipulators.codeblock.update("data.isActedUpon", sceneExcitementSelectorEl.checked);
        }
      });
    }
    return void 0;
  }
  _addSceneTypeSelector(contentEl, data) {
    var _a;
    if (((_a = data.additionalInformation) == null ? void 0 : _a.sceneId) !== void 0) {
      const sceneTypeSelectorEl = contentEl.createEl("select");
      sceneTypeSelectorEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
      Object.keys(SceneType).filter((v) => isNaN(Number(v))).forEach((type, index) => {
        var _a2;
        const sceneTypeOptionEl = sceneTypeSelectorEl.createEl("option", {
          text: (_a2 = sceneTypeDescription.get(SceneType[type])) != null ? _a2 : type,
          value: type
        });
        if (data.value.content !== void 0 && data.value.content === SceneType[type])
          sceneTypeOptionEl.selected = true;
      });
      sceneTypeSelectorEl.addEventListener("change", (e) => {
        const file = data.additionalInformation.file;
        if (file !== void 0) {
          this.manipulators.codeblock.update("data.sceneType", this.factories.sceneType.createReadableSceneType(SceneType[sceneTypeSelectorEl.value]));
        }
      });
      contentEl.createSpan({ text: "?" }).addEventListener("click", () => {
        new SceneTypeDescriptionModal(this.app).open();
      });
    }
    return void 0;
  }
  _addCurrentSessionLink(contentEl, data) {
    var _a;
    const sceneId = (_a = data.additionalInformation) == null ? void 0 : _a.sceneId;
    if (sceneId !== void 0) {
      const sessions = data.additionalInformation.sessions;
      sessions.forEach((session) => {
        var _a2;
        if (data.value.content.toString() === ((_a2 = session.id.sessionId) == null ? void 0 : _a2.toString())) {
          import_obsidian22.MarkdownRenderer.renderMarkdown(session.file.path, contentEl, "", null);
        }
      });
    }
  }
  _addSessionSelector(contentEl, data) {
    var _a;
    const sceneId = (_a = data.additionalInformation) == null ? void 0 : _a.sceneId;
    if (sceneId !== void 0) {
      const sessions = data.additionalInformation.sessions;
      const sessionSelectorEl = contentEl.createEl("select");
      sessionSelectorEl.createEl("option", {
        text: "",
        value: ""
      }).selected = true;
      sessions.forEach((session) => {
        var _a2, _b;
        const sessionOptionEl = sessionSelectorEl.createEl("option", {
          text: session.file.basename,
          value: (_a2 = session.id.sessionId) == null ? void 0 : _a2.toString()
        });
        if (data.value.content !== void 0 && data.value.content.toString() === ((_b = session.id.sessionId) == null ? void 0 : _b.toString()))
          sessionOptionEl.selected = true;
      });
      sessionSelectorEl.addEventListener("change", (e) => {
        const file = data.additionalInformation.file;
        if (file !== void 0) {
          this.manipulators.codeblock.update("data.sessionId", +sessionSelectorEl.value);
        }
      });
    }
    return (contentEl2, data2) => {
      var _a2;
      const sceneId2 = (_a2 = data2.additionalInformation) == null ? void 0 : _a2.sceneId;
      if (sceneId2 !== void 0) {
        const sessions = data2.additionalInformation.sessions;
        sessions.forEach((session) => {
          var _a3;
          if (data2.value.content !== void 0 && data2.value.content.toString() === ((_a3 = session.id.sessionId) == null ? void 0 : _a3.toString())) {
            import_obsidian22.MarkdownRenderer.renderMarkdown(session.link, contentEl2, "", null);
          }
        });
      }
    };
  }
};

// src/modals/SceneSelectionModal.ts
var import_obsidian23 = require("obsidian");
var SceneSelectionModal = class extends AbstractRpgManagerModal {
  constructor(app2, _session) {
    super(app2);
    this._session = _session;
    this._scenesEls = /* @__PURE__ */ new Map();
    this._loadAvailableScenes();
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rpgm-modal");
    contentEl.createEl("h2", { text: "Scene Selector" });
    contentEl.createEl("p", { text: 'Select the scenes to add to the session "' + this._session.file.basename + '"' });
    const actSelectorContainerEl = contentEl.createDiv("selector");
    actSelectorContainerEl.createDiv({ text: "Limit scenes to a specific act" });
    this._actSelectorEl = actSelectorContainerEl.createEl("select");
    this._actSelectorEl.createEl("option", {
      text: "",
      value: ""
    });
    const acts = this.database.read((act) => act.id.type === 4 /* Act */ && act.id.campaignId === this._session.id.campaignId).sort(this.factories.sorter.create([
      new SorterComparisonElement((act) => act.file.stat.mtime, 1 /* Descending */)
    ]));
    acts.forEach((act) => {
      this._actSelectorEl.createEl("option", { text: act.file.basename, value: act.file.path });
    });
    this._actSelectorEl.addEventListener("change", () => {
      if (this._actSelectorEl.value !== "") {
        this._selectedAct = this.database.readByPath(this._actSelectorEl.value);
      } else {
        this._selectedAct = void 0;
      }
      this._loadAvailableScenes();
      this._populateAvailableScenes();
    });
    this._sessionContainerEl = contentEl.createDiv();
    this._populateAvailableScenes();
    const scenesSelectionButtonEl = contentEl.createEl("button", { text: 'Add selected scenes to session "' + this._session.file.basename + '"' });
    scenesSelectionButtonEl.addEventListener("click", () => {
      return this._addScenes().then(() => {
        this._session.readMetadata().then(() => {
          DatabaseInitialiser.reinitialiseRelationships(this._session, this.database);
        });
        return;
      }).then(() => {
        this.app.workspace.trigger("rpgmanager:refresh-views");
        this.close();
        return;
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
  _loadAvailableScenes() {
    this._availableScenes = this.database.read((scene) => {
      var _a;
      return scene.id.type === 8 /* Scene */ && scene.id.campaignId === this._session.id.campaignId && (this._selectedAct !== void 0 ? scene.id.actId === this._selectedAct.id.actId : true) && (scene.session === void 0 || ((_a = scene.session) == null ? void 0 : _a.id.sessionId) === this._session.id.sessionId);
    }).sort(this.factories.sorter.create([
      new SorterComparisonElement((scene) => scene.id.adventureId),
      new SorterComparisonElement((scene) => scene.id.actId),
      new SorterComparisonElement((scene) => scene.id.sceneId)
    ]));
  }
  _populateAvailableScenes() {
    let populateInitialScenes = false;
    if (this._initialScenesEls === void 0) {
      this._initialScenesEls = /* @__PURE__ */ new Map();
      populateInitialScenes = true;
    }
    if (this._sessionContainerEl.childNodes.length > 0) {
      const keysToRemove = [];
      this._sessionContainerEl.childNodes.forEach((value, key, parent) => {
        const option = value.childNodes[0];
        if (!option.checked) {
          keysToRemove.push(key);
        }
      });
      keysToRemove.sort((n1, n2) => n2 - n1).forEach((key) => {
        this._sessionContainerEl.childNodes[key].remove();
      });
    }
    this._availableScenes.forEach((scene) => {
      var _a;
      if (!this._scenesEls.has(scene.file.path)) {
        const checkboxDiv = this._sessionContainerEl.createDiv();
        const checkbox = checkboxDiv.createEl("input");
        checkbox.type = "checkbox";
        checkbox.value = scene.file.path;
        checkbox.id = scene.file.basename;
        if (((_a = scene.session) == null ? void 0 : _a.id.sessionId) === this._session.id.sessionId) {
          checkbox.checked = true;
          this._scenesEls.set(scene.file.path, checkbox);
          if (populateInitialScenes)
            this._initialScenesEls.set(scene.file.path, checkbox.checked);
        }
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            this._scenesEls.set(scene.file.path, checkbox);
          }
        });
        const checkboxLabel = checkboxDiv.createEl("label", { text: scene.file.basename });
        checkboxLabel.htmlFor = scene.file.basename;
      }
    });
  }
  _addScenes() {
    return __async(this, null, function* () {
      this._scenesEls.forEach((sceneEl, path2) => {
        var _a;
        const initialSceneCheked = this._initialScenesEls.get(path2);
        if (initialSceneCheked === void 0 || sceneEl.checked !== initialSceneCheked) {
          const file = this.app.vault.getAbstractFileByPath(path2);
          if (file != null && file instanceof import_obsidian23.TFile) {
            this.manipulators.codeblock.updateInFile(file, "data.sessionId", sceneEl.checked === true ? (_a = this._session.id.sessionId) != null ? _a : "" : "");
          }
        }
      });
      return;
    });
  }
};

// src/components/components/session/views/SessionHeaderView.ts
var SessionHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      switch (element.type) {
        case 3 /* ScenesSelection */:
          headlessTable.addRow(element, this.addScenesSelection.bind(this));
          break;
        case 6 /* AbtSelector */:
          headlessTable.addRow(element, this.addAbtStageSelector.bind(this));
          if (this.currentComponent.abtStage !== void 0) {
            this._analyser = element.additionalInformation.sceneAnalyser;
          }
          break;
        case 11 /* SceneAnalyser */:
          this._analyser = element.additionalInformation.sceneAnalyser;
          break;
        case 13 /* DateSelector */:
          headlessTable.addRow(element, this.addIrlDateSelector.bind(this));
          break;
        case 14 /* DurationSelector */:
          headlessTable.addRow(element, this.addTargetDurationSelector.bind(this));
          break;
        default:
          element.value.fillContent(this.createContainerEl(element), this.sourcePath);
          break;
      }
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
    if (data.metadata.isSceneNoteListAvailable && data.metadata.scenes !== void 0 && data.metadata.scenes.length > 0) {
      const sceneNoteReplacerButtonEl = this.headerContainerEl.createDiv().createEl("button", { cls: "actionButton", text: "Add scene list to Storyteller Diary" });
      sceneNoteReplacerButtonEl.addEventListener("click", () => {
        const content = [];
        content.push("### Storyteller Diary");
        data.metadata.scenes.forEach((scene) => {
          content.push(scene.link);
          content.push("-");
          content.push("");
        });
        content.push("");
        content.push("###");
        this.currentComponent.replaceSceneNoteList(content);
      });
    }
    if (this._analyser !== void 0) {
      this._analyser.render(1 /* Minimal */, this.headerContainerEl);
      this._analyser.render(0 /* Extended */, this.headerContainerEl);
    }
  }
  addTargetDurationSelector(contentEl, data) {
    const options = {
      allowInput: true,
      enableTime: true,
      noCalendar: true,
      minuteIncrement: 15,
      time_24hr: true,
      onChange: (selectedDate, dateStr, instance) => {
        const [hours, minutes] = dateStr.split(":");
        const duration2 = +hours * 60 + +minutes;
        this.manipulators.codeblock.update("data.targetDuration", duration2);
      }
    };
    if (this.currentComponent.targetDuration != void 0) {
      const hours = Math.floor(this.currentComponent.targetDuration / 60);
      const minutes = this.currentComponent.targetDuration % 60;
      options.defaultDate = hours.toString() + ":" + (minutes < 10 ? "0" : "") + minutes.toString();
    }
    const flatpickrEl = contentEl.createEl("input", { cls: "flatpickr", type: "text" });
    flatpickrEl.placeholder = "Target Duration";
    flatpickrEl.readOnly = true;
    esm_default(flatpickrEl, options);
  }
  addIrlDateSelector(contentEl, data) {
    const options = {
      allowInput: true,
      dateFormat: "Y-m-d",
      altInput: true,
      onChange: (selectedDate, dateStr, instance) => {
        this.manipulators.codeblock.update("data.irl", dateStr);
      }
    };
    if (this.currentComponent.irl !== void 0) {
      options.defaultDate = this.currentComponent.irl;
    } else {
    }
    const flatpickrEl = contentEl.createEl("input", { cls: "flatpickr", type: "text" });
    flatpickrEl.placeholder = "Select the Session Date";
    flatpickrEl.readOnly = true;
    esm_default(flatpickrEl, options);
  }
  addScenesSelection(contentEl, data) {
    const sceneSelectionButtonEl = contentEl.createEl("button", { text: "Select session scenes" });
    sceneSelectionButtonEl.addEventListener("click", () => {
      new SceneSelectionModal(this.app, data.additionalInformation.session).open();
    });
  }
};

// src/components/components/subplot/views/SubplotHeaderView.ts
var SubplotHeaderView = class extends AbstractPlotHeaderView {
  render(container, data) {
    super.internalRender(container, data);
    const headlessTable = new HeadlessTableView(this.app, this.sourcePath);
    data.elements.forEach((element) => {
      element.value.fillContent(this.createContainerEl(element), this.sourcePath);
    });
    this.headerContainerEl.appendChild(headlessTable.tableEl);
    if (this.settings.usePlotStructures && data.currentComponent.hasAbtPlot && !data.currentComponent.abt.isEmpty) {
      this.addAbtPlot(data.currentComponent.abt);
    }
    if (this.settings.usePlotStructures && data.currentComponent.hasStoryCirclePlot && !data.currentComponent.storyCircle.isEmpty) {
      this.addStoryCirclePlot(data.currentComponent.storyCircle);
    }
  }
};

// src/views/factories/ViewFactory.ts
var ViewFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
    this._viewTypeMap = /* @__PURE__ */ new Map();
    this._viewTypeMap.set("AgnosticTable", TableView);
    this._viewTypeMap.set("AgnosticBreadcrumb", BreadcrumbView);
    this._viewTypeMap.set("AgnosticActHeader", ActHeaderView);
    this._viewTypeMap.set("AgnosticAdventureHeader", AdventureHeaderView);
    this._viewTypeMap.set("AgnosticCampaignHeader", CampaignHeaderView);
    this._viewTypeMap.set("AgnosticCharacterHeader", CharacterHeaderView);
    this._viewTypeMap.set("AgnosticClueHeader", ClueHeaderView);
    this._viewTypeMap.set("AgnosticEventHeader", EventHeaderView);
    this._viewTypeMap.set("AgnosticFactionHeader", FactionHeaderView);
    this._viewTypeMap.set("AgnosticLocationHeader", LocationHeaderView);
    this._viewTypeMap.set("AgnosticMusicHeader", MusicHeaderView);
    this._viewTypeMap.set("AgnosticSceneHeader", SceneHeaderView);
    this._viewTypeMap.set("AgnosticSessionHeader", SessionHeaderView);
    this._viewTypeMap.set("AgnosticSubplotHeader", SubplotHeaderView);
    this._showInRightLeaf = /* @__PURE__ */ new Map();
    this._showInRightLeaf.set("rpgm-creator-view" /* RPGManager */, true);
    this._showInRightLeaf.set("rpgm-error-view" /* Errors */, true);
    this._showInRightLeaf.set("rpgm-release-note-view" /* ReleaseNote */, false);
    this._showInRightLeaf.set("rpgm-timeline-view" /* Timeline */, false);
  }
  create(settings, type, sourcePath) {
    let viewKey = CampaignSetting[settings] + ResponseType[type];
    if (!this._viewTypeMap.has(viewKey))
      viewKey = CampaignSetting[0 /* Agnostic */] + ResponseType[type];
    if (!this._viewTypeMap.has(viewKey))
      throw new Error("Type of modal " + CampaignSetting[settings] + ComponentType[type] + " cannot be found");
    return new (this._viewTypeMap.get(viewKey))(this.app, sourcePath);
  }
  showObsidianView(_0) {
    return __async(this, arguments, function* (viewType, params = []) {
      this.app.workspace.detachLeavesOfType(viewType.toString());
      const showInRightLeaf = this._showInRightLeaf.get(viewType);
      if (showInRightLeaf === true || showInRightLeaf === void 0) {
        yield this.app.workspace.getRightLeaf(false).setViewState({
          type: viewType.toString(),
          active: true
        });
      } else {
        yield this.app.workspace.getLeaf(true).setViewState({
          type: viewType.toString(),
          active: true
        });
      }
      const leaf = this.app.workspace.getLeavesOfType(viewType.toString())[0];
      const view = leaf.view;
      this.app.workspace.revealLeaf(leaf);
      view.initialise(params);
      view.render();
    });
  }
};

// src/fetchers/factories/FetcherFactory.ts
var FetcherFactory = class extends AbstractFactory {
  create(fetcherType) {
    return __async(this, null, function* () {
      return new fetcherType(this.app);
    });
  }
};

// src/id/Id.ts
var Id = class extends AbstractRpgManager {
  constructor(app2, type, campaignId, adventureId, actId, sceneId, sessionId, _existingTag) {
    super(app2);
    this.type = type;
    this._existingTag = _existingTag;
    this.campaignSettings = 0 /* Agnostic */;
    this.tagMap = /* @__PURE__ */ new Map();
    this._generateTagValue(1 /* Campaign */, campaignId);
    this._generateTagValue(2 /* Adventure */, adventureId);
    this._generateTagValue(4 /* Act */, actId);
    this._generateTagValue(8 /* Scene */, sceneId);
    this._generateTagValue(16 /* Session */, sessionId);
  }
  get stringID() {
    let response = this.type + "-" + this.campaignSettings + "-" + this.campaignId;
    if (this.type === 16 /* Session */) {
      response += "/" + this.sessionId;
    } else if (this.type === 2 /* Adventure */ || this.type === 4 /* Act */ || this.type === 8 /* Scene */) {
      response += "/" + this.adventureId;
      if (this.type === 4 /* Act */ || this.type === 8 /* Scene */) {
        response += "/" + this.actId;
        if (this.type == 8 /* Scene */) {
          response += "/" + this.sceneId;
        }
      }
    }
    return response;
  }
  get id() {
    var _a;
    const response = (_a = this.tagMap.get(this.type)) == null ? void 0 : _a.value;
    if (response === void 0)
      throw new Error("");
    return response;
  }
  set id(id) {
    const tagValue = this.tagMap.get(this.type);
    if (tagValue !== void 0) {
      tagValue.value = id;
      tagValue.status = 0 /* Valid */;
    }
  }
  get tag() {
    var _a, _b, _c, _d;
    if (this._existingTag !== void 0)
      return this._existingTag;
    const tag = this.tagHelper.dataSettings.get(this.type);
    if (tag === void 0)
      throw new Error("");
    let ids = "";
    let id;
    switch (this.type) {
      case 8 /* Scene */:
        id = (_a = this.tagMap.get(8 /* Scene */)) == null ? void 0 : _a.value;
        if (id !== void 0)
          ids = "/" + id + ids;
      case 4 /* Act */:
        id = (_b = this.tagMap.get(4 /* Act */)) == null ? void 0 : _b.value;
        if (id !== void 0)
          ids = "/" + id + ids;
      case 2 /* Adventure */:
      case 16 /* Session */:
        id = (_c = this.tagMap.get(this.type === 16 /* Session */ ? 16 /* Session */ : 2 /* Adventure */)) == null ? void 0 : _c.value;
        if (id !== void 0)
          ids = "/" + id + ids;
      default:
        id = (_d = this.tagMap.get(1 /* Campaign */)) == null ? void 0 : _d.value;
        if (id !== void 0)
          ids = "/" + id + ids;
        break;
    }
    return tag + ids;
  }
  get campaignId() {
    const response = this.getTypeValue(1 /* Campaign */);
    if (response === void 0)
      throw new TagMisconfiguredError(this.app, this);
    return response;
  }
  get adventureId() {
    return this.getTypeValue(2 /* Adventure */);
  }
  get actId() {
    return this.getTypeValue(4 /* Act */);
  }
  get sceneId() {
    return this.getTypeValue(8 /* Scene */);
  }
  get sessionId() {
    return this.getTypeValue(16 /* Session */);
  }
  get stringValue() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let response = "";
    switch (this.type) {
      case 8 /* Scene */:
        response = "/" + ((_b = (_a = this.tagMap.get(8 /* Scene */)) == null ? void 0 : _a.value) != null ? _b : "");
      case 4 /* Act */:
        response = "/" + ((_d = (_c = this.tagMap.get(4 /* Act */)) == null ? void 0 : _c.value) != null ? _d : "") + response;
      case 2 /* Adventure */:
        response = "/" + ((_f = (_e = this.tagMap.get(2 /* Adventure */)) == null ? void 0 : _e.value) != null ? _f : "") + response;
        break;
      case 16 /* Session */:
        response = "/" + ((_h = (_g = this.tagMap.get(16 /* Session */)) == null ? void 0 : _g.value) != null ? _h : "") + response;
        break;
    }
    response = this.type + "/" + ((_j = (_i = this.tagMap.get(1 /* Campaign */)) == null ? void 0 : _i.value) != null ? _j : "") + response;
    return response;
  }
  _generateTagValue(type, value) {
    let status;
    let numericValue;
    if (value === "" || value === void 0) {
      let isRequired = type === 1 /* Campaign */;
      switch (this.type) {
        case 8 /* Scene */:
          if (type === 8 /* Scene */)
            isRequired = true;
        case 4 /* Act */:
          if (type === 4 /* Act */)
            isRequired = true;
        case 2 /* Adventure */:
          if (type === 2 /* Adventure */)
            isRequired = true;
          break;
        case 16 /* Session */:
          if (type === 16 /* Session */)
            isRequired = true;
      }
      status = isRequired ? 2 /* Missing */ : 3 /* NotRequired */;
    } else {
      if (isNaN(+value)) {
        status = 1 /* Invalid */;
      } else {
        status = 0 /* Valid */;
        numericValue = +value;
      }
    }
    this.tagMap.set(type, { status, value: numericValue });
  }
  get isValid() {
    let response = true;
    this.tagMap.forEach((tagValue, componentType) => {
      if (tagValue.status === 1 /* Invalid */ || tagValue.status === 2 /* Missing */)
        response = false;
    });
    return response;
  }
  isTypeValid(type) {
    var _a, _b;
    return ((_a = this.tagMap.get(type)) == null ? void 0 : _a.status) === 0 /* Valid */ || ((_b = this.tagMap.get(type)) == null ? void 0 : _b.status) === 3 /* NotRequired */;
  }
  get invalidIds() {
    const response = /* @__PURE__ */ new Map();
    this.tagMap.forEach((tagValue, type) => {
      if (tagValue.status === 1 /* Invalid */ || tagValue.status === 2 /* Missing */)
        response.set(type, tagValue.status);
    });
    return response.size === 0 ? void 0 : response;
  }
  get possiblyNotFoundIds() {
    const response = /* @__PURE__ */ new Map();
    this.tagMap.forEach((tagValue, type) => {
      if (tagValue.value !== void 0)
        response.set(type, tagValue.value);
    });
    return response.size === 0 ? void 0 : response;
  }
  getTypeValue(type) {
    const typeValue = this.tagMap.get(type);
    if (typeValue === void 0)
      throw new Error("Tag Type not found");
    if (typeValue.status === 0 /* Valid */)
      return typeValue.value;
    if (typeValue.status === 3 /* NotRequired */)
      return void 0;
    throw new TagMisconfiguredError(this.app, this);
  }
};

// src/id/factories/IdFactory.ts
var IdFactory = class extends AbstractFactory {
  create(type, campaignId, adventureId = void 0, actId = void 0, sceneId = void 0, sessionId = void 0, existingTag = void 0, campaignSettings = void 0) {
    const response = new Id(this.app, type, this._convertIdElement(campaignId), this._convertIdElement(adventureId), this._convertIdElement(actId), this._convertIdElement(sceneId), this._convertIdElement(sessionId), existingTag);
    if (campaignSettings !== void 0)
      response.campaignSettings = campaignSettings;
    return response;
  }
  createFromTag(tag) {
    const type = this.tagHelper.getDataType(tag);
    if (type === void 0)
      throw new Error("");
    const campaignId = this.tagHelper.getId(1 /* Campaign */, tag);
    const adventureId = this.tagHelper.getId(2 /* Adventure */, tag);
    const actId = this.tagHelper.getId(4 /* Act */, tag);
    const sceneId = this.tagHelper.getId(8 /* Scene */, tag);
    let sessionId = void 0;
    if (type === 16 /* Session */) {
      sessionId = this.tagHelper.getId(16 /* Session */, tag);
    }
    return this.create(type, campaignId, adventureId, actId, sceneId, sessionId, tag);
  }
  createFromTags(tags) {
    const tag = this.tagHelper.getTag(tags);
    if (tag === void 0)
      throw new Error("");
    return this.createFromTag(tag);
  }
  _convertIdElement(id) {
    if (id === void 0)
      return void 0;
    if (typeof id === "number")
      return id.toString();
    return id;
  }
  createFromID(id, checksum) {
    const [typeString, campaignSettings, ids] = id.split("-");
    const [campaignId, adventureIdOrSessionId, actId, sceneId] = ids.split("/");
    const type = +typeString;
    const adventureId = adventureIdOrSessionId !== void 0 && type !== 16 /* Session */ ? adventureIdOrSessionId : void 0;
    const sessionId = adventureIdOrSessionId !== void 0 && type === 16 /* Session */ ? adventureIdOrSessionId : void 0;
    const response = this.create(type, campaignId, adventureId, actId, sceneId, sessionId);
    response.campaignSettings = +campaignSettings;
    return response;
  }
};

// src/responses/ResponseBreadcrumb.ts
var ResponseBreadcrumb = class extends AbstractResponse {
  constructor(app2, currentComponent) {
    super(app2, currentComponent);
    this.component = void 0;
    this.title = null;
    this.isInNewLine = false;
    this.mainTitle = null;
    this.function = null;
    this.responseType = 1 /* Breadcrumb */;
  }
};

// src/views/factories/BreadcrumbFactory.ts
var BreadcrumbFactory = class extends AbstractFactory {
  constructor() {
    super(...arguments);
    this.sceneCreator = function(scene, fileFactory) {
      var _a, _b, _c, _d;
      const newSceneId = ((_a = scene.id.sceneId) != null ? _a : 0) + 1;
      fileFactory.silentCreate(8 /* Scene */, "a" + (((_b = scene.act.id.actId) != null ? _b : 0) < 10 ? "0" + ((_c = scene.act.id.actId) == null ? void 0 : _c.toString()) : (_d = scene.act.id.actId) == null ? void 0 : _d.toString()) + "s" + (newSceneId < 10 ? "0" + newSceneId.toString() : newSceneId.toString()), scene.campaign.id.campaignId, scene.adventure.id.adventureId, scene.act.id.actId, newSceneId);
    };
  }
  create(component) {
    const response = this._generateElementBreadcrumb(null, 1 /* Campaign */, component.campaign);
    if (component.id.type !== 1 /* Campaign */) {
      response.mainTitle = ComponentType[component.id.type];
      switch (component.id.type) {
        case 2 /* Adventure */:
          this._generateAventureBreadcrumb(response, component);
          break;
        case 16 /* Session */:
          this._generateSessionBreadcrumb(response, component);
          break;
        case 4 /* Act */:
          this._generateActBreadcrumb(response, component);
          break;
        case 8 /* Scene */:
          this._generateSceneBreadcrumb(response, component);
          break;
        default:
          this._generateElementBreadcrumb(response, component.id.type, component);
          break;
      }
    }
    response.component = component;
    return response;
  }
  _generateElementBreadcrumb(parent, type, data, linkText = null, isNewLine = false) {
    const response = new ResponseBreadcrumb(this.app, data);
    response.link = data.link;
    response.title = ComponentType[type];
    if (linkText != null)
      response.linkText = linkText;
    if (isNewLine)
      response.isInNewLine = isNewLine;
    if (parent != null)
      parent.nextBreadcrumb = response;
    return response;
  }
  _generateAventureBreadcrumb(parent, adventure) {
    var _a, _b;
    const adventureBreadcrumb = this._generateElementBreadcrumb(parent, 2 /* Adventure */, adventure);
    let previousAdventure;
    let nextAdventure;
    try {
      previousAdventure = this.database.readSingle(2 /* Adventure */, adventure.id, ((_a = adventure.id.adventureId) != null ? _a : 0) - 1);
    } catch (e) {
    }
    try {
      nextAdventure = this.database.readSingle(2 /* Adventure */, adventure.id, ((_b = adventure.id.adventureId) != null ? _b : 0) + 1);
    } catch (e) {
    }
    let previousBreadcrumb = void 0;
    let nextBreadcrumb = void 0;
    if (previousAdventure !== void 0) {
      previousBreadcrumb = this._generateElementBreadcrumb(adventureBreadcrumb, 2 /* Adventure */, previousAdventure, "<< prev adventure", true);
    }
    if (nextAdventure !== void 0) {
      nextBreadcrumb = this._generateElementBreadcrumb(previousBreadcrumb != null ? previousBreadcrumb : adventureBreadcrumb, 2 /* Adventure */, nextAdventure, "next adventure >>", previousAdventure === void 0);
    }
    if (nextBreadcrumb !== void 0) {
      return nextBreadcrumb;
    } else {
      if (previousBreadcrumb !== void 0)
        return previousBreadcrumb;
      return adventureBreadcrumb;
    }
  }
  _generateSessionBreadcrumb(parent, session) {
    var _a, _b;
    const sessionBreadcrumb = this._generateElementBreadcrumb(parent, 16 /* Session */, session);
    let previousSession;
    let nextSession;
    try {
      previousSession = this.database.readSingle(16 /* Session */, session.id, ((_a = session.id.sessionId) != null ? _a : 0) - 1);
    } catch (e) {
    }
    try {
      nextSession = this.database.readSingle(16 /* Session */, session.id, ((_b = session.id.sessionId) != null ? _b : 0) + 1);
    } catch (e) {
    }
    let previousBreadcrumb = void 0;
    let nextBreadcrumb = void 0;
    if (previousSession !== void 0) {
      previousBreadcrumb = this._generateElementBreadcrumb(sessionBreadcrumb, 16 /* Session */, previousSession, "<< prev session", true);
    }
    if (nextSession !== void 0) {
      nextBreadcrumb = this._generateElementBreadcrumb(previousBreadcrumb != null ? previousBreadcrumb : sessionBreadcrumb, 16 /* Session */, nextSession, "next session >>", previousSession === void 0);
    }
    if (nextBreadcrumb !== void 0) {
      return nextBreadcrumb;
    } else {
      if (previousBreadcrumb !== void 0)
        return previousBreadcrumb;
      return sessionBreadcrumb;
    }
  }
  _generateActBreadcrumb(parent, act) {
    const adventureBreadcrumb = this._generateElementBreadcrumb(parent, 2 /* Adventure */, act.adventure);
    const actBreadcrumb = this._generateElementBreadcrumb(adventureBreadcrumb, 4 /* Act */, act);
    let previousBreadcrumb = null;
    if (act.previousAct != null)
      previousBreadcrumb = this._generateElementBreadcrumb(actBreadcrumb, 4 /* Act */, act.previousAct, "<< prev act", true);
    let nextBreadcrumb = null;
    if (act.nextAct != null)
      nextBreadcrumb = this._generateElementBreadcrumb(previousBreadcrumb != null ? previousBreadcrumb : actBreadcrumb, 4 /* Act */, act.nextAct, "next act >>", previousBreadcrumb == null);
    return nextBreadcrumb != null ? nextBreadcrumb : previousBreadcrumb != null ? previousBreadcrumb : actBreadcrumb;
  }
  _generateSceneBreadcrumb(parent, scene) {
    const adventureBreadcrumb = this._generateElementBreadcrumb(parent, 2 /* Adventure */, scene.adventure);
    const actBreadcrumb = this._generateElementBreadcrumb(adventureBreadcrumb, 4 /* Act */, scene.act);
    const sceneBreadcrumb = this._generateElementBreadcrumb(actBreadcrumb, 8 /* Scene */, scene);
    let previousBreadcrumb = null;
    if (scene.previousScene != null)
      previousBreadcrumb = this._generateElementBreadcrumb(sceneBreadcrumb, 8 /* Scene */, scene.previousScene, "<< prev scene", true);
    let nextBreadcrumb = null;
    if (scene.nextScene != null) {
      nextBreadcrumb = this._generateElementBreadcrumb(previousBreadcrumb != null ? previousBreadcrumb : sceneBreadcrumb, 8 /* Scene */, scene.nextScene, "next scene >>", previousBreadcrumb == null);
    } else {
      const newSceneBreadcrumb = new ResponseBreadcrumb(this.app, scene);
      newSceneBreadcrumb.link = "";
      newSceneBreadcrumb.linkText = "+ add scene >>";
      newSceneBreadcrumb.functionParameters = [scene, this.factories.files];
      newSceneBreadcrumb.function = this.sceneCreator;
      if (previousBreadcrumb == null) {
        newSceneBreadcrumb.isInNewLine = true;
        sceneBreadcrumb.nextBreadcrumb = newSceneBreadcrumb;
      } else {
        previousBreadcrumb.nextBreadcrumb = newSceneBreadcrumb;
      }
    }
    return nextBreadcrumb != null ? nextBreadcrumb : previousBreadcrumb != null ? previousBreadcrumb : sceneBreadcrumb;
  }
};

// src/databases/Sorter.ts
var Sorter = class {
  constructor(comparisonElements) {
    if (comparisonElements !== void 0) {
      this.comparisonElements = comparisonElements;
    } else {
      this.comparisonElements = [];
    }
  }
  addComparisonElement(comparisonElement, sortType = 0 /* Ascending */) {
    this.comparisonElements.push({ comparisonElement, sortType });
    return this;
  }
  getSortingFunction(leftData, rightData) {
    for (let index = 0; index < this.comparisonElements.length; index++) {
      const comparer = this.comparisonElements[index];
      if (typeof comparer.comparisonElement === "function") {
        if (comparer.comparisonElement(leftData) > comparer.comparisonElement(rightData))
          return comparer.sortType === 0 /* Ascending */ ? 1 : -1;
        if (comparer.comparisonElement(leftData) < comparer.comparisonElement(rightData))
          return comparer.sortType === 0 /* Ascending */ ? -1 : 1;
      } else {
        if (this.getObjectValue(leftData, comparer.comparisonElement) > this.getObjectValue(rightData, comparer.comparisonElement))
          return comparer.sortType === 0 /* Ascending */ ? 1 : -1;
        if (this.getObjectValue(leftData, comparer.comparisonElement) < this.getObjectValue(rightData, comparer.comparisonElement))
          return comparer.sortType === 0 /* Ascending */ ? -1 : 1;
      }
    }
    return 0;
  }
  getObjectValue(object, value) {
    let response = object;
    const litteralValue = value.toString();
    const valueElements = litteralValue.split(".");
    valueElements.shift();
    while (valueElements.length > 0) {
      const id = valueElements.shift();
      const idKey = id;
      response = response[idKey];
    }
    return response;
  }
};

// src/databases/factories/SorterFactory.ts
var SorterFactory = class extends AbstractFactory {
  create(comparisonElements) {
    const sorter = new Sorter(comparisonElements);
    return sorter.getSortingFunction.bind(sorter);
  }
};

// src/timers/RunningTimeManager.ts
var RunningTimeManager = class extends AbstractRpgManager {
  constructor() {
    super(...arguments);
    this.currentlyRunningScene = void 0;
    this.medianDefaultTimes = /* @__PURE__ */ new Map([
      [0 /* Action */, [15 * 60]],
      [1 /* Combat */, [15 * 60]],
      [2 /* Encounter */, [15 * 60]],
      [3 /* Exposition */, [5 * 60]],
      [4 /* Investigation */, [15 * 60]],
      [5 /* Planning */, [10 * 60]],
      [6 /* Preparation */, [10 * 60]],
      [7 /* Recap */, [5 * 60]],
      [8 /* SocialCombat */, [15 * 60]]
    ]);
    this.medianTimes = /* @__PURE__ */ new Map([
      [
        0,
        this.medianDefaultTimes
      ]
    ]);
  }
  get isTimerRunning() {
    return this.currentlyRunningScene !== void 0;
  }
  isCurrentlyRunningScene(scene) {
    if (this.currentlyRunningScene === void 0)
      return false;
    return this.currentlyRunningScene.id === scene.id;
  }
  startScene(scene) {
    return __async(this, null, function* () {
      if (this.currentlyRunningScene !== void 0)
        yield this.stopScene(this.currentlyRunningScene);
      this.currentlyRunningScene = scene;
      yield this.manipulators.codeblock.startNewDuration(this.currentlyRunningScene.file);
    });
  }
  stopScene(scene) {
    return __async(this, null, function* () {
      if (this.currentlyRunningScene === void 0)
        return;
      yield this.manipulators.codeblock.stopCurrentDuration(this.currentlyRunningScene.file);
      this.currentlyRunningScene = void 0;
    });
  }
  updateMedianTimes(isStartup = false) {
    return __async(this, null, function* () {
      const campaigns = this.database.read((campaign) => campaign.id.type === 1 /* Campaign */);
      for (let index = 0; index < campaigns.length; index++) {
        this.medianTimes.set(campaigns[index].id.campaignId, structuredClone(this.medianDefaultTimes));
      }
      const scenes = this.database.read((scene) => scene.id.type === 8 /* Scene */);
      yield scenes.forEach((scene) => {
        if (isStartup && scene.isCurrentlyRunning) {
          this.currentlyRunningScene = scene;
          this.stopScene(scene);
        }
        if (scene.sceneType !== void 0 && scene.currentDuration !== void 0 && scene.currentDuration !== 0) {
          const campaignMedians = this.medianTimes.get(scene.id.campaignId);
          if (campaignMedians !== void 0) {
            const sessionTypeTimes = campaignMedians.get(scene.sceneType);
            if (sessionTypeTimes !== void 0)
              sessionTypeTimes.push(scene.currentDuration);
          }
        }
      });
    });
  }
};

// src/abstracts/AbstractRpgManagerComponent.ts
var import_obsidian24 = require("obsidian");
var AbstractRpgManagerComponent = class extends import_obsidian24.Component {
  constructor(app2) {
    super();
    this.app = app2;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
};

// src/databases/Database.ts
var import_obsidian25 = require("obsidian");
var Database = class extends AbstractRpgManagerComponent {
  constructor(app2) {
    super(app2);
    this.recordset = [];
    this._isDatabaseReady = false;
    this._basenameIndex = /* @__PURE__ */ new Map();
  }
  ready() {
    return __async(this, null, function* () {
      this._isDatabaseReady = true;
      this.registerEvent(this.app.metadataCache.on("resolve", (file) => this.onSave(file)));
      this.registerEvent(this.app.vault.on("rename", (file, oldPath) => this._onRename(file, oldPath)));
      this.registerEvent(this.app.vault.on("delete", (file) => this._onDelete(file)));
      this.app.workspace.trigger("rpgmanager:index-complete");
      this.app.workspace.trigger("rpgmanager:refresh-views");
    });
  }
  get isReady() {
    return this._isDatabaseReady;
  }
  create(component) {
    let isNew = true;
    for (let componentsCounter = 0; componentsCounter < this.recordset.length; componentsCounter++) {
      if (this.recordset[componentsCounter].file.path === component.file.path) {
        this.recordset[componentsCounter] = component;
        isNew = false;
      }
    }
    if (isNew) {
      this.recordset.push(component);
      this._basenameIndex.set(component.file.path, component.file.basename);
    }
  }
  read(query) {
    return this.recordset.filter(query !== null ? query : true);
  }
  update(component) {
    this.create(component);
  }
  delete(component) {
    const key = typeof component === "string" ? component : component.file.path;
    let index = void 0;
    for (let componentsCounter = 0; componentsCounter < this.recordset.length; componentsCounter++) {
      if (this.recordset[componentsCounter].file.path === key) {
        index = componentsCounter;
        break;
      }
    }
    if (index !== void 0) {
      this.recordset.splice(index, 1);
      this._basenameIndex.delete(key);
    }
    return index !== void 0;
  }
  readByPath(path2) {
    const response = this.recordset.filter((component) => component.file.path === path2);
    return response.length === 1 ? response[0] : void 0;
  }
  readByBaseName(basename) {
    const response = this.recordset.filter((component) => component.file.basename === basename);
    return response.length === 1 ? response[0] : void 0;
  }
  readSingle(type, id, overloadId = void 0) {
    const result = this.read(this._generateQuery(type, id, false, overloadId));
    if (result.length === 0)
      throw new ComponentNotFoundError(this.app, id);
    return result[0];
  }
  readList(type, id, overloadId = void 0) {
    return this.read(this._generateQuery(type, id, true, overloadId));
  }
  _generateQuery(type, id, isList, overloadId = void 0) {
    let campaignId = id == null ? void 0 : id.campaignId;
    let adventureId = id == null ? void 0 : id.adventureId;
    let actId = id == null ? void 0 : id.actId;
    let sceneId = id == null ? void 0 : id.sceneId;
    let sessionId = id == null ? void 0 : id.sessionId;
    switch (type) {
      case 1 /* Campaign */:
        if (overloadId !== void 0)
          campaignId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && (isList ? true : component.id.campaignId === campaignId);
        break;
      case 2 /* Adventure */:
        if (overloadId !== void 0)
          adventureId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && component.id.campaignId === campaignId && (isList ? true : component.id.adventureId === adventureId);
        break;
      case 16 /* Session */:
        if (overloadId !== void 0)
          sessionId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && component.id.campaignId === campaignId && (isList ? true : component.id.sessionId === sessionId);
        break;
      case 4 /* Act */:
        if (overloadId !== void 0)
          actId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && component.id.campaignId === campaignId && (adventureId !== void 0 ? component.id.adventureId === adventureId : true) && (isList ? true : component.id.actId === actId);
        break;
      case 8 /* Scene */:
        if (overloadId !== void 0)
          sceneId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && component.id.campaignId === campaignId && (adventureId !== void 0 ? component.id.adventureId === adventureId : true) && component.id.actId === actId && (isList ? true : component.id.sceneId === sceneId);
        break;
      default:
        if (overloadId !== void 0)
          campaignId = overloadId;
        return (component) => (type & component.id.type) === component.id.type && component.id.campaignId === campaignId;
        break;
    }
  }
  _replaceFileContent(file, oldBaseName, newBaseName) {
    return __async(this, null, function* () {
      const content = yield this.app.vault.read(file);
      const newFileContent = content.replaceAll("[[" + oldBaseName + "]]", "[[" + newBaseName + "]]").replaceAll("[[" + oldBaseName + "|", "[[" + newBaseName + "|");
      if (content !== newFileContent) {
        return this.app.vault.modify(file, newFileContent).then(() => {
          return;
        });
      }
    });
  }
  _onDelete(file) {
    return __async(this, null, function* () {
      if (this.delete(file.path)) {
        this.app.workspace.trigger("rpgmanager:refresh-views");
      }
    });
  }
  _onRename(file, oldPath) {
    return __async(this, null, function* () {
      const oldBaseName = this._basenameIndex.get(oldPath);
      const newBaseName = file.path;
      const metadata = this.app.metadataCache.getFileCache(file);
      const component = this.readByPath(file.path);
      yield this._basenameIndex.delete(oldPath);
      if (component !== void 0)
        yield this._basenameIndex.set(file.path, file.basename);
      if (AbstractComponentData.imageExtensions.contains(file.extension)) {
        this.manipulators.allComponents.updateImagePath(oldPath, file.path);
      } else {
        this.manipulators.allComponents.updateRelationshipPath(oldPath, file.path);
      }
      if (oldBaseName !== void 0 && component !== void 0 && metadata != null) {
        yield this._replaceFileContent(file, oldBaseName, newBaseName);
        yield component.readMetadata();
        DatabaseInitialiser.reinitialiseRelationships(component, this).then(() => {
          var _a, _b;
          if (((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) === file.path) {
            (_b = this.app.workspace.getActiveViewOfType(import_obsidian25.MarkdownView)) == null ? void 0 : _b.editor.refresh();
          }
          this.app.workspace.trigger("rpgmanager:refresh-views");
        });
      }
    });
  }
  onSave(file) {
    return __async(this, null, function* () {
      let component = this.readByPath(file.path);
      try {
        const isNewComponent = component === void 0;
        if (component === void 0) {
          component = yield DatabaseInitialiser.createComponent(file);
        }
        if (component === void 0)
          return;
        yield component.readMetadata();
        yield component.validateHierarchy();
        if (isNewComponent && (component.stage === 2 /* Run */ || component.stage === 0 /* Plot */)) {
          let error = void 0;
          try {
            const duplicate = this.readSingle(component.id.type, component.id);
            error = new ComponentDuplicatedError(this.app, component.id, [duplicate], component);
          } catch (e) {
          }
          if (error !== void 0) {
            throw error;
          }
        }
        yield this.create(component);
        DatabaseInitialiser.reinitialiseRelationships(component, this).then(() => {
          this.app.workspace.trigger("rpgmanager:refresh-views");
        });
      } catch (e) {
        if (e instanceof AbstractRpgManagerError) {
          new DatabaseErrorModal(this.app, void 0, e, file).open();
        } else {
          throw e;
        }
        return;
      }
    });
  }
};

// src/databases/factories/DatabaseFactory.ts
var DatabaseFactory = class extends AbstractFactory {
  create() {
    return new Database(this.app);
  }
};

// src/plots/PlotsAbtOnly.ts
var PlotsAbtOnly = class extends AbstractComponent {
  get abt() {
    return new AbtPlot(this.metadata);
  }
};

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = __spreadValues({ timeZoneName: offsetFormat }, intlOpts);
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = __spreadValues({}, this.opts);
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" }, "weekday"), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/zone.js
var Zone = class {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var throwOnInvalid;
var Settings = class {
  static get now() {
    return now;
  }
  static set now(n2) {
    now = n2;
  }
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const _a = opts, { base: base2 } = _a, cacheKeyOpts = __objRest(_a, ["base"]);
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const _a = opts, { padTo, floor } = _a, otherOpts = __objRest(_a, ["padTo", "floor"]);
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = __spreadValues({ useGrouping: false }, opts);
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }
    const intlOpts = __spreadValues({}, this.opts);
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = __spreadValues({ style: "long" }, opts);
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: true }));
  }
  redefaultToSystem(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: false }));
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(this, void 0, defaultOK, () => meridiems, () => {
      if (!this.meridiemCache) {
        const intl = { hour: "numeric", hourCycle: "h12" };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/impl/regexParser.js
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [__spreadValues(__spreadValues({}, mergedVals), val), zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int2(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int2(match2, cursor),
    month: int2(match2, cursor + 1, 1),
    day: int2(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int2(match2, cursor, 0),
    minutes: int2(match2, cursor + 1, 0),
    seconds: int2(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(s2) {
  return parse(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s2) {
  return parse(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : __spreadValues(__spreadValues({}, dur.values), alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n2) {
  return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
var Duration = class {
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = __spreadProps(__spreadValues({}, opts), {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  toHuman(opts = {}) {
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter(__spreadProps(__spreadValues({ style: "unit", unitDisplay: "long" }, opts), { unit: unit.slice(0, -1) })).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter(__spreadValues({ type: "conjunction", style: opts.listStyle || "narrow" }, opts)).format(l2);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return __spreadValues({}, this.values);
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = __spreadValues({
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended"
    }, opts);
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    return this.as("milliseconds");
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = __spreadValues(__spreadValues({}, this.values), normalizeObject(values, Duration.normalizeUnit));
    return clone(this, { values: mixed });
  }
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone(this, { values: built }, true).normalize();
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
}
var Interval = class {
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  count(unit = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit), end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit]: delta });
      if (highWater > later) {
        cursor = cursor.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration2 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration2);
  } else {
    return duration2;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p) => tokenForPart(p, locale, formatOpts));
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return __spreadValues({ weekYear, weekNumber, weekday }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return __spreadValues({ year, ordinal }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(__spreadProps(__spreadValues(__spreadValues({}, current), alts), { old: current }));
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = __spreadProps(__spreadValues({}, inst.c), {
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }), millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, __spreadProps(__spreadValues({}, opts), {
      zone: interpretationZone,
      specificOffset
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  get(unit) {
    return this[unit];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(__spreadValues(__spreadValues({}, gregorianToWeek(this.c)), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(__spreadValues(__spreadValues({}, gregorianToOrdinal(this.c)), normalized));
    } else {
      mixed = __spreadValues(__spreadValues({}, this.toObject()), normalized);
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return clone2(this, adjustTime(this, dur));
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2).negate();
    return clone2(this, adjustTime(this, dur));
  }
  startOf(unit) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base2 = __spreadValues({}, this.c);
    if (opts.includeConfig) {
      base2.outputCalendar = this.outputCalendar;
      base2.numberingSystem = this.loc.numberingSystem;
      base2.locale = this.loc.locale;
    }
    return base2;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = __spreadValues({ locale: this.locale, numberingSystem: this.numberingSystem }, opts);
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base2 = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base2 ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base2, this.plus(padding), __spreadProps(__spreadValues({}, options), {
      numeric: "always",
      units,
      unit
    }));
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, __spreadProps(__spreadValues({}, options), {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}

// src/helpers/DateHelper.ts
var DateHelper = class {
  static create(date) {
    return DateTime.fromISO(date).toJSDate();
  }
  static age(birth, deathOrNow) {
    const end = DateTime.fromISO(deathOrNow.toISOString());
    const start = DateTime.fromISO(birth.toISOString());
    return Math.floor(end.diff(start, "years").years);
  }
};

// src/components/components/campaign/abstracts/AbstractCampaignData.ts
var AbstractCampaignData = class extends PlotsAbtOnly {
  get date() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.date) ? DateHelper.create(this.metadata.data.date) : void 0;
  }
  get currentAdventureId() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.currentAdventureId;
  }
  get currentActId() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.currentActId;
  }
  get currentSessionId() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.currentSessionId;
  }
};

// src/components/components/campaign/Campaign.ts
var Campaign = class extends AbstractCampaignData {
  constructor() {
    super(...arguments);
    this.stage = 0 /* Plot */;
  }
  get folder() {
    const lastSlashPosition = this.file.path.lastIndexOf("/");
    return lastSlashPosition !== -1 ? this.file.path.substring(0, lastSlashPosition + 1) : "/";
  }
};

// src/plots/Plots.ts
var Plots = class extends AbstractComponent {
  get abt() {
    return new AbtPlot(this.metadata);
  }
  get storyCircle() {
    return new StoryCirclePlot(this.metadata);
  }
};

// src/components/components/adventure/abstracts/AbstractAdventureData.ts
var AbstractAdventureData = class extends Plots {
};

// src/components/components/adventure/Adventure.ts
var Adventure = class extends AbstractAdventureData {
  constructor() {
    super(...arguments);
    this.stage = 0 /* Plot */;
  }
};

// src/components/components/act/abstracts/AbstractActData.ts
var AbstractActData = class extends Plots {
  get abtStage() {
    var _a;
    if (((_a = this.metadata.data) == null ? void 0 : _a.abtStage) == void 0 || this.metadata.data.abtStage === "")
      return void 0;
    return this.factories.abtStage.createAbtStage(this.metadata.data.abtStage);
  }
};

// src/components/components/act/Act.ts
var Act = class extends AbstractActData {
  constructor() {
    super(...arguments);
    this.stage = 0 /* Plot */;
  }
  validateHierarchy() {
    super.validateHierarchy();
    try {
      this.adventure.validateHierarchy();
    } catch (e) {
      throw new ComponentNotFoundError(this.app, this.id);
    }
  }
  get adventure() {
    const response = this.database.readSingle(2 /* Adventure */, this.id);
    if (response === void 0)
      throw new Error("");
    return response;
  }
  get nextAct() {
    return this._adjacentAct(true);
  }
  get previousAct() {
    return this._adjacentAct(false);
  }
  _adjacentAct(next) {
    var _a;
    const actId = this.id.actId;
    if (actId === void 0)
      return null;
    const response = this.database.read((act) => act.id.type === 4 /* Act */ && act.id.campaignId === this.id.campaignId && act.id.actId === (next ? actId + 1 : actId - 1));
    return (_a = response[0]) != null ? _a : null;
  }
};

// src/components/components/scene/abstracts/AbstractSceneData.ts
var AbstractSceneData = class extends AbstractComponent {
  get action() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.action;
  }
  get trigger() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.trigger;
  }
  get date() {
    var _a, _b;
    return ((_a = this.metadata.data) == null ? void 0 : _a.date) ? DateHelper.create((_b = this.metadata.data) == null ? void 0 : _b.date) : void 0;
  }
  get isExciting() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.isActedUpon) !== void 0 && this.metadata.data.isActedUpon === true;
  }
  get sceneType() {
    var _a;
    if (((_a = this.metadata.data) == null ? void 0 : _a.sceneType) == void 0 || this.metadata.data.sceneType === "")
      return void 0;
    return this.factories.sceneType.createSceneType(this.metadata.data.sceneType);
  }
  get storyCircleStage() {
    var _a;
    if (((_a = this.metadata.data) == null ? void 0 : _a.storyCircleStage) == void 0 || this.metadata.data.storyCircleStage === "")
      return void 0;
    return this.factories.storyCircleStage.createStoryCircleStage(this.metadata.data.storyCircleStage);
  }
};

// src/components/components/scene/Scene.ts
var Scene = class extends AbstractSceneData {
  constructor() {
    super(...arguments);
    this.stage = 0 /* Plot */;
    this._activeSceneTypes = /* @__PURE__ */ new Map([
      [0 /* Action */, true],
      [1 /* Combat */, true],
      [2 /* Encounter */, true],
      [3 /* Exposition */, false],
      [4 /* Investigation */, true],
      [5 /* Planning */, false],
      [6 /* Preparation */, true],
      [7 /* Recap */, false],
      [8 /* SocialCombat */, true]
    ]);
  }
  validateHierarchy() {
    super.validateHierarchy();
    try {
      this.adventure.validateHierarchy();
      this.act.validateHierarchy();
    } catch (e) {
      throw new ComponentNotFoundError(this.app, this.id);
    }
  }
  get act() {
    const response = this.database.readSingle(4 /* Act */, this.id);
    if (response === void 0)
      throw new Error("");
    return response;
  }
  get adventure() {
    const response = this.database.readSingle(2 /* Adventure */, this.id);
    if (response === void 0)
      throw new Error("");
    return response;
  }
  get currentDuration() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.duration) !== void 0 ? this.metadata.data.duration : 0;
  }
  get duration() {
    if (this.currentDuration === 0)
      return "00:00";
    const hours = Math.floor(this.currentDuration / (60 * 60));
    const minutes = Math.floor((this.currentDuration - hours * 60 * 60) / 60);
    return (hours < 10 ? "0" + hours.toString() : hours.toString()) + ":" + (minutes < 10 ? "0" + minutes.toString() : minutes.toString());
  }
  get expectedDuration() {
    var _a, _b;
    if (this.sceneType == void 0)
      return 0;
    const previousDurations = (_b = (_a = this.factories.runningTimeManager.medianTimes.get(this.id.campaignId)) == null ? void 0 : _a.get(this.sceneType)) != null ? _b : [];
    previousDurations.sort((left, right) => {
      if (left > right)
        return 1;
      if (left < right)
        return -1;
      return 0;
    });
    if (previousDurations.length === 0)
      return 0;
    if (previousDurations.length === 1)
      return previousDurations[0];
    if (previousDurations.length % 2 === 0) {
      const previous = previousDurations[previousDurations.length / 2];
      const next = previousDurations[previousDurations.length / 2 - 1];
      return Math.floor((previous + next) / 2);
    } else {
      return previousDurations[(previousDurations.length - 1) / 2];
    }
  }
  get isActive() {
    var _a;
    if (this.sceneType == void 0)
      return false;
    return (_a = this._activeSceneTypes.get(this.sceneType)) != null ? _a : false;
  }
  get isCurrentlyRunning() {
    var _a, _b, _c;
    if (((_a = this.metadata.data) == null ? void 0 : _a.durations) == void 0)
      return false;
    for (let index = 0; index < ((_b = this.metadata.data) == null ? void 0 : _b.durations.length); index++) {
      if (((_c = this.metadata.data) == null ? void 0 : _c.durations[index].indexOf("-")) === -1)
        return true;
    }
    return false;
  }
  get lastStart() {
    var _a, _b, _c, _d;
    if (!this.isCurrentlyRunning || ((_a = this.metadata.data) == null ? void 0 : _a.durations) == void 0)
      return 0;
    for (let index = 0; index < ((_b = this.metadata.data) == null ? void 0 : _b.durations.length); index++) {
      if (((_c = this.metadata.data) == null ? void 0 : _c.durations[index].indexOf("-")) === -1)
        return +((_d = this.metadata.data) == null ? void 0 : _d.durations[index]);
    }
    return 0;
  }
  get nextScene() {
    return this._adjacentScene(true);
  }
  get previousScene() {
    return this._adjacentScene(false);
  }
  get session() {
    var _a, _b;
    if (((_a = this.metadata.data) == null ? void 0 : _a.sessionId) === void 0)
      return void 0;
    const response = this.database.read((session) => {
      var _a2;
      return session.id.type === 16 /* Session */ && session.id.campaignId === this.id.campaignId && session.id.sessionId === ((_a2 = this.metadata.data) == null ? void 0 : _a2.sessionId);
    });
    return (_b = response[0]) != null ? _b : void 0;
  }
  _adjacentScene(next) {
    const sceneId = this.id.sceneId;
    if (sceneId === void 0)
      return null;
    try {
      return this.database.readSingle(8 /* Scene */, this.id, next ? sceneId + 1 : sceneId - 1);
    } catch (e) {
      return null;
    }
  }
};

// src/components/components/session/abstracts/AbstractSessionData.ts
var AbstractSessionData = class extends Plots {
  get irl() {
    var _a, _b;
    return ((_a = this.metadata.data) == null ? void 0 : _a.irl) ? DateHelper.create((_b = this.metadata.data) == null ? void 0 : _b.irl) : void 0;
  }
  get abtStage() {
    var _a;
    if (((_a = this.metadata.data) == null ? void 0 : _a.abtStage) == void 0)
      return void 0;
    return this.factories.abtStage.createAbtStage(this.metadata.data.abtStage);
  }
  get targetDuration() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.targetDuration;
  }
};

// src/components/components/session/Session.ts
var Session = class extends AbstractSessionData {
  constructor() {
    super(...arguments);
    this.stage = 2 /* Run */;
    this._sceneNoteListPattern = void 0;
  }
  initialiseData() {
    return __async(this, null, function* () {
      const pattern = ["### Storyteller Diary", "-", "", "###"];
      this._sceneNoteListPattern = yield this.fileManipulator.patternPosition(pattern);
    });
  }
  get isSceneNoteListAvailable() {
    return this._sceneNoteListPattern !== void 0;
  }
  replaceSceneNoteList(content) {
    return __async(this, null, function* () {
      if (this._sceneNoteListPattern !== void 0)
        this.fileManipulator.replacePattern(this._sceneNoteListPattern, content);
    });
  }
  get nextSession() {
    return this._adjacentSession(true);
  }
  get previousSession() {
    return this._adjacentSession(false);
  }
  _adjacentSession(next) {
    var _a;
    const sessionId = this.id.sessionId;
    if (sessionId === void 0)
      return null;
    const response = this.database.read((session) => session.id.type === 16 /* Session */ && session.id.campaignId === this.id.campaignId && session.id.sessionId === (next ? sessionId + 1 : sessionId - 1));
    return (_a = response[0]) != null ? _a : null;
  }
};

// src/components/components/character/abstracts/AbstractCharacterData.ts
var AbstractCharacterData = class extends AbstractComponent {
  get death() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.death) ? DateHelper.create(this.metadata.data.death) : void 0;
  }
  get dob() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.dob) ? DateHelper.create(this.metadata.data.dob) : void 0;
  }
  get goals() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.goals;
  }
  get pronoun() {
    var _a, _b;
    if (((_a = this.metadata.data) == null ? void 0 : _a.pronoun) == null || ((_b = this.metadata.data) == null ? void 0 : _b.pronoun) === "")
      return void 0;
    return this.factories.pronouns.createPronoun(this.metadata.data.pronoun);
  }
};

// src/components/components/character/Character.ts
var Character = class extends AbstractCharacterData {
  get age() {
    if (this.dob === void 0)
      return void 0;
    if (this.death === void 0 && this.campaign.date === void 0)
      return void 0;
    const end = this.death ? this.death : this.campaign.date;
    if (end === void 0)
      return void 0;
    return DateHelper.age(this.dob, end);
  }
  get isDead() {
    return this.death !== void 0;
  }
};

// src/components/components/faction/abstracts/AbstractFactionData.ts
var AbstractFactionData = class extends AbstractComponent {
};

// src/components/components/faction/Faction.ts
var Faction = class extends AbstractFactionData {
};

// src/components/components/clue/abstracts/AbstractClueData.ts
var AbstractClueData = class extends AbstractComponent {
  get found() {
    var _a;
    if (((_a = this.metadata.data) == null ? void 0 : _a.found) === void 0 || this.metadata.data.found === false || this.metadata.data.found === "")
      return void 0;
    if (typeof this.metadata.data.found === "string")
      return DateHelper.create(this.metadata.data.found);
    return void 0;
  }
};

// src/components/components/clue/Clue.ts
var Clue = class extends AbstractClueData {
};

// src/components/components/location/abstracts/AbstractLocationData.ts
var AbstractLocationData = class extends AbstractComponent {
  get address() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.address;
  }
};

// src/components/components/location/Location.ts
var Location = class extends AbstractLocationData {
};

// src/components/components/event/abstracts/AbstractEventData.ts
var AbstractEventData = class extends AbstractComponent {
  get date() {
    var _a;
    return ((_a = this.metadata.data) == null ? void 0 : _a.date) ? DateHelper.create(this.metadata.data.date) : void 0;
  }
};

// src/components/components/event/Event.ts
var Event = class extends AbstractEventData {
};

// src/fetchers/abstracts/AbstractFetcher.ts
var AbstractFetcher = class extends AbstractRpgManager {
};

// src/fetchers/YouTubeImageFetcher.ts
var YouTubeImageFetcher = class extends AbstractFetcher {
  constructor() {
    super(...arguments);
    this.fetchUrl = "https://www.googleapis.com/youtube/v3/";
  }
  playlistEndPoint(playlistId) {
    return this.fetchUrl + "playlistItems?key=" + this.settings.YouTubeKey + "&part=snippet&playlistId=" + playlistId;
  }
  songEndPoint(songId) {
    return this.fetchUrl + "videos?key=" + this.settings.YouTubeKey + "&part=snippet&id=" + songId;
  }
  fetchImage(url) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const youTubeApiKey = this.settings.YouTubeKey;
      if (youTubeApiKey === "" || youTubeApiKey == null)
        return void 0;
      let apiResponse;
      const playlistIdentifier = "playlist?list=";
      const songIdentifier = "watch?v=";
      const alternativeSongIdentifier = "youtu.be/";
      let playlistId;
      let songId;
      try {
        if (url.indexOf(playlistIdentifier) !== -1) {
          playlistId = url.substring(url.indexOf(playlistIdentifier) + playlistIdentifier.length);
        } else if (url.indexOf(songIdentifier) !== -1) {
          songId = url.substring(url.indexOf(songIdentifier) + songIdentifier.length);
        } else if (url.indexOf(alternativeSongIdentifier) !== -1) {
          songId = url.substring(url.indexOf(alternativeSongIdentifier) + alternativeSongIdentifier.length);
        }
        if (playlistId !== void 0) {
          apiResponse = yield fetch(this.playlistEndPoint(playlistId));
        } else if (songId !== void 0) {
          apiResponse = yield fetch(this.songEndPoint(songId));
        }
        if (apiResponse === void 0)
          return void 0;
        const jsonData = yield apiResponse.json();
        if (jsonData === void 0)
          return void 0;
        return (_d = (_c = (_b = (_a = jsonData.items[0]) == null ? void 0 : _a.snippet) == null ? void 0 : _b.thumbnails) == null ? void 0 : _c.high) == null ? void 0 : _d.url;
      } catch (e) {
        return void 0;
      }
    });
  }
};

// src/components/components/music/abstracts/AbstractMusicData.ts
var AbstractMusicData = class extends AbstractComponent {
  get url() {
    var _a;
    return (_a = this.metadata.data) == null ? void 0 : _a.url;
  }
};

// src/components/components/music/Music.ts
var Music = class extends AbstractMusicData {
  get image() {
    if (super.images.length > 0)
      return super.images[0].src;
    if (this.url == void 0)
      return void 0;
    if (this._dynamicImage === void 0) {
      this._fetchImage().then((image) => {
        this._dynamicImage = image;
      });
      return void 0;
    }
    return this._dynamicImage != null ? this._dynamicImage : void 0;
  }
  getThumbnail() {
    return __async(this, null, function* () {
      if (this._dynamicImage != null)
        return this._dynamicImage;
      if (this.url === void 0)
        return void 0;
      this._dynamicImage = yield this._fetchImage();
      return this._dynamicImage != null ? this._dynamicImage : void 0;
    });
  }
  _fetchImage() {
    return __async(this, null, function* () {
      var _a;
      let response = null;
      if (this.url == void 0)
        return null;
      if (this.url.indexOf("youtube.com") !== -1 || this.url.indexOf("youtu.be") !== -1) {
        const fetcher = yield this.factories.fetchers.create(YouTubeImageFetcher);
        response = (_a = yield fetcher.fetchImage(this.url)) != null ? _a : null;
      }
      return response;
    });
  }
};

// src/components/components/subplot/abstracts/AbstractSubplotData.ts
var AbstractSubplotData = class extends Plots {
};

// src/components/components/subplot/Subplot.ts
var Subplot = class extends AbstractSubplotData {
  constructor() {
    super(...arguments);
    this.stage = 1 /* Subplot */;
  }
};

// src/components/factories/ComponentFactory.ts
var ComponentFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
    this._componentTypeMap = /* @__PURE__ */ new Map();
    this._componentTypeMap.set("AgnosticCampaign", Campaign);
    this._componentTypeMap.set("AgnosticAdventure", Adventure);
    this._componentTypeMap.set("AgnosticAct", Act);
    this._componentTypeMap.set("AgnosticScene", Scene);
    this._componentTypeMap.set("AgnosticSession", Session);
    this._componentTypeMap.set("AgnosticCharacter", Character);
    this._componentTypeMap.set("AgnosticNonPlayerCharacter", Character);
    this._componentTypeMap.set("AgnosticFaction", Faction);
    this._componentTypeMap.set("AgnosticClue", Clue);
    this._componentTypeMap.set("AgnosticLocation", Location);
    this._componentTypeMap.set("AgnosticEvent", Event);
    this._componentTypeMap.set("AgnosticMusic", Music);
    this._componentTypeMap.set("AgnosticSubplot", Subplot);
  }
  create(settings, file, id) {
    let dataKey = CampaignSetting[settings] + ComponentType[id.type];
    if (!this._componentTypeMap.has(dataKey))
      dataKey = CampaignSetting[0 /* Agnostic */] + ComponentType[id.type];
    if (!this._componentTypeMap.has(dataKey))
      throw new Error("Type of interfaces " + CampaignSetting[settings] + ComponentType[id.type] + " cannot be found");
    return new (this._componentTypeMap.get(dataKey))(this.app, settings, id, file);
  }
};

// src/components/factories/ComponentTypeFactory.ts
var ComponentTypeFactory = class extends AbstractFactory {
  constructor() {
    super(...arguments);
    this._contentTypeMap = /* @__PURE__ */ new Map([
      [1 /* Campaign */, "campaign"],
      [2 /* Adventure */, "adventure"],
      [4 /* Act */, "act"],
      [8 /* Scene */, "scene"],
      [16 /* Session */, "session"],
      [4096 /* Subplot */, "subplot"],
      [64 /* NonPlayerCharacter */, "npc"],
      [32 /* Character */, "pc"],
      [512 /* Clue */, "clue"],
      [256 /* Event */, "event"],
      [1024 /* Faction */, "faction"],
      [128 /* Location */, "location"],
      [2048 /* Music */, "music"]
    ]);
  }
  createComponentType(readableContentType) {
    let response = void 0;
    this._contentTypeMap.forEach((value, type) => {
      if (value === readableContentType.toLowerCase())
        response = type;
    });
    if (response === void 0) {
      this.factories.logger.error(8 /* ComponentInitialisation */, "wrong component type: " + readableContentType, this);
      throw new Error("wrong component type: " + readableContentType);
    }
    return response;
  }
  createReadableComponentType(type) {
    const response = this._contentTypeMap.get(type);
    if (response === void 0) {
      this.factories.logger.error(8 /* ComponentInitialisation */, "Non existing component type: " + type, this);
      throw new Error("Non existing component type: " + type);
    }
    return response;
  }
};

// src/relationships/factories/RelationshipTypeFactory.ts
var RelationshipTypeFactory = class extends AbstractFactory {
  createRelationshipType(readableRelationshipType) {
    readableRelationshipType = readableRelationshipType[0].toUpperCase() + readableRelationshipType.substring(1).toLowerCase();
    return RelationshipType[readableRelationshipType];
  }
  createReadableRelationshipType(type) {
    return RelationshipType[type].toString().toLowerCase();
  }
};

// src/components/factories/SceneTypeFactory.ts
var SceneTypeFactory = class extends AbstractFactory {
  createReadableSceneType(type) {
    return SceneType[type].toString().toLowerCase();
  }
  createSceneType(readableContentType) {
    readableContentType = readableContentType[0].toUpperCase() + readableContentType.substring(1).toLowerCase();
    readableContentType = readableContentType.replaceAll("combat", "Combat");
    return SceneType[readableContentType];
  }
};

// src/plots/factories/StoryCircleStageFactory.ts
var StoryCircleStageFactory = class extends AbstractFactory {
  createReadableStoryCircleStage(type) {
    return StoryCircleStage[type].toString().toLowerCase();
  }
  createStoryCircleStage(readableStoryCircleStage) {
    readableStoryCircleStage = readableStoryCircleStage[0].toUpperCase() + readableStoryCircleStage.substring(1).toLowerCase();
    return StoryCircleStage[readableStoryCircleStage];
  }
};

// src/plots/factories/AbtStageFactory.ts
var AbtStageFactory = class extends AbstractFactory {
  createAbtStage(readableAbtStage) {
    readableAbtStage = readableAbtStage[0].toUpperCase() + readableAbtStage.substring(1).toLowerCase();
    return AbtStage[readableAbtStage];
  }
  createReadableAbtStage(type) {
    return AbtStage[type].toString().toLowerCase();
  }
};

// src/relationships/Relationship.ts
var Relationship = class {
  constructor(type, path2, description = void 0, component = void 0, isInContent = false) {
    this.type = type;
    this.path = path2;
    this.description = description;
    this.component = component;
    this.isInContent = isInContent;
  }
};

// src/relationships/factories/RelationshipFactory.ts
var RelationshipFactory = class extends AbstractFactory {
  create(type, path2, description = void 0, component = void 0, isInContent = false, existingRelationships = void 0) {
    const response = new Relationship(type, path2, description, component, isInContent);
    if (existingRelationships !== void 0)
      existingRelationships.add(response);
    return response;
  }
  createFromMetadata(relationship, existingRelationships = void 0) {
    var _a;
    const response = new Relationship(relationship.type !== void 0 ? this.factories.relationshipType.createRelationshipType(relationship.type) : 64 /* Undefined */, relationship.path, relationship.description, void 0, (_a = relationship.isInContent) != null ? _a : false);
    if (existingRelationships !== void 0)
      existingRelationships.add(response);
    return response;
  }
  createFromReverse(component, relationship) {
    var _a;
    if (component.stage === 0 /* Plot */ || component.stage === 2 /* Run */)
      return void 0;
    if (relationship.component !== null && component.file.path === ((_a = relationship.component) == null ? void 0 : _a.file.path))
      return void 0;
    let reverseRelationshipType = void 0;
    switch (relationship.type) {
      case 2 /* Bidirectional */:
        reverseRelationshipType = 1 /* Reversed */;
        break;
      case 16 /* Child */:
        reverseRelationshipType = 8 /* Parent */;
        break;
    }
    if (reverseRelationshipType === void 0)
      return void 0;
    const response = new Relationship(reverseRelationshipType, component.file.path, void 0, component, true);
    if (relationship.component !== void 0)
      relationship.component.getRelationships().add(response);
    return response;
  }
};

// src/manipulators/FileManipulator.ts
var import_obsidian26 = require("obsidian");
var FileManipulator = class extends AbstractRpgManager {
  constructor(app2, file, fileContent = void 0) {
    super(app2);
    this.file = file;
    if (fileContent !== void 0)
      this._fileContent = fileContent;
  }
  get arrayContent() {
    return this._fileContent.split("\n");
  }
  get content() {
    return this._fileContent;
  }
  getCodeBlockMetadata(requestString = false) {
    var _a, _b;
    const arrayContent = this.arrayContent;
    for (let index = 0; index < ((_b = (_a = this.cachedFile.sections) == null ? void 0 : _a.length) != null ? _b : 0); index++) {
      const section = this.cachedFile.sections !== void 0 ? this.cachedFile.sections[index] : void 0;
      if (section !== void 0) {
        if (section.type === "code") {
          if (arrayContent[section.position.start.line] === "```RpgManagerData") {
            let codeBlockContent = "";
            for (let index2 = section.position.start.line + 1; index2 < arrayContent.length; index2++) {
              if (arrayContent[index2] === "```")
                break;
              codeBlockContent += arrayContent[index2] + "\n";
            }
            if (codeBlockContent !== "") {
              if (!requestString)
                return (0, import_obsidian26.parseYaml)(codeBlockContent);
              return codeBlockContent;
            }
          }
        }
      }
    }
    return void 0;
  }
  maybeReplaceCodeBlockMetadata(newMetadata) {
    return __async(this, null, function* () {
      const arrayContent = this.arrayContent;
      const newArrayContent = [];
      let inCorrectCodeBlock = false;
      let correctBlockProcessed = false;
      for (let index = 0; index < arrayContent.length; index++) {
        if (inCorrectCodeBlock) {
          if (arrayContent[index] === "```") {
            correctBlockProcessed = true;
            inCorrectCodeBlock = false;
            const newCodeBlock = YamlHelper.stringify(newMetadata);
            const newCodeBlockArray = newCodeBlock.split("\n");
            newArrayContent.push(...newCodeBlockArray);
            newArrayContent.push("```");
          }
        } else {
          newArrayContent.push(arrayContent[index]);
          if (!correctBlockProcessed && arrayContent[index] === "```RpgManagerData") {
            inCorrectCodeBlock = true;
          }
        }
      }
      const newContent = newArrayContent.join("\n");
      if (newContent !== this._fileContent) {
        yield this.app.vault.modify(this.file, newContent);
        yield this.database.onSave(this.file).then(() => {
          var _a;
          this.factories.runningTimeManager.updateMedianTimes();
          (_a = this.database.readByPath(this.file.path)) == null ? void 0 : _a.touch();
          this.app.workspace.trigger("rpgmanager:force-refresh-views");
          ``;
        });
      }
    });
  }
  maybeWrite(newContent) {
    return __async(this, null, function* () {
      if (newContent === this.content)
        return false;
      return this.app.vault.modify(this.file, newContent).then(() => {
        this.database.onSave(this.file);
        return true;
      });
    });
  }
  read() {
    return __async(this, null, function* () {
      const cache = yield this.app.metadataCache.getFileCache(this.file);
      if (cache === null)
        return false;
      this.cachedFile = cache;
      if (this._fileContent === void 0)
        this._fileContent = yield this.app.vault.read(this.file);
      return true;
    });
  }
  patternPosition(pattern) {
    const arrayContent = this.arrayContent;
    let startLine = void 0;
    let endLine = void 0;
    let isPartialStart = void 0;
    let isPartialEnd = void 0;
    let analysedLine = 0;
    for (let index = 0; index < arrayContent.length; index++) {
      const line = arrayContent[index];
      let isMatching = false;
      if (analysedLine === 0 && pattern.length === 1) {
        isMatching = line === pattern[0];
        if (isMatching) {
          startLine = index;
          isPartialStart = false;
        }
      } else if (analysedLine === 0) {
        isMatching = line.endsWith(pattern[0]);
        if (isMatching) {
          startLine = index;
          isPartialStart = line !== pattern[0];
        }
      } else if (analysedLine === pattern.length - 1) {
        isMatching = line.startsWith(pattern[pattern.length - 1]);
        if (isMatching) {
          endLine = index;
          isPartialEnd = line !== pattern[pattern.length - 1];
        }
      } else {
        isMatching = line === pattern[analysedLine];
      }
      if (isMatching) {
        analysedLine++;
        if (startLine !== void 0 && endLine !== void 0 && isPartialStart !== void 0 && isPartialEnd !== void 0) {
          return {
            partialEnd: isPartialEnd,
            partialStart: isPartialStart,
            start: startLine,
            end: endLine + 1,
            content: pattern
          };
        }
      } else if (analysedLine !== 0) {
        analysedLine = 0;
        startLine = void 0;
        endLine = void 0;
        isPartialStart = void 0;
        isPartialEnd = void 0;
      }
    }
    return void 0;
  }
  replacePattern(patternPosition, content) {
    return __async(this, null, function* () {
      const arrayContent = this.arrayContent;
      if (patternPosition.partialStart) {
        arrayContent[patternPosition.start].replace(patternPosition.content[0], content[0]);
        patternPosition.start++;
      }
      if (patternPosition.partialEnd) {
        arrayContent[patternPosition.end].replace(arrayContent[patternPosition.end], content[content.length - 1]);
        content.splice(content.length - 1, 1);
        patternPosition.end--;
      }
      arrayContent.splice(patternPosition.start, patternPosition.end - patternPosition.start, ...content);
      this.maybeWrite(arrayContent.join("\n"));
    });
  }
};

// src/manipulators/factories/FileManipulatorFactory.ts
var FileManipulatorFactory = class extends AbstractFactory {
  create(file, fileContent = void 0) {
    return __async(this, null, function* () {
      const response = new FileManipulator(this.app, file, fileContent);
      return response.read().then((isFileManipulatorReady) => {
        if (!isFileManipulatorReady)
          return void 0;
        return response;
      });
    });
  }
};

// src/loggers/loggers/ConsoleLogger.ts
var ConsoleLogger = class extends AbstractRpgManager {
  constructor(app2) {
    super(app2);
    this._debuggableTypes = 2 /* Warning */ | 4 /* Error */;
    this._isDebug = this.pluginVersion.indexOf("-") !== -1;
  }
  maybeWriteLog(log, duration2 = void 0) {
    return __async(this, null, function* () {
      if (this._isDebug || (log.type & this._debuggableTypes) === log.type) {
        let messageContent = log.message;
        let messageHeader;
        if (messageContent.startsWith("\x1B")) {
          messageHeader = messageContent.substring(0, messageContent.indexOf("\x1B[0m") + 6) + "\n";
          messageContent = messageContent.substring(messageContent.indexOf("\x1B[0m") + 6);
        }
        const data = [
          messageContent + "\n"
        ];
        if (log.object !== void 0)
          data.push(log.object);
        switch (log.type) {
          case 1 /* Info */:
            if (messageHeader !== void 0) {
              console.info("\x1B[38;2;102;178;155mRPG Manager: " + LogMessageType[log.messageType] + "\x1B[0m\n" + messageHeader, ...data);
            } else {
              console.info("\x1B[38;2;102;178;155mRPG Manager: " + LogMessageType[log.messageType] + "\x1B[0m\n", ...data);
            }
            break;
          case 4 /* Error */:
            console.error(...data);
            break;
          default:
            console.warn(...data);
            break;
        }
      }
    });
  }
  maybeWriteLogList(group) {
    return __async(this, null, function* () {
      let maxLogType = 1 /* Info */;
      if (group.logs.length > 0) {
        const messageContent = [];
        const messageType = group.logs[0].messageType;
        const totalDuration = Date.now() - group.start;
        for (let index = 0; index < group.logs.length; index++) {
          if (index === 0) {
            group.logs[0].duration = group.logs[index].start - group.start;
          } else {
            group.logs[index].duration = group.logs[index].start - group.logs[index - 1].start;
          }
          messageContent.push(group.logs[index].message + " in " + group.logs[index].duration + "ms\n");
          if (group.logs[index].object !== void 0)
            messageContent.push(group.logs[index].object);
          if (group.logs[index].type > maxLogType)
            maxLogType = group.logs[index].type;
        }
        switch (maxLogType) {
          case 1 /* Info */:
            console.info("\x1B[38;2;102;178;155mRPG Manager: " + LogMessageType[messageType] + " (" + totalDuration / 1e3 + "s)\x1B[0m\n", ...messageContent);
            break;
          case 4 /* Error */:
            console.error(...messageContent);
            break;
          default:
            console.warn(...messageContent);
            break;
        }
      }
    });
  }
};

// src/loggers/abstracts/AbstractLogMessage.ts
var AbstractLogMessage = class {
  constructor(type, messageType, message, object) {
    this.type = type;
    this.messageType = messageType;
    this.message = message;
    this.object = object;
    this.duration = void 0;
    this.start = Date.now();
  }
};

// src/loggers/messages/InfoMessage.ts
var InfoMessage = class extends AbstractLogMessage {
  constructor(messageType, message, object) {
    super(1 /* Info */, messageType, message, object);
  }
};

// src/loggers/messages/WarningMessage.ts
var WarningMessage = class extends AbstractLogMessage {
  constructor(messageType, message, object) {
    super(2 /* Warning */, messageType, message, object);
  }
};

// src/loggers/messages/ErrorMessage.ts
var ErrorMessage = class extends AbstractLogMessage {
  constructor(messageType, message, object) {
    super(4 /* Error */, messageType, message, object);
  }
};

// src/loggers/groups/LogGroup.ts
var LogGroup = class {
  constructor() {
    this.logs = [];
    this.start = Date.now();
  }
  add(log) {
    return __async(this, null, function* () {
      this.logs.push(log);
    });
  }
};

// src/loggers/factories/LogFactory.ts
var LogFactory = class extends AbstractFactory {
  constructor(app2, type) {
    super(app2);
    this._logWriter = new ConsoleLogger(this.app);
  }
  createInfo(messageType, message, object) {
    return new InfoMessage(messageType, message, object);
  }
  info(messageType, message, object) {
    return __async(this, null, function* () {
      this._logWriter.maybeWriteLog(this.createInfo(messageType, message, object));
    });
  }
  createWarning(messageType, message, object) {
    return new WarningMessage(messageType, message, object);
  }
  warning(messageType, message, object) {
    return __async(this, null, function* () {
      this._logWriter.maybeWriteLog(this.createWarning(messageType, message, object));
    });
  }
  createError(messageType, message, object) {
    return new ErrorMessage(messageType, message, object);
  }
  error(messageType, message, object) {
    return __async(this, null, function* () {
      this._logWriter.maybeWriteLog(this.createError(messageType, message, object));
    });
  }
  createGroup() {
    return new LogGroup();
  }
  group(group) {
    return __async(this, null, function* () {
      this._logWriter.maybeWriteLogList(group);
    });
  }
};

// src/analyser/AnalyserData.ts
var AnalyserData = class {
  constructor() {
    this.abtStage = void 0;
    this.dataLength = 0;
    this.totalRunningTime = 0;
    this.totalActiveScenes = 0;
    this.totalRepetitiveScenes = 0;
    this.totalExpectedRunningTime = 0;
    this.totalExpectedExcitmentDuration = 0;
    this.totalTargetDuration = 0;
    this.dataTypeUsed = /* @__PURE__ */ new Map();
    this._previousType = void 0;
  }
  get isValid() {
    return this.dataLength !== 0;
  }
  set dataCount(count) {
    this.dataLength = count;
  }
  addExpectedRunningTime(duration2) {
    this.totalExpectedRunningTime += duration2;
  }
  addExpectedExcitmentDuration(duration2) {
    this.totalExpectedExcitmentDuration += duration2;
  }
  addActiveScene() {
    this.totalActiveScenes++;
  }
  addSceneType(type) {
    var _a;
    if (type !== void 0) {
      this.dataTypeUsed.set(type, ((_a = this.dataTypeUsed.get(type)) != null ? _a : 0) + 1);
      if (this._previousType === type) {
        this.totalRepetitiveScenes++;
      } else {
        this._previousType = type;
      }
    }
  }
};

// src/analyser/views/abstract/AbstractAnalyserView.ts
var AbstractAnalyserView = class extends AbstractRpgManager {
  constructor(app2, type) {
    super(app2);
    this.type = type;
    this.subtitles = /* @__PURE__ */ new Map([
      [0 /* Activity */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "Too many active scenes"],
        [2 /* High */, "Maybe too many active scenes"],
        [3 /* Correct */, "The amount of active scenes is balanced"],
        [4 /* Low */, "Maybe not enough active scenes"],
        [5 /* CriticallyLow */, "Not enough active scenes"]
      ])],
      [1 /* Duration */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "The session is going to be too long"],
        [2 /* High */, "The session might be too long"],
        [3 /* Correct */, "The expected duration is in line with your target session duration"],
        [4 /* Low */, "The session might be short"],
        [5 /* CriticallyLow */, "The session is too short"]
      ])],
      [2 /* Excitement */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "Too much excitement"],
        [2 /* High */, "Maybe too much excitement"],
        [3 /* Correct */, "The amount of exciting time is balanced"],
        [4 /* Low */, "Maybe not enough excitement"],
        [5 /* CriticallyLow */, "Not enough excitement"]
      ])],
      [3 /* Interest */, /* @__PURE__ */ new Map([
        [5 /* CriticallyLow */, "Repetitive"],
        [4 /* Low */, "Maybe a bit repetitive"],
        [3 /* Correct */, "The scenes are not repetitive"]
      ])],
      [5 /* Variety */, /* @__PURE__ */ new Map([
        [3 /* Correct */, "There is a good variety of scenes"],
        [4 /* Low */, "Maybe not enough variety"],
        [5 /* CriticallyLow */, "Not enough variety"]
      ])]
    ]);
  }
  transformTime(duration2) {
    if (duration2 === void 0)
      return "00:00";
    const hours = Math.floor(duration2 / (60 * 60));
    const minutes = Math.floor((duration2 - hours * (60 * 60)) / 60);
    return (hours < 10 ? "0" + hours.toString() : hours.toString()) + ":" + (minutes < 10 ? "0" + minutes.toString() : minutes.toString());
  }
  prepareDescription(percentage, score, maximumScore, descriptionTemplate, ideal, type = void 0) {
    if (descriptionTemplate === void 0 || descriptionTemplate === "")
      return "";
    let response = descriptionTemplate;
    if (percentage !== void 0)
      response = response.replace("%percentage%", percentage.toString());
    if (score !== void 0)
      response = response.replace("%score%", score.toString());
    if (maximumScore !== void 0)
      response = response.replace("%maximumScore%", maximumScore.toString());
    if (type !== void 0)
      response = response.replace("%type%", ComponentType[type]);
    if (ideal !== void 0)
      response = response.replace("%ideal%", ideal.toString());
    return response;
  }
  addThresholdClass(threshold, containerEl) {
    switch (threshold) {
      case 1 /* CriticallyHigh */:
        containerEl.addClass("perfect");
        break;
      case 2 /* High */:
        containerEl.addClass("balanced");
        break;
      case 4 /* Low */:
        containerEl.addClass("warning");
        break;
      case 5 /* CriticallyLow */:
        containerEl.addClass("error");
        break;
    }
  }
  addThresholdErrorClass(threshold, containerEl) {
    switch (threshold) {
      case 3 /* Correct */:
        containerEl.addClass("perfect");
        break;
      case 1 /* CriticallyHigh */:
        containerEl.addClass("error");
        break;
      case 2 /* High */:
        containerEl.addClass("warning");
        break;
      case 4 /* Low */:
        containerEl.addClass("warning");
        break;
      case 5 /* CriticallyLow */:
        containerEl.addClass("error");
        break;
    }
  }
};

// src/analyser/views/AnalyserMinimalView.ts
var AnalyserMinimalView = class extends AbstractAnalyserView {
  constructor() {
    super(...arguments);
    this._description = /* @__PURE__ */ new Map([
      [void 0, "Score"],
      [0 /* Activity */, "Activity"],
      [1 /* Duration */, "Duration"],
      [2 /* Excitement */, "Excitement"],
      [3 /* Interest */, "Interest"],
      [5 /* Variety */, "Variety"],
      [4 /* Timing */, "Timing"]
    ]);
  }
  render(report, containerEl) {
    var _a;
    if (!report.isValid)
      return;
    const analyserEl = containerEl.createDiv({ cls: "rpgm-new-analyser centred" });
    const analyserContainerEl = analyserEl.createDiv({ cls: "analyser-container clearfix" });
    this._addCircle(analyserContainerEl, report.percentage, report.thresholdType, true, "Score");
    if (report.durationPercentage === 0 && isNaN(report.durationPercentage))
      this._addCircle(analyserContainerEl, report.durationPercentage, report.durationThreshold, true, (_a = this._description.get(void 0)) != null ? _a : "");
    report.details.forEach((reportDetail) => {
      var _a2;
      if (reportDetail.isRelevant === false)
        return;
      this._addCircle(analyserContainerEl, reportDetail.percentage, reportDetail.thresholdType, reportDetail.isHighBetter, (_a2 = this._description.get(reportDetail.detailType)) != null ? _a2 : "");
    });
  }
  _addCircle(containerEl, percentage, threshold, isHigerBetter, description) {
    const circleContainerEl = containerEl.createDiv({ cls: "circle-container" });
    const circleEl = circleContainerEl.createDiv({ cls: " c100 p" + percentage.toString() + " small" });
    circleEl.createSpan({ text: percentage.toString() + "%" });
    const sliceEl = circleEl.createDiv({ cls: "slice" });
    sliceEl.createDiv({ cls: "bar" });
    sliceEl.createDiv({ cls: "fill" });
    const circleDescriptionEl = circleContainerEl.createDiv({ cls: "description", text: description });
    if (isHigerBetter) {
      this.addThresholdClass(threshold, circleEl);
      this.addThresholdClass(threshold, circleDescriptionEl);
    } else {
      this.addThresholdErrorClass(threshold, circleEl);
      this.addThresholdErrorClass(threshold, circleDescriptionEl);
    }
  }
};

// src/analyser/views/AnalyserExtendedView.ts
var AnalyserExtendedView = class extends AbstractAnalyserView {
  constructor() {
    super(...arguments);
    this.titles = /* @__PURE__ */ new Map([
      [void 0, "Analysis score %percentage%%"],
      [0 /* Activity */, "Activity accuracy: %percentage%%"],
      [1 /* Duration */, "Plotted duration accuracy: %percentage%%"],
      [2 /* Excitement */, "Excitement accuracy: %percentage%%"],
      [3 /* Interest */, "Interest accuracy: %percentage%%"],
      [5 /* Variety */, "Variety accuracy: %percentage%%"],
      [4 /* Timing */, "Timing accuracy: %percentage%%"]
    ]);
    this.descriptions = /* @__PURE__ */ new Map([
      [0 /* Activity */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "Really, %score% scenes out of %maximumScore% are active, you should aim for %ideal%"],
        [2 /* High */, "%score% scenes out of %maximumScore% are active, you should aim for %ideal%"],
        [3 /* Correct */, "%score% scenes out of %maximumScore% are active, you should aim for %ideal%"],
        [4 /* Low */, "Only  %score% scenes out of %maximumScore% are active, you should aim for %ideal%"],
        [5 /* CriticallyLow */, "Just %score% scenes out of %maximumScore% are active, you should aim for %ideal%"]
      ])],
      [1 /* Duration */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "Really, %percentage%% longer than your target"],
        [2 /* High */, "%percentage%% longer than your target"],
        [3 /* Correct */, "%percentage%% longer or shorter than your target"],
        [4 /* Low */, "%percentage%% shorter than your target"],
        [5 /* CriticallyLow */, "%percentage%% shorter than your target"]
      ])],
      [2 /* Excitement */, /* @__PURE__ */ new Map([
        [1 /* CriticallyHigh */, "%score% are exciting, you should aim for %ideal%"],
        [2 /* High */, "%score% are exciting, you should aim for %ideal%"],
        [3 /* Correct */, "%score% are exciting, you should aim for %ideal%"],
        [4 /* Low */, "Only %score% are exciting, you should aim for %ideal%"],
        [5 /* CriticallyLow */, "Just %score% are exciting, you should aim for %ideal%"]
      ])],
      [3 /* Interest */, /* @__PURE__ */ new Map([
        [5 /* CriticallyLow */, "Really, %score% scenes type repeated in %maximumScore% scenes. Keep it below %ideal%."],
        [4 /* Low */, "%score% scenes type repeated in %maximumScore% scenes. Try to keep it below %ideal%"],
        [3 /* Correct */, "%score% scenes type repeated in %maximumScore% scenes. Try to keep it below %ideal%"]
      ])],
      [5 /* Variety */, /* @__PURE__ */ new Map([
        [3 /* Correct */, "%score% different type of scenes are used, you should aim for %ideal%"],
        [4 /* Low */, "Only %score% different type of scenes are used, you should aim for %ideal%"],
        [5 /* CriticallyLow */, "Just %score% different type of scenes are used, you should aim for %ideal%"]
      ])]
    ]);
  }
  render(report, containerEl) {
    if (!report.isValid)
      return;
    const analyserEl = containerEl.createDiv({ cls: "rpgm-new-analyser" });
    this._addHeaderElement(report, analyserEl);
    const analyserListEl = analyserEl.createEl("ul");
    this._addTimingElements(report, analyserListEl);
    report.details.forEach((reportDetail) => {
      this._addDetailElement(reportDetail, analyserListEl);
    });
  }
  _addDetailElement(reportDetail, containerEl) {
    var _a, _b, _c;
    if (reportDetail.isRelevant === false)
      return;
    const analyserListElementEl = containerEl.createEl("li");
    const title = this.prepareDescription(reportDetail.percentage, reportDetail.score, reportDetail.maximumScore, this.titles.get(reportDetail.detailType), reportDetail.ideal);
    if (title !== void 0) {
      const subtitleEl = analyserListElementEl.createSpan({ cls: "subtitle", text: title });
      if (reportDetail.isHighBetter) {
        this.addThresholdClass(reportDetail.thresholdType, subtitleEl);
      } else {
        this.addThresholdErrorClass(reportDetail.thresholdType, subtitleEl);
      }
    }
    const subtitle = this.prepareDescription(reportDetail.percentage, reportDetail.score, reportDetail.maximumScore, (_a = this.subtitles.get(reportDetail.detailType)) == null ? void 0 : _a.get(reportDetail.thresholdType), reportDetail.ideal);
    const analyserListEl = analyserListElementEl.createEl("ul");
    if (subtitle !== void 0 && subtitle !== "")
      analyserListEl.createEl("li", { text: subtitle });
    if (reportDetail.percentage !== 100) {
      let detail = void 0;
      if (reportDetail.scoreType === 1 /* Percentage */)
        detail = this.prepareDescription(reportDetail.percentage, reportDetail.score, reportDetail.maximumScore, (_b = this.descriptions.get(reportDetail.detailType)) == null ? void 0 : _b.get(reportDetail.thresholdType), reportDetail.ideal);
      else if (reportDetail.scoreType === 2 /* Time */)
        detail = this.prepareDescription(reportDetail.percentage, this.transformTime(reportDetail.score), this.transformTime(reportDetail.maximumScore), (_c = this.descriptions.get(reportDetail.detailType)) == null ? void 0 : _c.get(reportDetail.thresholdType), this.transformTime(reportDetail.ideal));
      if (detail !== void 0 && detail !== "")
        analyserListEl.createEl("li", { text: detail });
    }
  }
  _addTimingElements(report, containerEl) {
    const analyserListTimingElementEl = containerEl.createEl("li");
    if (report.durationPercentage !== 0 && !isNaN(report.durationPercentage)) {
      const detail = this.prepareDescription(report.durationPercentage, 0, 0, this.titles.get(4 /* Timing */), 0);
      const timingTitleEl = analyserListTimingElementEl.createSpan({ cls: "subtitle", text: detail });
      this.addThresholdClass(report.durationThreshold, timingTitleEl);
    } else {
      analyserListTimingElementEl.createSpan({ cls: "subtitle", text: "Time Analysis" });
    }
    const timingEl = analyserListTimingElementEl.createDiv();
    const timingListEl = timingEl.createEl("ul");
    if (report.actualDuration !== void 0 && report.actualDuration !== 0) {
      const actualDurationEl = timingListEl.createEl("li");
      const actualDuration = this.transformTime(report.actualDuration);
      const actualDurationDescription = "Actual " + ComponentType[this.type] + " duration: " + actualDuration;
      actualDurationEl.createSpan({ cls: "description", text: actualDurationDescription });
    }
    if (report.expectedDuration !== void 0 && report.expectedDuration !== 0) {
      const expectedDurationEl = timingListEl.createEl("li");
      const expectedDuration = this.transformTime(report.expectedDuration);
      const expectedDurationDescription = "Expected " + ComponentType[this.type] + " duration: " + expectedDuration;
      expectedDurationEl.createSpan({ cls: "description", text: expectedDurationDescription });
      if (report.targetDuration !== void 0 && report.targetDuration !== 0) {
        const targetDurationEl = timingListEl.createEl("li");
        const targetDuration = this.transformTime(report.targetDuration);
        const targetDurationDescription = "Target duration: " + targetDuration;
        targetDurationEl.createSpan({ cls: "description", text: targetDurationDescription });
      }
    }
  }
  _addHeaderElement(report, containerEl) {
    const analyserHeadlineEl = containerEl.createSpan({ cls: "header" });
    analyserHeadlineEl.textContent = this.prepareDescription(report.percentage, report.score, report.maximumScore, this.titles.get(void 0), report.ideal, this.type);
    this.addThresholdClass(report.thresholdType, analyserHeadlineEl);
  }
};

// src/analyser/abstracts/AbstractAnalyserReportDetail.ts
var AbstractAnalyserReportDetail = class {
  constructor(data) {
    this.data = data;
    this._isRelevant = true;
  }
  get ideal() {
    return this._idealScore;
  }
  get detailType() {
    return this._detailType;
  }
  get scoreType() {
    return this._type;
  }
  get isRelevant() {
    return this._isRelevant;
  }
  get maximumScore() {
    return this._maximumScore;
  }
  get score() {
    return this._score;
  }
  get isHighBetter() {
    return false;
  }
  get percentage() {
    if (this.maximumScore === 0)
      return 0;
    return Math.floor(this.score * 100 / this.maximumScore);
  }
  get thresholdType() {
    if (this.percentage < 30)
      return 5 /* CriticallyLow */;
    if (this.percentage < 60)
      return 4 /* Low */;
    if (this.percentage < 75)
      return 3 /* Correct */;
    if (this.percentage < 90)
      return 2 /* High */;
    return 1 /* CriticallyHigh */;
  }
  get percentageThresholdScore() {
    if (this._idealScore === void 0)
      return 0 /* NotAnalysable */;
    if (this._score > this._idealScore) {
      if (this.percentage < 60)
        return 1 /* CriticallyHigh */;
      if (this.percentage < 80)
        return 2 /* High */;
    } else {
      if (this.percentage < 60)
        return 5 /* CriticallyLow */;
      if (this.percentage < 80)
        return 4 /* Low */;
    }
    return 3 /* Correct */;
  }
};

// src/analyser/reports/details/AnalyserReportActivityDetail.ts
var AnalyserReportActivityDetail = class extends AbstractAnalyserReportDetail {
  constructor(data) {
    var _a;
    super(data);
    this._type = 1 /* Percentage */;
    this._detailType = 0 /* Activity */;
    this._abtStageActivityThreshold = /* @__PURE__ */ new Map([
      [0 /* Need */, 35],
      [1 /* And */, 75],
      [2 /* But */, 50],
      [3 /* Therefore */, 75]
    ]);
    this._maximumScore = this.data.dataLength;
    this._score = this.data.totalActiveScenes;
    if (this.data.abtStage === void 0) {
      this._idealScore = Math.floor(this.maximumScore * 50 / 100);
    } else {
      this._idealScore = Math.floor(this.maximumScore * ((_a = this._abtStageActivityThreshold.get(this.data.abtStage)) != null ? _a : 50) / 100);
    }
  }
  get percentage() {
    if (this._idealScore === void 0)
      return 0;
    if (this._score === this._idealScore)
      return 100;
    if (this._score > this._idealScore * 2)
      return 0;
    if (this._score > this._idealScore)
      return Math.floor((this._idealScore - (this._score - this._idealScore)) * 100 / this._idealScore);
    return Math.floor(this._score * 100 / this._idealScore);
  }
  get thresholdType() {
    return this.percentageThresholdScore;
  }
};

// src/analyser/reports/details/AnalyserReportDurationDetail.ts
var AnalyserReportDurationDetail = class extends AbstractAnalyserReportDetail {
  constructor(data) {
    super(data);
    this._type = 2 /* Time */;
    this._detailType = 1 /* Duration */;
    if (this.data.totalTargetDuration === 0 || this.data.totalExpectedRunningTime === 0) {
      this._isRelevant = false;
      return;
    }
    this._maximumScore = this.data.totalTargetDuration;
    this._idealScore = this._maximumScore;
    this._score = Math.floor(this.data.totalExpectedRunningTime / 60);
  }
  get percentage() {
    if (this.data.totalTargetDuration === 0 || this.data.totalExpectedRunningTime === 0)
      return 0;
    if (this._score > this._maximumScore * 2)
      return 0;
    if (this._score > this._maximumScore)
      return Math.floor((this._maximumScore - (this._score - this._maximumScore)) * 100 / this._maximumScore);
    return Math.floor(this._score * 100 / this._maximumScore);
  }
  get thresholdType() {
    return this.percentageThresholdScore;
  }
};

// src/analyser/reports/details/AnalyserReportExcitementDetail.ts
var AnalyserReportExcitementDetail = class extends AbstractAnalyserReportDetail {
  constructor(data) {
    var _a;
    super(data);
    this._type = 2 /* Time */;
    this._detailType = 2 /* Excitement */;
    this._abtStageExcitementThreshold = /* @__PURE__ */ new Map([
      [0 /* Need */, 35],
      [1 /* And */, 35],
      [2 /* But */, 75],
      [3 /* Therefore */, 50]
    ]);
    if (this.data.totalExpectedRunningTime === 0)
      return;
    this._maximumScore = this.data.totalExpectedRunningTime;
    this._score = this.data.totalExpectedExcitmentDuration;
    if (this.data.abtStage === void 0) {
      this._idealScore = Math.floor(this.maximumScore * 50 / 100);
    } else {
      this._idealScore = Math.floor(this.maximumScore * ((_a = this._abtStageExcitementThreshold.get(this.data.abtStage)) != null ? _a : 50) / 100);
    }
  }
  get percentage() {
    if (this._idealScore === void 0)
      return 0;
    if (this._score === this._idealScore)
      return 100;
    if (this._score > this._idealScore * 2)
      return 0;
    if (this._score > this._idealScore)
      return Math.floor((this._idealScore - (this._score - this._idealScore)) * 100 / this._idealScore);
    return Math.floor(this._score * 100 / this._idealScore);
  }
  get thresholdType() {
    return this.percentageThresholdScore;
  }
};

// src/analyser/reports/details/AnalyserReportInterestDetail.ts
var AnalyserReportInterestDetail = class extends AbstractAnalyserReportDetail {
  constructor(data) {
    super(data);
    this._type = 1 /* Percentage */;
    this._detailType = 3 /* Interest */;
    this._score = this.data.dataLength - this.data.totalRepetitiveScenes;
    this._maximumScore = this.data.dataLength;
    this._idealScore = this.data.dataLength;
  }
  get isHighBetter() {
    return true;
  }
};

// src/analyser/reports/details/AnalyserReportVarietyDetail.ts
var AnalyserReportVarietyDetail = class extends AbstractAnalyserReportDetail {
  constructor(data) {
    super(data);
    this._type = 1 /* Percentage */;
    this._detailType = 5 /* Variety */;
    this._score = this.data.dataTypeUsed.size;
    this._maximumScore = this.data.dataLength;
    this._idealScore = 6;
  }
  get percentage() {
    if (this._idealScore === void 0)
      return 0;
    if (this._score >= this._idealScore)
      return 100;
    return Math.floor(this._score * 100 / this._idealScore);
  }
  get isHighBetter() {
    return true;
  }
};

// src/analyser/reports/AnalyserReport.ts
var AnalyserReport = class extends AbstractRpgManager {
  constructor(app2, _data) {
    super(app2);
    this._data = _data;
    this.activity = new AnalyserReportActivityDetail(_data);
    this.duration = new AnalyserReportDurationDetail(_data);
    this.excitement = new AnalyserReportExcitementDetail(_data);
    this.interest = new AnalyserReportInterestDetail(_data);
    this.variety = new AnalyserReportVarietyDetail(_data);
    this._reportDetails = /* @__PURE__ */ new Map([
      [0 /* Activity */, this.activity],
      [1 /* Duration */, this.duration],
      [2 /* Excitement */, this.excitement],
      [3 /* Interest */, this.interest],
      [5 /* Variety */, this.variety]
    ]);
  }
  get ideal() {
    return void 0;
  }
  get scoreType() {
    return 1 /* Percentage */;
  }
  get isValid() {
    return this._data.isValid;
  }
  get details() {
    const response = [];
    this._reportDetails.forEach((detail) => {
      if (detail.isRelevant)
        response.push(detail);
    });
    return response;
  }
  get actualDuration() {
    return this._data.totalRunningTime;
  }
  get expectedDuration() {
    return this._data.totalExpectedRunningTime;
  }
  get targetDuration() {
    if (this._data.totalTargetDuration === void 0)
      return void 0;
    return this._data.totalTargetDuration * 60;
  }
  get durationThreshold() {
    if (this.targetDuration === void 0 || this.actualDuration === void 0)
      return 3 /* Correct */;
    if (this.durationPercentage < 30)
      return 5 /* CriticallyLow */;
    if (this.durationPercentage < 60)
      return 4 /* Low */;
    if (this.durationPercentage < 75)
      return 3 /* Correct */;
    if (this.durationPercentage < 90)
      return 2 /* High */;
    return 1 /* CriticallyHigh */;
  }
  get score() {
    return 0;
  }
  get maximumScore() {
    return 0;
  }
  get percentage() {
    let maximumPercentage = 0;
    let percentage = 0;
    this._reportDetails.forEach((analyser) => {
      if (analyser.isRelevant) {
        maximumPercentage += 100;
        percentage += analyser.percentage;
      }
    });
    return Math.floor(percentage * 100 / maximumPercentage);
  }
  get durationPercentage() {
    if (this.targetDuration === void 0 || this.actualDuration === void 0)
      return 0;
    if (this.actualDuration > this.targetDuration * 2)
      return 0;
    if (this.actualDuration > this.targetDuration) {
      const actualDuration = this.targetDuration - (this.actualDuration - this.targetDuration);
      return Math.floor(actualDuration * 100 / this.targetDuration);
    }
    return Math.floor(this.actualDuration * 100 / this.targetDuration);
  }
  get thresholdType() {
    if (this.percentage < 30)
      return 5 /* CriticallyLow */;
    if (this.percentage < 60)
      return 4 /* Low */;
    if (this.percentage < 75)
      return 3 /* Correct */;
    if (this.percentage < 90)
      return 2 /* High */;
    return 1 /* CriticallyHigh */;
  }
};

// src/analyser/views/AnalyserSceneView.ts
var AnalyserSceneView = class extends AbstractAnalyserView {
  render(report, containerEl) {
    if (!report.isValid)
      return;
    const analyserEl = containerEl.createDiv({ cls: "rpgm-new-analyser" });
    const analyserListEl = analyserEl.createEl("ul");
    const analyserListTimingElementEl = analyserListEl.createEl("li");
    analyserListTimingElementEl.createSpan({ cls: "subtitle", text: "Expected session duration: " + this.transformTime(report.expectedDuration) });
  }
};

// src/analyser/abstracts/AbstractAnalyser.ts
var AbstractAnalyser = class extends AbstractRpgManager {
  constructor(app2, abtStage) {
    super(app2);
    this.isSingleScene = false;
    this.rawData = [];
    this._analyserData = new AnalyserData();
    this._analyserData.abtStage = abtStage;
  }
  get scenesCount() {
    return this.rawData.length;
  }
  set targetDuration(duration2) {
    this._analyserData.totalTargetDuration = duration2;
  }
  render(type, containerEl) {
    const report = new AnalyserReport(this.app, this._analyserData);
    let view = void 0;
    switch (type) {
      case 2 /* Scene */:
        view = new AnalyserSceneView(this.app, this.type);
        break;
      case 1 /* Minimal */:
        view = new AnalyserMinimalView(this.app, this.type);
        break;
      case 0 /* Extended */:
        view = new AnalyserExtendedView(this.app, this.type);
        break;
      default:
        return;
    }
    view.render(report, containerEl);
  }
  ingestData() {
    if (this.rawData.length > 0) {
      this._analyserData.dataLength = this.rawData.length;
      this.rawData.forEach((data) => {
        var _a;
        this._analyserData.totalRunningTime += (_a = data.currentDuration) != null ? _a : 0;
        this._analyserData.addExpectedRunningTime(data.expectedDuration);
        if (data.isExciting)
          this._analyserData.addExpectedExcitmentDuration(data.expectedDuration);
        if (data.isActive)
          this._analyserData.addActiveScene();
        this._analyserData.addSceneType(data.type);
      });
    }
  }
  convertScene(scene) {
    const response = {
      isExciting: false,
      isActive: false,
      expectedDuration: 0
    };
    response.currentDuration = scene.currentDuration;
    response.isExciting = scene.isExciting;
    response.expectedDuration = scene.expectedDuration;
    response.isActive = scene.isActive;
    response.type = scene.sceneType;
    return response;
  }
  addScene(scene) {
    this.rawData.push(this.convertScene(scene));
  }
  addScenesList(scenes) {
    scenes.forEach((scene) => {
      this.addScene(scene);
    });
  }
};

// src/analyser/BuilderAnalyser.ts
var BuilderAnalyser = class extends AbstractAnalyser {
  constructor(app2, dataList, abtStage) {
    super(app2, abtStage);
    this.type = 4 /* Act */;
    this.rawData = dataList;
    super.ingestData();
  }
};

// src/analyser/ActAnalyser.ts
var ActAnalyser = class extends AbstractAnalyser {
  constructor(app2, act, abtStage) {
    super(app2, abtStage);
    this.type = 4 /* Act */;
    const sceneList = this.database.readList(8 /* Scene */, act.id).sort(this.factories.sorter.create([
      new SorterComparisonElement((scene) => scene.id.campaignId),
      new SorterComparisonElement((scene) => scene.id.adventureId),
      new SorterComparisonElement((scene) => scene.id.actId),
      new SorterComparisonElement((scene) => scene.id.sceneId)
    ]));
    super.addScenesList(sceneList);
    super.ingestData();
  }
};

// src/analyser/SessionAnalyser.ts
var SessionAnalyser = class extends AbstractAnalyser {
  constructor(app2, session, abtStage) {
    super(app2, abtStage);
    this.type = 16 /* Session */;
    const singleSession = this.database.readSingle(16 /* Session */, session.id);
    if (singleSession.targetDuration != void 0)
      this.targetDuration = singleSession.targetDuration;
    const sceneList = this.database.read((scene) => {
      var _a;
      return scene.id.type === 8 /* Scene */ && scene.id.campaignId === session.id.campaignId && ((_a = scene.session) == null ? void 0 : _a.id.sessionId) === session.id.sessionId;
    }).sort(this.factories.sorter.create([
      new SorterComparisonElement((scene) => scene.id.campaignId),
      new SorterComparisonElement((scene) => scene.id.adventureId),
      new SorterComparisonElement((scene) => scene.id.actId),
      new SorterComparisonElement((scene) => scene.id.sceneId)
    ]));
    super.addScenesList(sceneList);
    super.ingestData();
  }
};

// src/analyser/SceneAnalyser.ts
var SceneAnalyser = class extends AbstractAnalyser {
  constructor(app2, scene, abtStage) {
    super(app2, abtStage);
    this.isSingleScene = true;
    this.addScene(this.database.readSingle(8 /* Scene */, scene.id));
    super.ingestData();
  }
};

// src/analyser/factories/AnalyserFactory.ts
var AnalyserFactory = class extends AbstractFactory {
  constructor(app2) {
    super(app2);
  }
  createBuilder(data, abtStage = void 0) {
    return new BuilderAnalyser(this.app, data, abtStage);
  }
  createScene(scene, abtStage) {
    return new SceneAnalyser(this.app, scene, abtStage);
  }
  createAct(act, abtStage) {
    return new ActAnalyser(this.app, act, abtStage);
  }
  createSession(session, abtStage) {
    return new SessionAnalyser(this.app, session, abtStage);
  }
};

// src/galleries/data/Image.ts
var Image2 = class {
  constructor(path2, src) {
    this._path = path2;
    this._src = src;
    this._caption = "";
  }
  get path() {
    return this._path;
  }
  get caption() {
    return this._caption;
  }
  set caption(caption) {
    this._caption = caption;
  }
  get src() {
    return this._src;
  }
};

// src/galleries/factories/ImageFactory.ts
var ImageFactory = class extends AbstractFactory {
  create(path2, caption) {
    const imageLocation = this._getImageLocation(path2);
    if (imageLocation === void 0)
      return void 0;
    const response = new Image2(path2, imageLocation);
    if (caption !== void 0)
      response.caption = caption;
    return response;
  }
  _getImageLocation(path2) {
    if (path2.startsWith("http"))
      return path2;
    if (this.app.vault.getAbstractFileByPath(path2) === void 0)
      return void 0;
    if (AbstractComponentData.root === void 0)
      AbstractComponentData.initialiseRoots(this.app);
    return AbstractComponentData.root + path2;
  }
};

// src/views/abstracts/AbstractView.ts
var AbstractView = class extends AbstractRpgManager {
  addSeparator(containerEl) {
    containerEl.createSpan({ cls: "separator", text: " | " });
  }
  addLinkWithFunction(containerEl, text, fn, isLast = false) {
    const containerSpanEl = containerEl.createSpan({ cls: "link" });
    if (isLast)
      containerSpanEl.addClass("clearfix");
    const anchorEl = containerSpanEl.createEl("a", { href: "#", text });
    anchorEl.addEventListener("click", fn.bind(this));
  }
};

// src/galleries/abstracts/AbstractGalleryModalView.ts
var AbstractGalleryModalView = class extends AbstractView {
  get component() {
    return this._component;
  }
  set component(component) {
    this._component = component;
  }
};

// src/galleries/views/modals/GalleryListModalView.ts
var import_obsidian27 = require("obsidian");
var GalleryListModalView = class extends AbstractGalleryModalView {
  render(containerEl) {
    containerEl.empty();
    this._masonryEl = containerEl.createDiv({ cls: "gallery-operations-masonry" });
    this.component.images.forEach((image) => {
      const masonryItemEl = this._masonryEl.createDiv({ cls: "gallery-operations-masonry-item" });
      const imageContainerEl = masonryItemEl.createDiv({ cls: "gallery-operations-masonry-item-container" });
      const imageEl = new Image();
      imageEl.addClass("image");
      imageEl.src = image.src;
      imageContainerEl.append(imageEl);
      const imageCaptionEl = imageContainerEl.createDiv({ cls: "caption" });
      if (image.caption !== "") {
        import_obsidian27.MarkdownRenderer.renderMarkdown(image.caption, imageCaptionEl, "", null);
      }
      imageEl.addEventListener("click", () => {
        const view = this.factories.imageView.create(4 /* ModalEdit */, this.component);
        view.image = image;
        view.render(containerEl);
      });
    });
  }
};

// src/galleries/views/modals/GalleryNavigationModalView.ts
var GalleryNavigationModalView = class extends AbstractGalleryModalView {
  render(containerEl) {
    const navigationEl = containerEl.createDiv({ cls: "gallery-navigation" });
    this._operationsEl = containerEl.createDiv({ cls: "gallery-operations" });
    this.addLinkWithFunction(navigationEl, "Current Images", () => {
      this._loadView(2 /* ModalList */);
    });
    this.addSeparator(navigationEl);
    this.addLinkWithFunction(navigationEl, "Add Local Image", () => {
      this._loadView(3 /* ModalAddLocal */);
    });
    this.addSeparator(navigationEl);
    this.addLinkWithFunction(navigationEl, "Upload Image", () => {
      this._loadView(6 /* ModalUpload */);
    });
    this.addSeparator(navigationEl);
    this.addLinkWithFunction(navigationEl, "Add Online Image", () => {
      this._loadView(5 /* ModalAddRemote */);
    }, true);
    this._loadView(2 /* ModalList */);
  }
  _loadView(type) {
    this._operationsEl.empty();
    const view = this.factories.imageView.create(type, this.component);
    view.render(this._operationsEl);
  }
};

// src/galleries/views/modals/GalleryEditModalView.ts
var GalleryEditModalView = class extends AbstractGalleryModalView {
  set image(image) {
    this._image = image;
    this.component;
  }
  render(containerEl) {
    containerEl.empty();
    const editorDeletedContainerEl = containerEl.createDiv({ cls: "gallery-operations-edit-deleted" });
    editorDeletedContainerEl.createDiv({ text: "The image has been removed from " + this.component.file.basename });
    editorDeletedContainerEl.createDiv({ text: "Click to return to its gallery" });
    editorDeletedContainerEl.addEventListener("click", () => {
      const view = this.factories.imageView.create(2 /* ModalList */, this.component);
      view.render(containerEl);
    });
    const editorContainerEl = containerEl.createDiv({ cls: "gallery-operations-edit" });
    const editorImageContainerEl = editorContainerEl.createDiv({ cls: "gallery-operations-edit-image" });
    const editorEditorContainerEl = editorContainerEl.createDiv({ cls: "gallery-operations-edit-editor clearfix" });
    this._imageEl = new Image();
    this._imageEl.addClass("image");
    this._imageEl.src = this._image.src;
    editorImageContainerEl.append(this._imageEl);
    editorEditorContainerEl.createEl("h3", { text: "Edit Image" });
    editorEditorContainerEl.createEl("label", { text: "Caption" });
    this._captionEl = editorEditorContainerEl.createEl("textarea", { text: this._image.caption });
    editorEditorContainerEl.createEl("button", { text: "Save Caption" }).addEventListener("click", () => {
      this.manipulators.codeblock.addOrUpdateImage(this._image.path, this._captionEl.value);
    });
    editorEditorContainerEl.createEl("button", { cls: "danger", text: "Remove Image from " + this.component.file.basename }).addEventListener("click", () => {
      this.manipulators.codeblock.removeImage(this._image.path).then(() => {
        editorDeletedContainerEl.style.display = "block";
      });
    });
  }
};

// src/galleries/views/modals/abstracts/AbstractConfirmationGalleryModalView.ts
var AbstractConfirmationGalleryModalView = class extends AbstractGalleryModalView {
  render(containerEl) {
    this.containerEl = containerEl;
    this.containerEl.empty();
    this.confirmationOverlayEl = this.containerEl.createDiv({ cls: "gallery-operations-edit-deleted" });
    this.confirmationOverlayEl.createDiv({ text: "The image has been added to " + this.component.file.basename });
    this.confirmationOverlayEl.createDiv({ text: "Click to edit its caption" });
    this.confirmationOverlayEl.addEventListener("click", () => {
      if (this.selectedImage !== void 0) {
        const view = this.factories.imageView.create(4 /* ModalEdit */, this.component);
        view.image = this.selectedImage;
        view.render(this.containerEl);
      } else {
        const view = this.factories.imageView.create(2 /* ModalList */, this.component);
        view.render(containerEl);
      }
    });
  }
};

// src/galleries/views/modals/GalleryAddLocalModalView.ts
var GalleryAddLocalModalView = class extends AbstractConfirmationGalleryModalView {
  render(containerEl) {
    super.render(containerEl);
    this.containerEl.createEl("label", { text: "Search your image" });
    const searchEl = this.containerEl.createEl("input", { type: "text" });
    searchEl.addEventListener("keyup", () => {
      this._populateGrid(searchEl.value);
    });
    this._masonryEl = this.containerEl.createDiv({ cls: "gallery-operations-masonry-x" });
    if (AbstractComponent.root == void 0)
      AbstractComponent.initialiseRoots(this.app);
    this._attachmentFolder = this.settings.imagesFolder !== void 0 && this.settings.imagesFolder !== "" ? this.settings.imagesFolder : this.app.vault.config.attachmentFolderPath;
    if (this._attachmentFolder === void 0)
      return;
    this._attachmentFolder = this._attachmentFolder.toLowerCase();
    const existingImages = [];
    this.component.images.forEach((image) => {
      existingImages.push(image.path);
    });
    this._allImages = this.app.vault.getFiles().filter((file) => file.path.toLowerCase().startsWith(this._attachmentFolder) && !existingImages.contains(file.path));
    this._populateGrid();
  }
  _populateGrid(searchedText) {
    this._masonryEl.empty();
    let images = this._allImages;
    if (searchedText !== void 0)
      images = this._allImages.filter((image) => image.path.toLowerCase().indexOf(searchedText.toLowerCase()) !== -1);
    images.forEach((image) => {
      const imageEl = new Image();
      imageEl.addClass("image");
      imageEl.src = AbstractComponent.root + image.path;
      imageEl.dataset.id = image.path;
      imageEl.addEventListener("click", () => {
        if (imageEl.dataset.id !== void 0) {
          this.manipulators.codeblock.addOrUpdateImage(imageEl.dataset.id, "").then((image2) => {
            if (image2 !== void 0) {
              this.selectedImage = image2;
              this.confirmationOverlayEl.style.display = "block";
            }
          });
        }
      });
      this._masonryEl.append(imageEl);
    });
  }
};

// src/galleries/views/modals/GalleryAddRemoteModalView.ts
var GalleryAddRemoteModalView = class extends AbstractConfirmationGalleryModalView {
  render(containerEl) {
    super.render(containerEl);
    this.containerEl.createEl("label", { text: "Add the URL of the online image" });
    this._urlEl = this.containerEl.createEl("input", { type: "text" });
    this._addButtonEl = this.containerEl.createEl("button", { text: "Add image" });
    this._addButtonEl.disabled = true;
    this._errorEl = this.containerEl.createDiv({ cls: "error" });
    this._imageContainerEl = this.containerEl.createDiv({ cls: "image-container" });
    this._urlEl.addEventListener("paste", this._showPreview.bind(this));
    this._urlEl.addEventListener("keyup", this._showPreview.bind(this));
    this._addButtonEl.addEventListener("click", () => {
      const imageEl = new Image();
      for (let index = 0; index < this.component.images.length; index++) {
        if (this._urlEl.value.toLowerCase() === this.component.images[index].src.toLowerCase()) {
          this._errorEl.style.display = "";
          this._errorEl.textContent = "The URL to the image is invalid.";
          return;
        }
      }
      imageEl.onerror = (evt) => {
        this._errorEl.style.display = "";
        this._errorEl.textContent = "The URL to the image is invalid.";
        return;
      };
      imageEl.onload = (evt) => {
        this.manipulators.codeblock.addOrUpdateImage(this._urlEl.value.toLowerCase(), "").then((image) => {
          if (image !== void 0) {
            this.selectedImage = image;
            this.confirmationOverlayEl.style.display = "block";
          }
        });
      };
      imageEl.src = this._urlEl.value;
    });
  }
  _showPreview() {
    const imageEl = new Image();
    imageEl.onerror = (evt) => {
      this._errorEl.style.display = "";
      this._addButtonEl.disabled = true;
      return;
    };
    imageEl.onload = (evt) => {
      this._imageContainerEl.empty();
      this._imageContainerEl.append(imageEl);
      this._addButtonEl.disabled = false;
    };
    imageEl.src = this._urlEl.value;
  }
};

// src/galleries/views/modals/GalleryUploadModalView.ts
var import_obsidian28 = require("obsidian");
var fs = require("fs");
var GalleryUploadModalView = class extends AbstractConfirmationGalleryModalView {
  render(containerEl) {
    super.render(containerEl);
    this._dropZoneEl = this.containerEl.createDiv({ cls: "dropzone" });
    this._dropZoneEl.createDiv();
    (0, import_obsidian28.setIcon)(this._dropZoneEl, "download");
    this._dropZoneEl.createDiv({ text: "Drag and drop your image here to add it to your Vault" });
    if (this._isAdvancedUpload()) {
      this._dropZoneEl.ondrag = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondragstart = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondragend = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondragover = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondragenter = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondragleave = (e) => {
        this._onDrag(e);
      };
      this._dropZoneEl.ondrop = (e) => {
        this._onDrag(e);
        if (e.dataTransfer != null) {
          for (let index = 0; index < e.dataTransfer.files.length; index++) {
            const file = e.dataTransfer.files[index];
            const folder = this.settings.imagesFolder !== void 0 && this.settings.imagesFolder !== "" ? this.settings.imagesFolder : this.app.vault.config.attachmentFolderPath;
            let fileName = file.name;
            let fileIndex = 0;
            while (this.app.vault.getAbstractFileByPath(folder + "/" + fileName) != void 0) {
              const indexOfExtension = fileName.lastIndexOf(".");
              const name = fileName.substring(0, indexOfExtension);
              const extension = fileName.substring(indexOfExtension);
              fileIndex++;
              fileName = name + "_" + fileIndex.toString() + extension;
            }
            const path2 = this.app.vault.adapter.basePath + "/" + folder + "/" + fileName;
            const originalFilePath = file["path"];
            fs.copyFile(originalFilePath, path2, (err) => {
              if (err)
                throw err;
              this.manipulators.codeblock.addOrUpdateImage(folder + "/" + fileName, "").then((image) => {
                if (image !== void 0) {
                  this.selectedImage = image;
                  this.confirmationOverlayEl.style.display = "block";
                }
              });
            });
          }
        }
      };
    }
  }
  _onDrag(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  _isAdvancedUpload() {
    return ("draggable" in this._dropZoneEl || "ondragstart" in this._dropZoneEl && "ondrop" in this._dropZoneEl) && "FormData" in window && "FileReader" in window;
  }
};

// src/galleries/factories/GalleryViewFactory.ts
var GalleryViewFactory = class extends AbstractFactory {
  constructor() {
    super(...arguments);
    this._views = /* @__PURE__ */ new Map([
      [1 /* ModalNavigation */, GalleryNavigationModalView],
      [2 /* ModalList */, GalleryListModalView],
      [4 /* ModalEdit */, GalleryEditModalView],
      [3 /* ModalAddLocal */, GalleryAddLocalModalView],
      [5 /* ModalAddRemote */, GalleryAddRemoteModalView],
      [6 /* ModalUpload */, GalleryUploadModalView]
    ]);
  }
  create(type, component) {
    const view = this._views.get(type);
    if (view === void 0)
      throw new Error("");
    const response = new view(this.app);
    response.component = component;
    return response;
  }
};

// src/factories/Factories.ts
var Factories = class {
  constructor(_app) {
    this._app = _app;
    this.subModels = new SubModelFactory(this._app);
    this.contents = new ContentFactory(this._app);
    this.component = new ComponentFactory(this._app);
    this.files = new FileFactory(this._app);
    this.modals = new ModalFactory(this._app);
    this.models = new ModelFactory(this._app);
    this.pronouns = new PronounFactory(this._app);
    this.templates = new TemplateFactory(this._app);
    this.views = new ViewFactory(this._app);
    this.fetchers = new FetcherFactory(this._app);
    this.database = new DatabaseFactory(this._app);
    this.id = new IdFactory(this._app);
    this.breadcrumb = new BreadcrumbFactory(this._app);
    this.sorter = new SorterFactory(this._app);
    this.componentType = new ComponentTypeFactory(this._app);
    this.relationshipType = new RelationshipTypeFactory(this._app);
    this.sceneType = new SceneTypeFactory(this._app);
    this.storyCircleStage = new StoryCircleStageFactory(this._app);
    this.abtStage = new AbtStageFactory(this._app);
    this.relationship = new RelationshipFactory(this._app);
    this.logger = new LogFactory(this._app, 1 /* Console */);
    this.fileManipulator = new FileManipulatorFactory(this._app);
    this.analyser = new AnalyserFactory(this._app);
    this.image = new ImageFactory(this._app);
    this.imageView = new GalleryViewFactory(this._app);
    this.runningTimeManager = new RunningTimeManager(this._app);
  }
};

// src/modals/CreationModal.ts
var import_obsidian29 = require("obsidian");
var CreationModal = class extends AbstractRpgManagerModal {
  constructor(app2, type, _create = true, _name = null, campaignId = void 0, adventureId = void 0, actId = void 0) {
    super(app2);
    this.app = app2;
    this.type = type;
    this._create = _create;
    this._name = _name;
    this.campaignSetting = 0 /* Agnostic */;
    this.availableSpecificTemplates = [];
    this.availableGenericTemplates = [];
    if (campaignId !== void 0) {
      const campaign = this.factories.id.create(1 /* Campaign */, campaignId);
      if (campaign !== void 0) {
        this.campaignId = campaign;
        if (adventureId !== void 0) {
          this.adventureId = this.factories.id.create(2 /* Adventure */, campaignId, adventureId);
          if (actId !== void 0)
            this.actId = this.factories.id.create(4 /* Act */, campaignId, adventureId, actId);
        }
      }
    }
    this.app.vault.getFiles().filter((file) => file.parent.path === this.app.plugins.getPlugin("rpg-manager").settings.templateFolder).forEach((file) => {
      var _a, _b;
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata != null) {
        const tags = this.tagHelper.sanitiseTags((_a = metadata.frontmatter) == null ? void 0 : _a.tags);
        if (tags.length > 0) {
          const tags2 = this.tagHelper.sanitiseTags((_b = metadata.frontmatter) == null ? void 0 : _b.tags);
          const templateType = this.tagHelper.getTemplateDataType(tags2);
          if (templateType == void 0)
            this.availableGenericTemplates.push(file);
          if (templateType === this.type)
            this.availableSpecificTemplates.push(file);
        } else {
          this.availableGenericTemplates.push(file);
        }
      }
    });
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rpgm-modal");
    if (!this._create && this.app.workspace.getActiveViewOfType(import_obsidian29.MarkdownView) == null) {
      contentEl.createEl("h2", { cls: "rpgm-modal-title", text: "Error" });
      contentEl.createSpan({ cls: "", text: "To fill a note with a RPG Manager element you must have a valid file opened." });
      return;
    }
    contentEl.createEl("h2", { cls: "rpgm-modal-title", text: "Create New " + ComponentType[this.type] });
    const gridEl = contentEl.createDiv({ cls: "rpgm-grid" });
    const navigationEl = gridEl.createDiv({ cls: "navigation" });
    this.additionalInformationEl = gridEl.createDiv({ cls: "additionalElements" });
    const titleEl = navigationEl.createDiv({ cls: "rpgm-input-title" });
    titleEl.createEl("label", { text: "Title of your new " + ComponentType[this.type] });
    this.title = titleEl.createEl("input", { type: "text" });
    if (this._name !== null) {
      this.title.value = this._name;
    }
    this.titleError = navigationEl.createEl("p", { cls: "error", text: "Please specify a valid title" });
    const selectionTitleEl = navigationEl.createDiv({ cls: "rpgm-input-title" });
    selectionTitleEl.createEl("label", { text: "Template to use" });
    this.templateEl = selectionTitleEl.createEl("select");
    this.templateEl.createEl("option", {
      text: "",
      value: ""
    });
    this.templateEl.createEl("option", {
      text: "RpgManager default " + ComponentType[this.type] + " template",
      value: "internal" + ComponentType[this.type]
    }).selected = true;
    this.templateEl.createEl("option", {
      text: "",
      value: ""
    });
    if (this.availableSpecificTemplates.length > 0) {
      const templateOptionEl = this.templateEl.createEl("option", {
        text: ComponentType[this.type] + "-specific frontmatter"
      });
      templateOptionEl.disabled = true;
      this.availableSpecificTemplates.forEach((file) => {
        this.templateEl.createEl("option", {
          text: file.basename,
          value: file.path
        });
      });
      this.templateEl.createEl("option", {
        text: "",
        value: ""
      });
    }
    if (this.availableGenericTemplates.length > 0) {
      const templateOptionEl = this.templateEl.createEl("option", {
        text: "Generic frontmatter"
      });
      templateOptionEl.disabled = true;
      this.availableGenericTemplates.forEach((file) => {
        this.templateEl.createEl("option", {
          text: file.basename,
          value: file.path
        });
      });
    }
    this.campaignModal = this.factories.modals.create(this.campaignSetting, 1 /* Campaign */, this);
    const childElement = navigationEl.createDiv();
    this.button = contentEl.createEl("button", { cls: "mod-cta", text: "Create" });
    if (this.type !== 1 /* Campaign */) {
      this.button.disabled = true;
    }
    this.button.addEventListener("click", (e) => {
      this._save();
    });
    this.campaignModal.addElement(childElement);
    titleEl.addEventListener("keypress", function(event) {
      if (event.key === "Enter")
        this.button.click();
    }.bind(this));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
  _save() {
    return __async(this, null, function* () {
      if (this.title.value === "") {
        this.titleError.style.display = "block";
        return;
      }
      if (!this.campaignModal.validate())
        return;
      if (this.adventureModal != null && !this.adventureModal.validate())
        return;
      if (this.actModal != null && !this.actModal.validate())
        return;
      if (this.sceneModal != null && !this.sceneModal.validate())
        return;
      if (this.sessionModal != null && !this.sessionModal.validate())
        return;
      if (this.elementModal != null && !this.elementModal.validate())
        return;
      this.saver.save(this.campaignSetting, this.type, this._create, this.templateEl.value, this.title.value, this.campaignId, this.adventureId, this.actId, this.sceneId, this.sessionId, this.saver.prepareAdditionalInformation());
      this.close();
    });
  }
  enableButton() {
    this.button.disabled = false;
  }
  getContentEl() {
    const { contentEl } = this;
    return contentEl;
  }
};

// src/settings/RpgManagerSettingsInterface.ts
var rpgManagerDefaultSettings = {
  automaticMove: true,
  templateFolder: "",
  imagesFolder: "",
  YouTubeKey: "",
  previousVersion: "",
  usePlotStructures: false,
  useSceneAnalyser: false,
  advanced: {
    Agnostic: {
      ActList: {
        title: "Acts",
        defaultVisible: true,
        fields: [
          { field: 0 /* Index */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      AdventureList: {
        title: "Adventures",
        defaultVisible: true,
        fields: [
          { field: 0 /* Index */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      CharacterList: {
        title: "Player Characters",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 3 /* Age */, checked: true, required: false },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      ClueList: {
        title: "Clues",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 5 /* Found */, checked: true, required: false },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      EventList: {
        title: "Events",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: false, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 6 /* Date */, checked: true, required: false },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      FactionList: {
        title: "Factions",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: false, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      LocationList: {
        title: "Locations",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      MusicList: {
        title: "Musics",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 7 /* Url */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      NonPlayerCharacterList: {
        title: "Non Player Characters",
        defaultVisible: true,
        fields: [
          { field: 1 /* Image */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 3 /* Age */, checked: true, required: false },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      SceneList: {
        title: "Scenes",
        defaultVisible: true,
        fields: [
          { field: 0 /* Index */, checked: true, required: false },
          { field: 8 /* StoryCircleIndicator */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false },
          { field: 6 /* Date */, checked: true, required: false },
          { field: 11 /* Duration */, checked: false, required: false },
          { field: 12 /* SceneType */, checked: false, required: false },
          { field: 13 /* SceneExciting */, checked: false, required: false }
        ]
      },
      SessionList: {
        title: "Sessions",
        defaultVisible: true,
        fields: [
          { field: 0 /* Index */, checked: true, required: false },
          { field: 2 /* Name */, checked: true, required: true },
          { field: 6 /* Date */, checked: true, required: false },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      },
      SubplotList: {
        title: "Subplots",
        defaultVisible: false,
        fields: [
          { field: 2 /* Name */, checked: true, required: true },
          { field: 4 /* Synopsis */, checked: true, required: false }
        ]
      }
    }
  }
};

// src/settings/RpgManagerSettings.ts
var import_obsidian31 = require("obsidian");

// src/settings/SettingsUpdater.ts
var SettingsUpdater = class extends AbstractRpgManager {
  updateTags(updatedTags) {
    return __async(this, null, function* () {
      this.factories.logger.info(32 /* TagUpdates */, "Collecting files");
      const files = yield this.app.vault.getMarkdownFiles();
      for (let index = 0; index < files.length; index++) {
        const content = yield this.app.vault.read(files[index]);
        this.factories.logger.info(32 /* TagUpdates */, "Reading file contents", files[index]);
        let newFileContent = content;
        yield updatedTags.forEach((newTag, oldTag) => {
          newFileContent = newFileContent.replaceAll(oldTag, newTag);
        });
        this.factories.logger.info(32 /* TagUpdates */, "Tags Updated", files[index]);
        if (newFileContent !== content) {
          yield this.app.vault.modify(files[index], newFileContent);
          this.factories.logger.info(32 /* TagUpdates */, "File updated", files[index]);
        }
      }
      this.factories.logger.info(32 /* TagUpdates */, "Re-initialising databases");
      return yield DatabaseInitialiser.initialise(this.app).then((database) => {
        this.database = database;
        this.factories.logger.info(32 /* TagUpdates */, "Database re-initialised");
        this.app.workspace.trigger("rpgmanager:refresh-views");
        return;
      });
    });
  }
};

// src/settings/factories/SettingsFactory.ts
var import_obsidian30 = require("obsidian");
var SettingsFactory = class {
  constructor(_app, _plugin, _map, _containerEl) {
    this._app = _app;
    this._plugin = _plugin;
    this._map = _map;
    this._containerEl = _containerEl;
  }
  _generateFragment(text) {
    const lines = text.split("\n");
    return createFragment((fragment) => {
      lines.forEach((content) => {
        fragment.appendText(content);
        fragment.createEl("br");
      });
      fragment.appendText(" ");
    });
  }
  createHeader(text, level = 2, additionalText = void 0) {
    const elementType = "h" + level.toString();
    this._containerEl.createEl(elementType, { text });
    if (additionalText !== void 0) {
      this._containerEl.createEl("span", { text: this._generateFragment(additionalText) });
    }
  }
  createWarning(text) {
    this._containerEl.createEl("p", { text }).style.color = "var(--text-error)";
  }
  createTextSetting(type, description = "") {
    const settings = this._map.get(type);
    if (settings === void 0)
      throw new Error("Setting type not found");
    return new import_obsidian30.Setting(this._containerEl).setName(settings.title).setDesc(this._generateFragment(description)).addText((text) => {
      var _a;
      return text.setPlaceholder((_a = settings.placeholder) != null ? _a : "").setValue(settings.value).onChange((value) => {
        settings.value = value;
      });
    });
  }
  createDropdownSetting(type, description, options) {
    const settings = this._map.get(type);
    if (settings === void 0)
      throw new Error("Setting type not found");
    return new import_obsidian30.Setting(this._containerEl).setName(settings.title).setDesc(this._generateFragment(description)).addDropdown((dropdown) => {
      dropdown.addOption("", "");
      options.forEach((value, display) => {
        dropdown.addOption(value, display);
      });
      dropdown.setValue(settings.value);
      dropdown.onChange((value) => __async(this, null, function* () {
        switch (type) {
          case 13 /* templateFolder */:
            yield this._plugin.updateSettings({ templateFolder: value });
            settings.value = value;
            break;
          case 18 /* imagesFolder */:
            yield this._plugin.updateSettings({ imagesFolder: value });
            settings.value = value;
            break;
        }
      }));
    });
  }
  createToggleSetting(type, description) {
    const settings = this._map.get(type);
    if (settings === void 0)
      throw new Error("Setting type not found");
    return new import_obsidian30.Setting(this._containerEl).setName(settings.title).setDesc(this._generateFragment(description)).addToggle((toggle) => toggle.setValue(settings.value).onChange((value) => __async(this, null, function* () {
      switch (type) {
        case 11 /* automaticMove */:
          yield this._plugin.updateSettings({ automaticMove: value });
          settings.value = value;
          break;
        case 16 /* usePlotStructures */:
          yield this._plugin.updateSettings({ usePlotStructures: value });
          settings.value = value;
          break;
        case 17 /* useSceneAnalyser */:
          yield this._plugin.updateSettings({ useSceneAnalyser: value });
          settings.value = value;
          break;
      }
      this._app.workspace.trigger("rpgmanager:force-refresh-views");
    })));
  }
};

// src/settings/RpgManagerSettings.ts
var RpgManagerSettings = class extends import_obsidian31.PluginSettingTab {
  constructor(app2) {
    super(app2, app2.plugins.getPlugin("rpg-manager"));
    this._advancedSettingsDescription = /* @__PURE__ */ new Map();
    this._plugin = app2.plugins.getPlugin("rpg-manager");
    const { containerEl } = this;
    this.containerEl = containerEl;
    this._map = /* @__PURE__ */ new Map();
    this._map.set(12 /* YouTubeApiKey */, { title: "YouTube API Key", value: this._plugin.settings.YouTubeKey, placeholder: "Your YouTube API Key" });
    this._map.set(11 /* automaticMove */, { title: "Automatically organise elements in folders", value: this._plugin.settings.automaticMove, placeholder: "Organise new elements" });
    this._map.set(13 /* templateFolder */, { title: "Template folder", value: this._plugin.settings.templateFolder, placeholder: "Template Folder" });
    this._map.set(18 /* imagesFolder */, { title: "Images folder", value: this._plugin.settings.imagesFolder, placeholder: "Images Folder" });
    this._map.set(16 /* usePlotStructures */, { title: "Abt/Story Circle plot structure", value: this._plugin.settings.usePlotStructures, placeholder: "" });
    this._map.set(17 /* useSceneAnalyser */, { title: "Scene Analyser", value: this._plugin.settings.useSceneAnalyser, placeholder: "" });
    this._advancedSettingsDescription.set("ActList", { title: "Act List", description: "Select which fields you would like to see when displaying a list of Acts" });
    this._advancedSettingsDescription.set("AdventureList", { title: "Adventure List", description: "Select which fields you would like to see when displaying a list of Adventures" });
    this._advancedSettingsDescription.set("CharacterList", { title: "Player Character List", description: "Select which fields you would like to see when displaying a list of Player characters" });
    this._advancedSettingsDescription.set("ClueList", { title: "Clue List", description: "Select which fields you would like to see when displaying a list of Clues" });
    this._advancedSettingsDescription.set("EventList", { title: "Event List", description: "Select which fields you would like to see when displaying a list of Events" });
    this._advancedSettingsDescription.set("FactionList", { title: "Faction List", description: "Select which fields you would like to see when displaying a list of Factions" });
    this._advancedSettingsDescription.set("LocationList", { title: "Location List", description: "Select which fields you would like to see when displaying a list of Locations" });
    this._advancedSettingsDescription.set("MusicList", { title: "Music List", description: "Select which fields you would like to see when displaying a list of Musics" });
    this._advancedSettingsDescription.set("NonPlayerCharacterList", { title: "Non Player Character List", description: "Select which fields you would like to see when displaying a list of Non Player Characters" });
    this._advancedSettingsDescription.set("SceneList", { title: "Scene List", description: "Select which fields you would like to see when displaying a list of Scenes" });
    this._advancedSettingsDescription.set("SessionList", { title: "Session List", description: "Select which fields you would like to see when displaying a list of Sessions" });
    this._advancedSettingsDescription.set("SubplotList", { title: "Subplot List", description: "Select which fields you would like to see when displaying a list of Subplots" });
    this._settingsUpdater = new SettingsUpdater(this.app);
    this._settingsFactory = new SettingsFactory(this.app, this._plugin, this._map, this.containerEl);
  }
  display() {
    this.containerEl.empty();
    this._createFolderMap();
    this._settingsFactory.createHeader("CampaignSetting for Role Playing Game Manager");
    this._loadTemplatesSettings();
    this._loadImagesSettings();
    this._loadExternalServicesSettings();
    this._loadAdvancedSettings();
  }
  _loadExternalServicesSettings() {
    this._settingsFactory.createHeader("External Services", 3);
    this._settingsFactory.createWarning(`Configurations are saved in a file in your vault. If you share your vault, you share your key!`);
    this._settingsFactory.createTextSetting(12 /* YouTubeApiKey */, `Used to access YouTube-specific information`);
  }
  _loadTemplatesSettings() {
    this._settingsFactory.createHeader("Component creations", 3, "Manage how new subModels are created");
    this._settingsFactory.createDropdownSetting(13 /* templateFolder */, `Select the folder in which you keep the templates for RPG Manager.`, this._folderMap);
    this._settingsFactory.createToggleSetting(11 /* automaticMove */, `Keeps your structure organised by creating subfolders for your Outlines and Elements`);
    this._settingsFactory.createToggleSetting(16 /* usePlotStructures */, `Use ABT/Story Circle plot structures`);
    this._settingsFactory.createToggleSetting(17 /* useSceneAnalyser */, `Analyses the scenes inside acts or sessions to provide running time estimations and act or session balance`);
  }
  _loadImagesSettings() {
    this._settingsFactory.createHeader("Images Management", 3, "Manage where you store the galleries for all your campaigns");
    this._settingsFactory.createDropdownSetting(18 /* imagesFolder */, `Select the folder in which you keep the images for RPG Manager. Leave it empty if you want to use the default Obsidian Attachment folder. RPG Manager scans every subfolder in the one you selected`, this._folderMap);
  }
  _createFolderMap(parent = void 0, indent = 0) {
    let folderList = [];
    if (parent != void 0) {
      folderList = parent.children.filter((file) => file instanceof import_obsidian31.TFolder);
    } else {
      this._folderMap = /* @__PURE__ */ new Map();
      folderList = this.app.vault.getRoot().children.filter((file) => file instanceof import_obsidian31.TFolder);
    }
    folderList.forEach((folder) => {
      this._folderMap.set(folder.path, folder.path);
      this._createFolderMap(folder, indent + 1);
    });
  }
  _loadAdvancedSettings() {
    this._settingsFactory.createHeader("Lists", 3);
    Object.keys(this._plugin.settings.advanced.Agnostic).forEach((name, index) => {
      const advancedSetting = this._plugin.settings.advanced.Agnostic[name];
      this._addSettingsItem(name, advancedSetting);
    });
  }
  _addSettingsItem(type, settings) {
    var _a, _b, _c, _d, _e;
    const settingItemEl = this.containerEl.createDiv({ cls: "setting-item" });
    const settingItemInfoEl = settingItemEl.createDiv({ cls: "setting-item-info" });
    settingItemInfoEl.createDiv({ cls: "setting-item-name", text: (_b = (_a = this._advancedSettingsDescription.get(type)) == null ? void 0 : _a.title) != null ? _b : "" });
    settingItemInfoEl.createDiv({ cls: "setting-item-description", text: (_d = (_c = this._advancedSettingsDescription.get(type)) == null ? void 0 : _c.description) != null ? _d : "" }).createEl("br");
    const settingItemControlEl = settingItemEl.createDiv({ cls: "setting-item-control" });
    const listSettingTableEl = settingItemControlEl.createEl("table", { cls: "rpgm-advanced-settings-table" });
    const defaultSettings = rpgManagerDefaultSettings.advanced.Agnostic[type];
    for (let index = 0; index < defaultSettings.fields.length; index++) {
      const listSettingTableRowEl = listSettingTableEl.createEl("tr");
      listSettingTableRowEl.createEl("td", { text: (_e = tableFieldName.get(defaultSettings.fields[index].field)) != null ? _e : "" });
      const listSettingTableCheckboxEl = listSettingTableRowEl.createEl("td");
      const listSettingFieldCheckboxEl = listSettingTableCheckboxEl.createEl("input");
      listSettingFieldCheckboxEl.type = "checkbox";
      listSettingFieldCheckboxEl.dataset.id = index.toString();
      let isChecked = defaultSettings.fields[index].checked;
      for (let actualSettingsIndex = 0; actualSettingsIndex < settings.fields.length; actualSettingsIndex++) {
        if (settings.fields[actualSettingsIndex].field === defaultSettings.fields[index].field) {
          isChecked = settings.fields[actualSettingsIndex].checked;
          break;
        }
      }
      if (isChecked)
        listSettingFieldCheckboxEl.checked = true;
      if (defaultSettings.fields[index].required)
        listSettingFieldCheckboxEl.disabled = true;
      listSettingFieldCheckboxEl.addEventListener("change", () => {
        this._updateAdvancedListSettings(index, type, listSettingFieldCheckboxEl.checked);
      });
    }
  }
  _updateAdvancedListSettings(index, type, checked) {
    return __async(this, null, function* () {
      const name = type;
      const partialSettings = {
        advanced: {
          Agnostic: this._plugin.settings.advanced.Agnostic
        }
      };
      if (partialSettings.advanced !== void 0) {
        for (let defaultIndex = 0; defaultIndex < rpgManagerDefaultSettings.advanced.Agnostic[name].fields.length; defaultIndex++) {
          if (partialSettings.advanced.Agnostic[name].fields[defaultIndex] === void 0) {
            partialSettings.advanced.Agnostic[name].fields.push(rpgManagerDefaultSettings.advanced.Agnostic[name].fields[defaultIndex]);
          }
        }
        partialSettings.advanced.Agnostic[name].fields[index].checked = checked;
        yield this._plugin.updateSettings(partialSettings);
      }
      this.app.workspace.trigger("rpgmanager:refresh-views");
    });
  }
};

// src/views/ErrorView.ts
var import_obsidian33 = require("obsidian");

// src/abstracts/AbstractRpgManagerView.ts
var import_obsidian32 = require("obsidian");

// node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = mac || chrome && +chrome[1] < 57;
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;

// src/abstracts/AbstractRpgManagerView.ts
var AbstractRpgManagerView = class extends import_obsidian32.ItemView {
  constructor(app2, leaf) {
    super(leaf);
    this.app = app2;
  }
  get pluginVersion() {
    return this.app.plugins.getPlugin("rpg-manager").version;
  }
  get settings() {
    return this.app.plugins.getPlugin("rpg-manager").settings;
  }
  get database() {
    return this.app.plugins.getPlugin("rpg-manager").database;
  }
  get factories() {
    return this.app.plugins.getPlugin("rpg-manager").factories;
  }
  get manipulators() {
    return this.app.plugins.getPlugin("rpg-manager").manipulators;
  }
  get tagHelper() {
    return this.app.plugins.getPlugin("rpg-manager").tagHelper;
  }
  updateSettings(settings, partial = true) {
    return this.app.plugins.getPlugin("rpg-manager").updateSettings(settings, partial);
  }
  initialise(params) {
    this.onOpenOrResize();
  }
  getViewType() {
    return this.viewType;
  }
  getDisplayText() {
    return this.displayText;
  }
  onOpen() {
    return __async(this, null, function* () {
      this.onOpenOrResize();
    });
  }
  onOpenOrResize() {
    return __async(this, null, function* () {
      const container = this.containerEl.children[1];
      container.empty();
      this.rpgmContentEl = container.createDiv({ cls: "rpgm-view" });
      this.rpgmContentEl.createEl("h2", { text: this.displayText });
    });
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
  updateInternalLinks(element) {
    if (element.children.length > 0) {
      for (let index = 0; index < element.children.length; index++) {
        const elementChild = element.children.item(index);
        if (elementChild !== null) {
          if (elementChild instanceof HTMLAnchorElement) {
            this.updateInternalLink(elementChild);
          } else {
            this.updateInternalLinks(elementChild);
          }
        }
      }
    }
  }
  updateInternalLink(element) {
    const basename = element.dataset.href;
    if (base == void 0)
      return;
    const component = this.database.read((data) => data.file.basename === basename)[0];
    if (component === void 0)
      return;
    const file = component.file;
    element.addEventListener("click", (ev) => {
      ev.preventDefault();
      this.app.workspace.getLeaf(true).openFile(file);
    });
    element.href = "#";
  }
};

// src/views/ErrorView.ts
var ErrorView = class extends AbstractRpgManagerView {
  constructor() {
    super(...arguments);
    this.viewType = "rpgm-error-view" /* Errors */.toString();
    this.displayText = "RPG Manager Errors";
    this.icon = "d20";
    this._errors = /* @__PURE__ */ new Map();
  }
  initialise(params) {
    this._errors = params[0];
  }
  render() {
    return __async(this, null, function* () {
      if (this._errors !== void 0 && this._errors.size > 0) {
        this._errors.forEach((error, file) => {
          const errorEl = this.rpgmContentEl.createEl("div");
          const errorTitle = error.getErrorTitle();
          let title;
          if (errorTitle !== void 0) {
            title = errorEl.createEl("span");
            title.textContent = errorTitle;
          } else {
            title = errorEl.createEl("a");
            this._addLink(title, file.path);
          }
          title.style.fontWeight = "bold";
          const errorDescriptionEl = errorEl.createEl("div");
          import_obsidian33.MarkdownRenderer.renderMarkdown(error.showErrorActions(), errorDescriptionEl, file.path, null);
          const errorLinksEl = errorDescriptionEl.createEl("ul");
          const errorLinkEl = errorLinksEl.createEl("li");
          const errorLinkAnchorEl = errorLinkEl.createEl("a", { href: "#", text: "Fix the issue" });
          errorLinkAnchorEl.addEventListener("click", () => {
            new IdSwitcherModal(this.app, file).open();
          });
        });
      }
      const closeButtonEl = this.contentEl.createEl("button", { text: "Close" });
      closeButtonEl.addEventListener("click", () => {
        this.app.workspace.detachLeavesOfType("rpgm-error-view" /* Errors */.toString());
      });
    });
  }
  _addLink(contentEl, linkOrFile) {
    let file;
    if (linkOrFile instanceof import_obsidian33.TFile) {
      file = linkOrFile;
      linkOrFile = file.basename;
    } else {
      file = this.app.vault.getAbstractFileByPath(linkOrFile);
    }
    if (file != null) {
      contentEl.textContent = file.basename;
      contentEl.style.textDecoration = "underlined";
      contentEl.addEventListener("click", () => {
        this.app.workspace.getLeaf(false).openFile(file);
      });
    }
  }
};

// src/updaters/abstracts/AbstractDatabaseWorker.ts
var AbstractDatabaseWorker = class extends AbstractRpgManager {
};

// src/updaters/workers/V1_2_to_1_3_worker.ts
var V1_2_to_1_3_worker = class extends AbstractDatabaseWorker {
  run(reporter = void 0) {
    return __async(this, null, function* () {
      return;
    });
  }
};

// src/updaters/workers/V1_3_to_2_0_worker.ts
var import_obsidian34 = require("obsidian");

// src/databases/TagHelper.ts
var _TagHelper = class {
  constructor(_settings) {
    this._settings = _settings;
    this.dataSettings = /* @__PURE__ */ new Map();
    this.dataSettings.set(1 /* Campaign */, _TagHelper.campaignTag);
    this.dataSettings.set(2 /* Adventure */, _TagHelper.adventureTag);
    this.dataSettings.set(4 /* Act */, _TagHelper.actTag);
    this.dataSettings.set(8 /* Scene */, _TagHelper.sceneTag);
    this.dataSettings.set(16 /* Session */, _TagHelper.sessionTag);
    this.dataSettings.set(32 /* Character */, _TagHelper.pcTag);
    this.dataSettings.set(512 /* Clue */, _TagHelper.clueTag);
    this.dataSettings.set(256 /* Event */, _TagHelper.eventTag);
    this.dataSettings.set(1024 /* Faction */, _TagHelper.factionTag);
    this.dataSettings.set(128 /* Location */, _TagHelper.locationTag);
    this.dataSettings.set(64 /* NonPlayerCharacter */, _TagHelper.npcTag);
    this.dataSettings.set(2048 /* Music */, _TagHelper.musicTag);
    this.dataSettings.set(4096 /* Subplot */, _TagHelper.subplotTag);
    this._requiredIds = /* @__PURE__ */ new Map();
    this._requiredIds.set(1 /* Campaign */, [1 /* Campaign */]);
    this._requiredIds.set(2 /* Adventure */, [1 /* Campaign */]);
    this._requiredIds.set(4 /* Act */, [1 /* Campaign */, 2 /* Adventure */]);
    this._requiredIds.set(8 /* Scene */, [1 /* Campaign */, 2 /* Adventure */, 4 /* Act */, 8 /* Scene */]);
    this._requiredIds.set(16 /* Session */, [1 /* Campaign */, 16 /* Session */]);
    this._requiredIds.set(32 /* Character */, [1 /* Campaign */]);
    this._requiredIds.set(512 /* Clue */, [1 /* Campaign */]);
    this._requiredIds.set(256 /* Event */, [1 /* Campaign */]);
    this._requiredIds.set(1024 /* Faction */, [1 /* Campaign */]);
    this._requiredIds.set(128 /* Location */, [1 /* Campaign */]);
    this._requiredIds.set(64 /* NonPlayerCharacter */, [1 /* Campaign */]);
    this._requiredIds.set(2048 /* Music */, [2048 /* Music */]);
    this._requiredIds.set(4096 /* Subplot */, [4096 /* Subplot */]);
  }
  sanitiseTags(tags) {
    if (tags == null)
      return [];
    let temporaryResponse = [];
    if (typeof tags === "string") {
      temporaryResponse = tags.split(",");
      temporaryResponse.forEach((tag) => {
        tag = tag.replaceAll(" ", "").replaceAll("#", "");
      });
    } else {
      temporaryResponse = tags;
    }
    const response = [];
    temporaryResponse.forEach((tag) => {
      if (tag != null)
        response.push(tag);
    });
    return response;
  }
  getDataType(tag) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (tag.startsWith((_a = this.dataSettings.get(1 /* Campaign */)) != null ? _a : "?"))
      return 1 /* Campaign */;
    if (tag.startsWith((_b = this.dataSettings.get(2 /* Adventure */)) != null ? _b : "?"))
      return 2 /* Adventure */;
    if (tag.startsWith((_c = this.dataSettings.get(4 /* Act */)) != null ? _c : "?"))
      return 4 /* Act */;
    if (tag.startsWith((_d = this.dataSettings.get(8 /* Scene */)) != null ? _d : "?"))
      return 8 /* Scene */;
    if (tag.startsWith((_e = this.dataSettings.get(16 /* Session */)) != null ? _e : "?"))
      return 16 /* Session */;
    if (tag.startsWith((_f = this.dataSettings.get(64 /* NonPlayerCharacter */)) != null ? _f : "?"))
      return 64 /* NonPlayerCharacter */;
    if (tag.startsWith((_g = this.dataSettings.get(32 /* Character */)) != null ? _g : "?"))
      return 32 /* Character */;
    if (tag.startsWith((_h = this.dataSettings.get(512 /* Clue */)) != null ? _h : "?"))
      return 512 /* Clue */;
    if (tag.startsWith((_i = this.dataSettings.get(128 /* Location */)) != null ? _i : "?"))
      return 128 /* Location */;
    if (tag.startsWith((_j = this.dataSettings.get(1024 /* Faction */)) != null ? _j : "?"))
      return 1024 /* Faction */;
    if (tag.startsWith((_k = this.dataSettings.get(256 /* Event */)) != null ? _k : "?"))
      return 256 /* Event */;
    if (tag.startsWith((_l = this.dataSettings.get(2048 /* Music */)) != null ? _l : "?"))
      return 2048 /* Music */;
    if (tag.startsWith((_m = this.dataSettings.get(4096 /* Subplot */)) != null ? _m : "?"))
      return 4096 /* Subplot */;
    return void 0;
  }
  hasRpgManagerTags(tags) {
    for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {
      if (this.isRpgManagerTag(tags[tagIndex]))
        return true;
    }
    return false;
  }
  isRpgManagerTag(tag) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (tag == null)
      throw new Error("");
    if (tag.startsWith((_a = this.dataSettings.get(1 /* Campaign */)) != null ? _a : "?"))
      return true;
    if (tag.startsWith((_b = this.dataSettings.get(2 /* Adventure */)) != null ? _b : "?"))
      return true;
    if (tag.startsWith((_c = this.dataSettings.get(4 /* Act */)) != null ? _c : "?"))
      return true;
    if (tag.startsWith((_d = this.dataSettings.get(8 /* Scene */)) != null ? _d : "?"))
      return true;
    if (tag.startsWith((_e = this.dataSettings.get(16 /* Session */)) != null ? _e : "?"))
      return true;
    if (tag.startsWith((_f = this.dataSettings.get(64 /* NonPlayerCharacter */)) != null ? _f : "?"))
      return true;
    if (tag.startsWith((_g = this.dataSettings.get(32 /* Character */)) != null ? _g : "?"))
      return true;
    if (tag.startsWith((_h = this.dataSettings.get(512 /* Clue */)) != null ? _h : "?"))
      return true;
    if (tag.startsWith((_i = this.dataSettings.get(128 /* Location */)) != null ? _i : "?"))
      return true;
    if (tag.startsWith((_j = this.dataSettings.get(1024 /* Faction */)) != null ? _j : "?"))
      return true;
    if (tag.startsWith((_k = this.dataSettings.get(256 /* Event */)) != null ? _k : "?"))
      return true;
    if (tag.startsWith((_l = this.dataSettings.get(2048 /* Music */)) != null ? _l : "?"))
      return true;
    return tag.startsWith((_m = this.dataSettings.get(4096 /* Subplot */)) != null ? _m : "?");
  }
  getId(type, tag) {
    let response = void 0;
    const tagType = this.getDataType(tag);
    if (tagType === void 0)
      return void 0;
    const settings = this.dataSettings.get(tagType);
    if (settings === void 0)
      return void 0;
    const ids = tag.substring(settings.length + 1);
    if (ids === "")
      return void 0;
    const tagIds = ids.split("/");
    switch (type) {
      case 1 /* Campaign */:
        response = tagIds[0] ? tagIds[0] : void 0;
        break;
      case 2 /* Adventure */:
        response = +tagIds[1] ? tagIds[1] : void 0;
        break;
      case 16 /* Session */:
        response = +tagIds[1] ? tagIds[1] : void 0;
        break;
      case 4 /* Act */:
        response = +tagIds[2] ? tagIds[2] : void 0;
        break;
      case 8 /* Scene */:
        response = +tagIds[3] ? tagIds[3] : void 0;
        break;
    }
    return response;
  }
  getTag(tags) {
    if (tags == null)
      return void 0;
    let response;
    tags.forEach((tag) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      if (tag !== null && typeof tag === "string") {
        if (tag.startsWith((_a = this.dataSettings.get(1 /* Campaign */)) != null ? _a : "?"))
          response = tag;
        if (tag.startsWith((_b = this.dataSettings.get(2 /* Adventure */)) != null ? _b : "?"))
          response = tag;
        if (tag.startsWith((_c = this.dataSettings.get(4 /* Act */)) != null ? _c : "?"))
          response = tag;
        if (tag.startsWith((_d = this.dataSettings.get(8 /* Scene */)) != null ? _d : "?"))
          response = tag;
        if (tag.startsWith((_e = this.dataSettings.get(16 /* Session */)) != null ? _e : "?"))
          response = tag;
        if (tag.startsWith((_f = this.dataSettings.get(64 /* NonPlayerCharacter */)) != null ? _f : "?"))
          response = tag;
        if (tag.startsWith((_g = this.dataSettings.get(32 /* Character */)) != null ? _g : "?"))
          response = tag;
        if (tag.startsWith((_h = this.dataSettings.get(512 /* Clue */)) != null ? _h : "?"))
          response = tag;
        if (tag.startsWith((_i = this.dataSettings.get(128 /* Location */)) != null ? _i : "?"))
          response = tag;
        if (tag.startsWith((_j = this.dataSettings.get(1024 /* Faction */)) != null ? _j : "?"))
          response = tag;
        if (tag.startsWith((_k = this.dataSettings.get(256 /* Event */)) != null ? _k : "?"))
          response = tag;
        if (tag.startsWith((_l = this.dataSettings.get(2048 /* Music */)) != null ? _l : "?"))
          response = tag;
        if (tag.startsWith((_m = this.dataSettings.get(4096 /* Subplot */)) != null ? _m : "?"))
          response = tag;
      }
    });
    return response;
  }
  fuzzyTagGuesser(tag) {
    const response = void 0;
    const settings = this._settings;
    const oldCampaignTag = settings.campaignTag;
    const oldAdventureTag = settings.adventureTag;
    const oldActTag = settings.actTag;
    const oldSceneTag = settings.sceneTag;
    const oldSessionTag = settings.sessionTag;
    const oldSubplotTag = settings.subplotTag;
    const oldPcTag = settings.pcTag;
    const oldNpcTag = settings.npcTag;
    const oldClueTag = settings.clueTag;
    const oldEventTag = settings.eventTag;
    const oldLocationTag = settings.locationTag;
    const oldFactionTag = settings.factionTag;
    const oldMusicTag = settings.musicTag;
    if (oldCampaignTag !== void 0 && tag.startsWith(oldCampaignTag))
      return { tag: oldCampaignTag, type: 1 /* Campaign */ };
    if (oldAdventureTag !== void 0 && tag.startsWith(oldAdventureTag))
      return { tag: oldAdventureTag, type: 2 /* Adventure */ };
    if (oldActTag !== void 0 && tag.startsWith(oldActTag))
      return { tag: oldActTag, type: 4 /* Act */ };
    if (oldSceneTag !== void 0 && tag.startsWith(oldSceneTag))
      return { tag: oldSceneTag, type: 8 /* Scene */ };
    if (oldSessionTag !== void 0 && tag.startsWith(oldSessionTag))
      return { tag: oldSessionTag, type: 16 /* Session */ };
    if (oldSubplotTag !== void 0 && tag.startsWith(oldSubplotTag))
      return { tag: oldSubplotTag, type: 4096 /* Subplot */ };
    if (oldPcTag !== void 0 && tag.startsWith(oldPcTag))
      return { tag: oldPcTag, type: 32 /* Character */ };
    if (oldNpcTag !== void 0 && tag.startsWith(oldNpcTag))
      return { tag: oldNpcTag, type: 64 /* NonPlayerCharacter */ };
    if (oldClueTag !== void 0 && tag.startsWith(oldClueTag))
      return { tag: oldClueTag, type: 512 /* Clue */ };
    if (oldEventTag !== void 0 && tag.startsWith(oldEventTag))
      return { tag: oldEventTag, type: 256 /* Event */ };
    if (oldLocationTag !== void 0 && tag.startsWith(oldLocationTag))
      return { tag: oldLocationTag, type: 128 /* Location */ };
    if (oldFactionTag !== void 0 && tag.startsWith(oldFactionTag))
      return { tag: oldFactionTag, type: 1024 /* Faction */ };
    if (oldMusicTag !== void 0 && tag.startsWith(oldMusicTag))
      return { tag: oldMusicTag, type: 2048 /* Music */ };
    if (tag.startsWith("rpgm/outline/campaign"))
      return { tag, type: 1 /* Campaign */ };
    if (tag.startsWith("rpgm/outline/adventure"))
      return { tag, type: 2 /* Adventure */ };
    if (tag.startsWith("rpgm/outline/act"))
      return { tag, type: 4 /* Act */ };
    if (tag.startsWith("rpgm/outline/scene"))
      return { tag, type: 8 /* Scene */ };
    if (tag.startsWith("rpgm/outline/session"))
      return { tag, type: 16 /* Session */ };
    if (tag.startsWith("rpgm/outline/subplot"))
      return { tag, type: 4096 /* Subplot */ };
    if (tag.startsWith("rpgm/element/character/pc"))
      return { tag, type: 32 /* Character */ };
    if (tag.startsWith("rpgm/element/character/npc"))
      return { tag, type: 64 /* NonPlayerCharacter */ };
    if (tag.startsWith("rpgm/element/clue"))
      return { tag, type: 512 /* Clue */ };
    if (tag.startsWith("rpgm/element/event"))
      return { tag, type: 256 /* Event */ };
    if (tag.startsWith("rpgm/element/location"))
      return { tag, type: 128 /* Location */ };
    if (tag.startsWith("rpgm/element/faction"))
      return { tag, type: 1024 /* Faction */ };
    if (tag.startsWith("rpgm/element/music"))
      return { tag, type: 2048 /* Music */ };
    if (tag.toLowerCase().indexOf("campaign") !== -1)
      return { tag, type: 1 /* Campaign */ };
    if (tag.toLowerCase().indexOf("adventure") !== -1)
      return { tag, type: 2 /* Adventure */ };
    if (tag.toLowerCase().indexOf("act") !== -1)
      return { tag, type: 4 /* Act */ };
    if (tag.toLowerCase().indexOf("scene") !== -1)
      return { tag, type: 8 /* Scene */ };
    if (tag.toLowerCase().indexOf("session") !== -1)
      return { tag, type: 16 /* Session */ };
    if (tag.toLowerCase().indexOf("subplot") !== -1)
      return { tag, type: 4096 /* Subplot */ };
    if (tag.toLowerCase().indexOf("pc") !== -1)
      return { tag, type: 32 /* Character */ };
    if (tag.toLowerCase().indexOf("npc") !== -1)
      return { tag, type: 64 /* NonPlayerCharacter */ };
    if (tag.toLowerCase().indexOf("clue") !== -1)
      return { tag, type: 512 /* Clue */ };
    if (tag.toLowerCase().indexOf("event") !== -1)
      return { tag, type: 256 /* Event */ };
    if (tag.toLowerCase().indexOf("location") !== -1)
      return { tag, type: 128 /* Location */ };
    if (tag.toLowerCase().indexOf("faction") !== -1)
      return { tag, type: 1024 /* Faction */ };
    if (tag.toLowerCase().indexOf("music") !== -1)
      return { tag, type: 2048 /* Music */ };
    return response;
  }
  fuzzyTagsGuesser(tags) {
    if (tags == null)
      return void 0;
    let response;
    for (let index = 0; index < tags.length; index++) {
      response = this.fuzzyTagGuesser(tags[index]);
      if (response !== void 0 && response.tag.indexOf("rpgm") === -1)
        response = void 0;
    }
    if (response !== void 0) {
      for (let index = 0; index < tags.length; index++) {
        if (tags[index].startsWith(response.tag))
          response.tag = tags[index];
      }
    }
    return response;
  }
  getTemplateDataType(tags) {
    if (tags == null)
      return void 0;
    let response;
    tags.forEach((tag) => {
      if (tag.startsWith("rpgm/template/" + ComponentType[1 /* Campaign */].toLowerCase()))
        response = 1 /* Campaign */;
      if (tag.startsWith("rpgm/template/" + ComponentType[2 /* Adventure */].toLowerCase()))
        response = 2 /* Adventure */;
      if (tag.startsWith("rpgm/template/" + ComponentType[4 /* Act */].toLowerCase()))
        response = 4 /* Act */;
      if (tag.startsWith("rpgm/template/" + ComponentType[8 /* Scene */].toLowerCase()))
        response = 8 /* Scene */;
      if (tag.startsWith("rpgm/template/" + ComponentType[16 /* Session */].toLowerCase()))
        response = 16 /* Session */;
      if (tag.startsWith("rpgm/template/" + ComponentType[64 /* NonPlayerCharacter */].toLowerCase()))
        response = 64 /* NonPlayerCharacter */;
      if (tag.startsWith("rpgm/template/" + ComponentType[32 /* Character */].toLowerCase()))
        response = 32 /* Character */;
      if (tag.startsWith("rpgm/template/" + ComponentType[512 /* Clue */].toLowerCase()))
        response = 512 /* Clue */;
      if (tag.startsWith("rpgm/template/" + ComponentType[128 /* Location */].toLowerCase()))
        response = 128 /* Location */;
      if (tag.startsWith("rpgm/template/" + ComponentType[1024 /* Faction */].toLowerCase()))
        response = 1024 /* Faction */;
      if (tag.startsWith("rpgm/template/" + ComponentType[256 /* Event */].toLowerCase()))
        response = 256 /* Event */;
      if (tag.startsWith("rpgm/template/" + ComponentType[2048 /* Music */].toLowerCase()))
        response = 2048 /* Music */;
      if (tag.startsWith("rpgm/template/" + ComponentType[4096 /* Subplot */].toLowerCase()))
        response = 4096 /* Subplot */;
    });
    return response;
  }
};
var TagHelper = _TagHelper;
TagHelper.campaignTag = "rpgm/campaign";
TagHelper.adventureTag = "rpgm/adventure";
TagHelper.actTag = "rpgm/act";
TagHelper.sceneTag = "rpgm/scene";
TagHelper.sessionTag = "rpgm/session";
TagHelper.npcTag = "rpgm/npc";
TagHelper.pcTag = "rpgm/pc";
TagHelper.locationTag = "rpgm/location";
TagHelper.factionTag = "rpgm/faction";
TagHelper.eventTag = "rpgm/event";
TagHelper.clueTag = "rpgm/clue";
TagHelper.musicTag = "rpgm/music";
TagHelper.subplotTag = "rpgm/subplot";

// src/updaters/workers/V1_3_to_2_0_worker.ts
var V1_3_to_2_0_worker = class extends AbstractDatabaseWorker {
  run(reporter = void 0) {
    return __async(this, null, function* () {
      this.factories.logger.warning(16 /* Updater */, "Updating RPG Manager from v1.3 to v2.0");
      const campaigns = [];
      const sessions = [];
      const files = yield this.app.vault.getMarkdownFiles();
      const fileMap = /* @__PURE__ */ new Map();
      let wasAlreadyUpdated = false;
      for (let index = 0; index < files.length; index++) {
        const content = yield this.app.vault.read(files[index]);
        fileMap.set(files[index], content);
        if (content.indexOf("```RpgManager\nact") !== -1)
          wasAlreadyUpdated = true;
      }
      if (!wasAlreadyUpdated) {
        for (let index = 0; index < files.length; index++) {
          const content = yield this.app.vault.read(files[index]);
          const newFileContent = yield content.replaceAll(TagHelper.sessionTag, TagHelper.actTag).replaceAll("```RpgManager\nsession", "```RpgManager\nact");
          if (newFileContent !== content) {
            if (files[index].basename.toLowerCase().indexOf("session") !== -1)
              sessions.push(files[index]);
            yield this.app.vault.modify(files[index], newFileContent);
          }
          if (content.contains(TagHelper.campaignTag)) {
            campaigns.push(files[index]);
          }
        }
        for (let sessionIndex = 0; sessionIndex < sessions.length; sessionIndex++) {
          const path2 = sessions[sessionIndex].path;
          const basename = sessions[sessionIndex].basename;
          const newBaseName = basename.replaceAll("session", "act").replaceAll("Session", "Act").replaceAll("SESSION", "ACT");
          const newPath = path2.replaceAll(basename, newBaseName);
          yield this.app.vault.rename(sessions[sessionIndex], newPath);
        }
        const changedPaths = /* @__PURE__ */ new Map();
        for (let index = 0; index < campaigns.length; index++) {
          const file = campaigns[index];
          yield file.parent.children.forEach((fileOrFolder) => {
            if (fileOrFolder instanceof import_obsidian34.TFolder && fileOrFolder.name === "Sessions") {
              if (changedPaths.get(fileOrFolder.path) === void 0) {
                changedPaths.set(fileOrFolder.path + "", true);
                const newPath = fileOrFolder.path.replaceAll("Sessions", "Acts");
                this.app.vault.rename(fileOrFolder, newPath);
              }
            }
          });
        }
      }
      return;
    });
  }
};

// src/updaters/workers/V2_0_to_3_0_worker.ts
var import_obsidian35 = require("obsidian");
var V2_0_to_3_0_worker = class extends AbstractDatabaseWorker {
  run(reporter = void 0) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      this.factories.logger.warning(16 /* Updater */, "Updating RPG Manager from v2.0 to v3.0");
      this._campaignSettings = /* @__PURE__ */ new Map();
      this._loadCampaignSettings();
      const files = yield this.app.vault.getMarkdownFiles();
      if (reporter !== void 0)
        reporter.setFileCount(files.length);
      for (let filesIndex = 0; filesIndex < files.length; filesIndex++) {
        const file = files[filesIndex];
        const cachedMetadata = this.app.metadataCache.getFileCache(file);
        if (cachedMetadata == null)
          continue;
        if (((_a = cachedMetadata == null ? void 0 : cachedMetadata.frontmatter) == null ? void 0 : _a.tags) == null) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        const tags = this.tagHelper.sanitiseTags((_b = cachedMetadata == null ? void 0 : cachedMetadata.frontmatter) == null ? void 0 : _b.tags);
        if (tags.length === 0) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        let fileContent = yield this.app.vault.read(file);
        const tagAndType = this._getTagAndType(tags);
        if (tagAndType === void 0) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        } else {
          if (fileContent.indexOf("```RpgManager") === -1) {
            if (reporter !== void 0)
              reporter.addFileUpdated();
            continue;
          }
        }
        if (tagAndType.updated === true) {
          fileContent = fileContent.replaceAll(tagAndType.fuzzyGuessedTag, tagAndType.tag);
        }
        const fileContentArray = yield fileContent.split("\n");
        let frontmatterMetadataStartLine = void 0;
        let frontmatterMetadataEndLine = void 0;
        const frontmatterMetadata = cachedMetadata.frontmatter;
        let frontmatterMetadataContentArray = void 0;
        let firstCodeblockStartLine = void 0;
        let firstCodeblockEndLine = void 0;
        let firstCodeblockMetadata = void 0;
        let firstCodeblockMetadataType;
        let firstCodeblockMetadataContent = void 0;
        let firstCodeblockMetadataContentArray = void 0;
        let firstCodeblockNewMetadata = void 0;
        let firstCodeblockNewMetadataContent = void 0;
        let secondCodeblockMetadataStartLine = void 0;
        let secondCodeblockMetadataEndLine = void 0;
        let secondCodeblockMetadataType;
        let secondCodeblockNewMetadata = void 0;
        let secondCodeblockNewMetadataContent = void 0;
        let codeblock;
        for (let index = 0; index < ((_d = (_c = cachedMetadata.sections) == null ? void 0 : _c.length) != null ? _d : 0); index++) {
          codeblock = cachedMetadata.sections !== void 0 ? cachedMetadata.sections[index] : void 0;
          if (codeblock !== void 0 && codeblock.type === "yaml" && index === 0) {
            frontmatterMetadataStartLine = codeblock.position.start.line;
            frontmatterMetadataEndLine = codeblock.position.end.line;
            frontmatterMetadataContentArray = fileContentArray.slice(frontmatterMetadataStartLine, frontmatterMetadataEndLine);
          } else if (codeblock !== void 0 && fileContentArray[codeblock.position.start.line] === "```RpgManager") {
            if (firstCodeblockStartLine === void 0) {
              firstCodeblockStartLine = codeblock.position.start.line + 1;
              firstCodeblockEndLine = codeblock.position.end.line;
              if (firstCodeblockStartLine != void 0 && firstCodeblockEndLine != void 0) {
                firstCodeblockMetadataType = fileContentArray[firstCodeblockStartLine];
                firstCodeblockMetadataContentArray = fileContentArray.slice(firstCodeblockStartLine + 1, firstCodeblockEndLine);
                firstCodeblockMetadataContentArray.slice(1);
                firstCodeblockMetadataContent = firstCodeblockMetadataContentArray.join("\n");
                firstCodeblockMetadata = (0, import_obsidian35.parseYaml)(firstCodeblockMetadataContent);
              }
            } else {
              secondCodeblockMetadataStartLine = codeblock.position.start.line + 1;
              secondCodeblockMetadataEndLine = codeblock.position.end.line;
              if (secondCodeblockMetadataStartLine != void 0 && secondCodeblockMetadataEndLine != void 0) {
                secondCodeblockMetadataType = fileContentArray[secondCodeblockMetadataStartLine];
              }
            }
          }
        }
        let metadataRelationships = [];
        if (frontmatterMetadataContentArray !== void 0) {
          metadataRelationships = yield this._readRelationshipsFromFrontmatter(frontmatterMetadataContentArray);
        }
        const relationships = yield this._addRelationshipsFromContent(metadataRelationships, fileContentArray);
        const dataCodeblockMetadata = this._getComponentRpgManagerDataCodeBlockMetadata(tagAndType.type);
        let dataCodeblockMetadataContent = "";
        if (firstCodeblockMetadataType !== void 0) {
          firstCodeblockNewMetadata = this._getComponentRpgManagerCodeBlockMetadata(firstCodeblockMetadataType.toLowerCase());
          firstCodeblockNewMetadataContent = YamlHelper.stringify(firstCodeblockNewMetadata);
          dataCodeblockMetadataContent = yield this._updateMetadata(tagAndType.type, dataCodeblockMetadata, frontmatterMetadata, firstCodeblockMetadata, relationships);
        }
        if (secondCodeblockMetadataType !== void 0) {
          secondCodeblockNewMetadata = this._getComponentRpgManagerCodeBlockMetadata(secondCodeblockMetadataType.toLowerCase());
          secondCodeblockNewMetadataContent = YamlHelper.stringify(secondCodeblockNewMetadata);
        }
        if (secondCodeblockNewMetadataContent !== void 0 && secondCodeblockMetadataStartLine !== void 0 && secondCodeblockMetadataEndLine !== void 0) {
          const listNewMetadataContentArray = secondCodeblockNewMetadataContent.split("\n");
          listNewMetadataContentArray[listNewMetadataContentArray.length - 1] = "```";
          fileContentArray.splice(secondCodeblockMetadataStartLine, secondCodeblockMetadataEndLine - secondCodeblockMetadataStartLine + 1, ...listNewMetadataContentArray);
        }
        if (firstCodeblockNewMetadataContent !== void 0 && firstCodeblockStartLine !== void 0 && firstCodeblockEndLine !== void 0) {
          const dataNewMetadataContentArray = firstCodeblockNewMetadataContent.split("\n");
          dataNewMetadataContentArray[dataNewMetadataContentArray.length - 1] = "```";
          fileContentArray.splice(firstCodeblockStartLine, firstCodeblockEndLine - firstCodeblockStartLine + 1, ...dataNewMetadataContentArray);
        }
        if (frontmatterMetadataContentArray !== void 0 && frontmatterMetadataStartLine !== void 0 && frontmatterMetadataEndLine !== void 0) {
          const frontmatter = this._cleanFrontmatter(frontmatterMetadataContentArray);
          const frontmatterContent = "---\n" + YamlHelper.stringify(frontmatter) + "---\n```RpgManagerData\n" + dataCodeblockMetadataContent + "```";
          fileContentArray.splice(frontmatterMetadataStartLine, frontmatterMetadataEndLine - frontmatterMetadataStartLine + 1, ...frontmatterContent.split("\n"));
        }
        let defaultTag = this.tagHelper.dataSettings.get(tagAndType.type);
        if (defaultTag !== void 0) {
          if (!defaultTag.endsWith("/"))
            defaultTag += "/";
          const tagIds = tagAndType.tag.substring(defaultTag.length);
          const [campaignId] = tagIds.split("/");
          let campaignSettings = this._campaignSettings.get(+campaignId);
          if (campaignSettings === void 0)
            campaignSettings = 0 /* Agnostic */;
          const validator = tagAndType.tag.substring(defaultTag.length).split("/");
          let isValidTag = true;
          for (let index = 0; index < validator.length; index++) {
            if (isNaN(+validator[index])) {
              isValidTag = false;
              break;
            }
          }
          if (!isValidTag)
            continue;
          const computedTag = tagAndType.type + "-" + campaignSettings + "-" + tagAndType.tag.substring(defaultTag.length);
          fileContentArray.push("```RpgManagerID");
          fileContentArray.push("### DO NOT EDIT MANUALLY IF NOT INSTRUCTED TO DO SO ###");
          fileContentArray.push("id: " + computedTag);
          fileContentArray.push("checksum: " + Md5.hashStr(computedTag));
          fileContentArray.push("```");
        }
        fileContent = fileContentArray.join("\n");
        this.app.vault.modify(file, fileContent).then(() => {
          const settings = this.settings;
          delete settings.campaignTag;
          delete settings.adventureTag;
          delete settings.actTag;
          delete settings.sceneTag;
          delete settings.sessionTag;
          delete settings.subplotTag;
          delete settings.npcTag;
          delete settings.pcTag;
          delete settings.clueTag;
          delete settings.eventTag;
          delete settings.locationTag;
          delete settings.factionTag;
          delete settings.musicTag;
          this.updateSettings(settings, false);
          if (reporter !== void 0)
            reporter.addFileUpdated();
        });
      }
    });
  }
  _getTagAndType(tags) {
    let type = void 0;
    let tag = this.tagHelper.getTag(tags);
    if (tag === void 0) {
      const fuzzyGuessedTag = this.tagHelper.fuzzyTagsGuesser(tags);
      if (fuzzyGuessedTag === void 0)
        return void 0;
      tag = this.tagHelper.dataSettings.get(fuzzyGuessedTag.type);
      if (tag === void 0)
        return void 0;
      type = fuzzyGuessedTag.type;
      let parameterCount = 1;
      switch (type) {
        case 2 /* Adventure */:
        case 16 /* Session */:
          parameterCount = 2;
          break;
        case 4 /* Act */:
          parameterCount = 3;
          break;
        case 8 /* Scene */:
          parameterCount = 4;
          break;
      }
      const tagElements = fuzzyGuessedTag.tag.split("/");
      const remainingTagElements = tagElements.slice(tagElements.length - parameterCount);
      if (!tag.endsWith("/"))
        tag += "/";
      tag += remainingTagElements.join("/");
      return { tag, fuzzyGuessedTag: fuzzyGuessedTag.tag, type, updated: true };
    }
    type = this.tagHelper.getDataType(tag);
    if (type === void 0)
      return void 0;
    return { tag, fuzzyGuessedTag: tag, type, updated: false };
  }
  _cleanFrontmatter(frontmatterMetadataContentArray) {
    let frontmatterContent = "";
    for (let index = 0; index < frontmatterMetadataContentArray.length; index++) {
      if (!frontmatterMetadataContentArray[index].trimStart().startsWith("[[") && frontmatterMetadataContentArray[index].trim() !== "") {
        frontmatterContent += frontmatterMetadataContentArray[index] + "\n";
      }
    }
    const frontmatter = (0, import_obsidian35.parseYaml)(frontmatterContent);
    if (frontmatter.tags !== void 0) {
      for (let index = frontmatter.tags.length - 1; index >= 0; index--) {
        if (this.tagHelper.isRpgManagerTag(frontmatter.tags[index])) {
          frontmatter.tags.splice(index, 1);
        }
      }
    } else {
      frontmatter.tags = [];
    }
    if (frontmatter.alias == void 0)
      frontmatter.alias = [];
    if (frontmatter.settings !== void 0)
      delete frontmatter.settings;
    if (frontmatter.completed !== void 0)
      delete frontmatter.completed;
    if (frontmatter.synopsis !== void 0)
      delete frontmatter.synopsis;
    if (frontmatter.image !== void 0)
      delete frontmatter.image;
    if (frontmatter.abt !== void 0)
      delete frontmatter.abt;
    if (frontmatter.dates !== void 0)
      delete frontmatter.dates;
    if (frontmatter.times !== void 0)
      delete frontmatter.times;
    if (frontmatter.time !== void 0)
      delete frontmatter.time;
    if (frontmatter.relationships !== void 0)
      delete frontmatter.relationships;
    if (frontmatter.address !== void 0)
      delete frontmatter.address;
    if (frontmatter.url !== void 0)
      delete frontmatter.url;
    if (frontmatter.goals !== void 0)
      delete frontmatter.goals;
    if (frontmatter.session !== void 0)
      delete frontmatter.session;
    if (frontmatter.action !== void 0)
      delete frontmatter.action;
    if (frontmatter.storycircle !== void 0)
      delete frontmatter.storycircle;
    if (frontmatter.sceneType !== void 0)
      delete frontmatter.sceneType;
    if (frontmatter.date !== void 0)
      delete frontmatter.date;
    if (frontmatter.pronoun !== void 0)
      delete frontmatter.pronoun;
    return frontmatter;
  }
  _readRelationshipsFromFrontmatter(frontmatterMetadataContentArray) {
    const response = [];
    let fileContentArray = [];
    for (let index = 0; index < frontmatterMetadataContentArray.length; index++) {
      const frontmatterLine = frontmatterMetadataContentArray[index];
      if (frontmatterLine.trimStart().startsWith("[[")) {
        let line = frontmatterLine;
        line = line.substring(line.indexOf("[[") + 2);
        const endLinkIndex = line.indexOf("]]");
        if (endLinkIndex === -1)
          continue;
        const nameAndAlias = line.substring(0, endLinkIndex);
        const aliasIndex = nameAndAlias.indexOf("|");
        let basename;
        if (aliasIndex === -1) {
          basename = nameAndAlias;
        } else {
          basename = nameAndAlias.substring(0, aliasIndex);
        }
        line = line.substring(line.indexOf("]]") + 3).trimStart();
        if (line === '""')
          line = "";
        if (line.startsWith('"') && line.endsWith('"'))
          line = line.substring(1, line.length - 1);
        fileContentArray = [...fileContentArray, ...this._readContentRelationships(line)];
        const path2 = this._getPathFromBasename(basename);
        if (path2 !== void 0 && !this._pathExistsInRelationships(path2, response)) {
          const newRelationship = {
            type: "bidirectional",
            path: path2,
            description: line
          };
          response.push(newRelationship);
        }
      }
    }
    return this._addRelationshipsFromContent(response, fileContentArray);
  }
  _readContentRelationships(content) {
    const response = [];
    let indexStart = content.indexOf("[[");
    while (indexStart !== -1) {
      content = content.substring(indexStart + 2);
      const endLinkIndex = content.indexOf("]]");
      if (endLinkIndex === -1)
        break;
      const nameAndAlias = content.substring(0, endLinkIndex);
      content = content.substring(endLinkIndex + 2);
      const aliasIndex = nameAndAlias.indexOf("|");
      let basename;
      if (aliasIndex === -1) {
        basename = nameAndAlias;
      } else {
        basename = nameAndAlias.substring(0, aliasIndex);
      }
      response.push(basename);
      indexStart = content.indexOf("[[");
    }
    return response;
  }
  _addRelationshipsFromContent(frontmatterRelationships, fileContentArray) {
    for (let index = 0; index < fileContentArray.length; index++) {
      const path2 = this._getPathFromBasename(fileContentArray[index]);
      if (path2 === void 0)
        continue;
      if (!this._pathExistsInRelationships(path2, frontmatterRelationships)) {
        const newRelationship = {
          type: "bidirectional",
          path: path2,
          isInContent: true
        };
        frontmatterRelationships.push(newRelationship);
      }
    }
    return frontmatterRelationships;
  }
  _pathExistsInRelationships(path2, relationships) {
    const existingRelationships = relationships.filter((relationship) => relationship.path === path2);
    if (existingRelationships.length !== 1)
      return false;
    return true;
  }
  _getPathFromBasename(basename) {
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.basename === basename);
    if (files.length !== 1)
      return void 0;
    return files[0].path;
  }
  _updateMetadata(type, metadata, frontmatterMetadata, codeblockMetadata, relationships) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    switch (type) {
      case 1 /* Campaign */:
        if (((_a = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _a.current) != void 0)
          metadata.data.date = frontmatterMetadata.dates.current;
        break;
      case 4 /* Act */:
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.abt) != void 0)
          metadata.data.abtStage = frontmatterMetadata.abt;
        break;
      case 8 /* Scene */:
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.sceneType) != void 0)
          metadata.data.sceneType = frontmatterMetadata.sceneType;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.storycircle) != void 0)
          metadata.data.storyCircleStage = frontmatterMetadata.storycircle;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.isActedUpon) != void 0)
          metadata.data.isActedUpon = frontmatterMetadata.isActedUpon;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.action) != void 0)
          metadata.data.action = frontmatterMetadata.action;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.date) != void 0)
          metadata.data.date = frontmatterMetadata.date;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.session) != void 0)
          metadata.data.sessionId = frontmatterMetadata.session;
        if ((codeblockMetadata == null ? void 0 : codeblockMetadata.action) != void 0)
          metadata.data.action = codeblockMetadata.action;
        if ((codeblockMetadata == null ? void 0 : codeblockMetadata.trigger) != void 0)
          metadata.data.trigger = codeblockMetadata.trigger;
        if ((codeblockMetadata == null ? void 0 : codeblockMetadata.durations) !== void 0 && (codeblockMetadata == null ? void 0 : codeblockMetadata.duration)) {
          metadata.data.duration = codeblockMetadata.duration;
          metadata.data.durations = codeblockMetadata.durations;
        } else {
          if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.time) != void 0 && ((_b = frontmatterMetadata == null ? void 0 : frontmatterMetadata.time) == null ? void 0 : _b.start) != void 0 && ((_c = frontmatterMetadata == null ? void 0 : frontmatterMetadata.time) == null ? void 0 : _c.end) != void 0) {
            this._addDurations(frontmatterMetadata.time.start, frontmatterMetadata.time.end, metadata);
          }
          if (frontmatterMetadata.times != void 0 && ((_d = frontmatterMetadata.times) == null ? void 0 : _d.start) != void 0 && ((_e = frontmatterMetadata.times) == null ? void 0 : _e.end) != void 0) {
            this._addDurations(frontmatterMetadata.times.start, frontmatterMetadata.times.end, metadata);
          }
        }
        break;
      case 16 /* Session */:
        if (((_f = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _f.irl) != void 0)
          metadata.data.irl = frontmatterMetadata.dates.irl;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.abt) != void 0)
          metadata.data.abtStage = frontmatterMetadata.abt;
        break;
      case 32 /* Character */:
        if (((_g = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _g.dob) != void 0)
          metadata.data.dob = frontmatterMetadata.dates.dob;
        if (((_h = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _h.death) != void 0)
          metadata.data.death = frontmatterMetadata.dates.death;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.pronoun) != void 0)
          metadata.data.pronoun = frontmatterMetadata.pronoun;
        break;
      case 512 /* Clue */:
        if (((_i = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _i.found) != void 0)
          metadata.data.found = frontmatterMetadata.dates.found;
        break;
      case 256 /* Event */:
        if (((_j = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _j.event) != void 0)
          metadata.data.date = frontmatterMetadata.dates.event;
        break;
      case 128 /* Location */:
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.address) != void 0)
          metadata.data.date = frontmatterMetadata.address;
        break;
      case 2048 /* Music */:
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.url) != void 0)
          metadata.data.date = frontmatterMetadata.url;
        break;
      case 64 /* NonPlayerCharacter */:
        if (((_k = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _k.dob) != void 0)
          metadata.data.dob = frontmatterMetadata.dates.dob;
        if (((_l = frontmatterMetadata == null ? void 0 : frontmatterMetadata.dates) == null ? void 0 : _l.death) != void 0)
          metadata.data.death = frontmatterMetadata.dates.death;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.pronoun) != void 0)
          metadata.data.pronoun = frontmatterMetadata.dates.pronoun;
        if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.goals) != void 0)
          metadata.data.pronoun = frontmatterMetadata.goals;
        break;
    }
    if ((codeblockMetadata == null ? void 0 : codeblockMetadata.abt) != void 0 && metadata.plot != void 0)
      metadata.plot.abt = codeblockMetadata.abt;
    if ((codeblockMetadata == null ? void 0 : codeblockMetadata.storycircle) != void 0 && metadata.plot != void 0)
      metadata.plot.storycircle = codeblockMetadata.storycircle;
    if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.complete) !== void 0 || (frontmatterMetadata == null ? void 0 : frontmatterMetadata.completed) !== void 0) {
      if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.complete) !== void 0 && frontmatterMetadata.complete === false) {
        metadata.data.complete = false;
      } else if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.completed) !== void 0 && frontmatterMetadata.completed === false) {
        metadata.data.complete = false;
      }
    } else {
      delete metadata.data.complete;
    }
    if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.synopsis) != void 0)
      metadata.data.synopsis = frontmatterMetadata.synopsis;
    if ((frontmatterMetadata == null ? void 0 : frontmatterMetadata.image) != void 0)
      metadata.data.image = frontmatterMetadata.image;
    if (relationships.length > 0)
      metadata.relationships = relationships;
    let response = YamlHelper.stringify(metadata);
    response = response.replaceAll("0,", ",").replaceAll("'',", ",").replaceAll("{},", ",").replaceAll('"",', ",");
    return response;
  }
  _addDurations(start, end, metadata) {
    const indexOfStartT = start.indexOf("T");
    const indexOfEndT = end.indexOf("T");
    if (indexOfStartT !== -1 && indexOfEndT !== -1) {
      const [startHour, startMinute] = start.substring(indexOfStartT + 1).split(":");
      const [endHour, endMinute] = end.substring(indexOfEndT + 1).split(":");
      const startTime = +startHour * 60 + +startMinute;
      let endTime = +endHour * 60 + +endMinute;
      if (startTime > endTime)
        endTime += 24 * 60;
      const duration2 = (endTime - startTime) * 60;
      if (duration2 !== void 0 && duration2 > 0) {
        const durations = [];
        metadata.data.durations = [];
        let singleDuration = "0";
        singleDuration += "-";
        singleDuration += duration2.toString();
        durations.push("" + singleDuration);
        metadata.data.durations = durations;
        metadata.data.duration = duration2;
      }
    }
  }
  _getComponentRpgManagerDataCodeBlockMetadata(type) {
    switch (type) {
      case 1 /* Campaign */:
        return {
          plot: { abt: { need: "", and: "", but: "", therefore: "" }, storycircle: { you: "", need: "", go: "", search: "", find: "", take: "", return: "", change: "" } },
          data: { date: "", synopsis: "", image: "", complete: true, currentAdventureId: "", currentActId: "", currentSessionId: "" }
        };
      case 2 /* Adventure */:
        return {
          plot: { abt: { need: "", and: "", but: "", therefore: "" }, storycircle: { you: "", need: "", go: "", search: "", find: "", take: "", return: "", change: "" } },
          data: { synopsis: "", complete: false }
        };
      case 4 /* Act */:
        return {
          plot: { abt: { need: "", and: "", but: "", therefore: "" }, storycircle: { you: "", need: "", go: "", search: "", find: "", take: "", return: "", change: "" } },
          data: { synopsis: "", image: "", complete: false, abtStage: "" },
          relationships: []
        };
      case 8 /* Scene */:
        return {
          data: { synopsis: "", image: "", complete: false, sessionId: 0, action: "", trigger: "", date: "", sceneType: "", isActedUpon: false, duration: 0, durations: [], storyCircleStage: "" },
          relationships: []
        };
      case 16 /* Session */:
        return {
          data: { synopsis: "", image: "", complete: false, irl: void 0, abtStage: void 0 },
          relationships: []
        };
      case 4096 /* Subplot */:
        return {
          plot: { abt: { need: "", and: "", but: "", therefore: "" }, storycircle: { you: "", need: "", go: "", search: "", find: "", take: "", return: "", change: "" } },
          data: { synopsis: "", image: "", complete: false },
          relationships: []
        };
      case 32 /* Character */:
        return {
          data: { synopsis: "", image: "", complete: false, dob: "", death: "", goals: "", pronoun: "" },
          relationships: []
        };
      case 512 /* Clue */:
        return {
          data: { synopsis: "", image: "", complete: false, found: false },
          relationships: []
        };
      case 256 /* Event */:
        return {
          data: { synopsis: "", image: "", complete: false, date: "" },
          relationships: []
        };
      case 1024 /* Faction */:
        return {
          data: { synopsis: "", image: "", complete: false },
          relationships: []
        };
      case 128 /* Location */:
        return {
          data: { synopsis: "", image: "", complete: false, address: "" },
          relationships: []
        };
      case 2048 /* Music */:
        return {
          data: { synopsis: "", image: "", complete: false, url: "" },
          relationships: []
        };
      case 64 /* NonPlayerCharacter */:
        return {
          data: { synopsis: "", image: "", death: "", dob: "", goals: "", pronoun: "", complete: false },
          relationships: []
        };
    }
  }
  _getComponentRpgManagerCodeBlockMetadata(codeBlockType) {
    switch (codeBlockType) {
      case "campaignnavigation":
        return {
          models: { header: true }
        };
      case "campaign":
        return {
          models: { lists: { pcs: { relationship: "hierarchy" }, subplots: { relationship: "hierarchy" }, adventures: { relationship: "hierarchy" }, acts: { relationship: "hierarchy" }, sessions: { relationship: "hierarchy" }, events: { relationship: "hierarchy" }, npcs: { relationship: "hierarchy" } } }
        };
      case "adventurenavigation":
        return {
          models: { header: true }
        };
      case "adventure":
        return {
          models: { lists: { acts: { relationship: "hierarchy" } } }
        };
      case "actnavigation":
        return {
          models: { header: true }
        };
      case "act":
        return {
          models: { lists: { scenes: { relationship: "hierarchy" }, pcs: { relationship: "unidirectional" }, npcs: { relationship: "unidirectional" }, clues: { relationship: "unidirectional" }, locations: { relationship: "unidirectional" }, factions: { relationship: "unidirectional" } } }
        };
      case "scenenavigation":
        return {
          models: { header: true }
        };
      case "scene":
        return {
          models: { lists: { musics: { relationship: "unidirectional" }, pcs: { relationship: "unidirectional" }, npcs: { relationship: "unidirectional" }, factions: { relationship: "unidirectional" }, clues: { relationship: "unidirectional" }, locations: { relationship: "unidirectional" }, events: { relationship: "unidirectional" } } }
        };
      case "sessionnavigation":
        return {
          models: { header: true, lists: { scenes: { relationship: "hierarchy" } } }
        };
      case "session":
        return {
          models: { lists: { subplots: { relationship: "hierarchy" }, musics: { relationship: "hierarchy" }, pcs: { relationship: "hierarchy" }, npcs: { relationship: "hierarchy" }, factions: { relationship: "hierarchy" }, clues: { relationship: "hierarchy" }, locations: { relationship: "hierarchy" }, events: { relationship: "hierarchy" } } }
        };
      case "subplot":
        return {
          models: { header: true, lists: { events: {}, clues: {}, factions: {}, npcs: {}, locations: {} } }
        };
      case "pc":
        return {
          models: { header: true, lists: { pcs: { relationship: "unidirectional" }, npcs: { relationship: "unidirectional" }, factions: {}, locations: {} } }
        };
      case "clue":
        return {
          models: { header: true, lists: { subplots: {}, pcs: {}, npcs: {}, locations: {}, clues: {}, events: {} } }
        };
      case "event":
        return {
          models: { header: true, lists: { subplots: {}, pcs: {}, npcs: {}, clues: {}, locations: {} } }
        };
      case "faction":
        return {
          models: { header: true, lists: { pcs: {}, npcs: {}, locations: {}, subplots: {} } }
        };
      case "location":
        return {
          models: { header: true, lists: { pcs: {}, npcs: {}, events: {}, clues: {}, locations: [{ relationship: "parent", title: "Inside" }, { relationship: "child", title: "Contains" }] } }
        };
      case "music":
        return {
          models: { header: true, lists: { musics: [{ relationship: "parent", title: "Part of playlists" }, { relationship: "child", title: "Songs" }] } }
        };
      case "npc":
        return {
          models: { header: true, lists: { subplots: {}, pcs: { relationship: "unidirectional" }, npcs: { relationship: "unidirectional" }, factions: {}, locations: {}, events: {}, clues: {} } }
        };
    }
  }
  _loadCampaignSettings() {
    this.app.vault.getMarkdownFiles().forEach((file) => {
      var _a, _b;
      const metadata = this.app.metadataCache.getFileCache(file);
      if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.tags) != null) {
        const tags = this.tagHelper.sanitiseTags(metadata.frontmatter.tags);
        if (tags.length === 0)
          return;
        const tagAndType = this._getTagAndType(tags);
        if (tagAndType !== void 0) {
          if (tagAndType.type === 1 /* Campaign */) {
            const id = this.factories.id.createFromTag(tagAndType.tag);
            try {
              const settings = ((_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.settings) != void 0 ? CampaignSetting[metadata.frontmatter.settings] : 0 /* Agnostic */;
              this._campaignSettings.set(id.campaignId, settings);
            } catch (e) {
            }
          }
        }
      }
    });
  }
};

// src/updaters/workers/V3_0_to_3_1_worker.ts
var import_obsidian36 = require("obsidian");
var V3_0_to_3_1_worker = class extends AbstractDatabaseWorker {
  run(reporter = void 0) {
    return __async(this, null, function* () {
      var _a;
      this.factories.logger.warning(16 /* Updater */, "Updating RPG Manager from v3.0 to v3.1");
      const files = yield this.app.vault.getMarkdownFiles();
      if (reporter !== void 0)
        reporter.setFileCount(files.length);
      for (let filesIndex = 0; filesIndex < files.length; filesIndex++) {
        const file = files[filesIndex];
        const cachedMetadata = this.app.metadataCache.getFileCache(file);
        if (cachedMetadata == null) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        let fileContent = yield this.app.vault.read(file);
        const fileContentArray = fileContent.split("\n");
        if (fileContent.indexOf("```RpgManagerData") === -1) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        const codeblocks = (_a = cachedMetadata.sections) == null ? void 0 : _a.filter((section) => section.type === "code" && fileContentArray[section.position.start.line] === "```RpgManagerData");
        if (codeblocks == void 0 || codeblocks.length !== 1) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        const codeblock = codeblocks[0];
        const data = fileContentArray.slice(codeblock.position.start.line + 1, codeblock.position.end.line);
        const yaml = (0, import_obsidian36.parseYaml)(data.join("\n"));
        if (yaml == void 0) {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        if (yaml.data === void 0)
          yaml.data = {};
        if (yaml.data.images === void 0)
          yaml.data.images = [];
        const imageSrc = yaml.data.image;
        let imagePath = imageSrc;
        if (imagePath == void 0 || imagePath === "") {
          if (AbstractComponent.root == void 0)
            AbstractComponent.initialiseRoots(this.app);
          const attachmentFolder = this.settings.imagesFolder !== void 0 && this.settings.imagesFolder !== "" ? this.settings.imagesFolder : this.app.vault.config.attachmentFolderPath;
          if (attachmentFolder === void 0) {
            if (reporter !== void 0)
              reporter.addFileUpdated();
            continue;
          }
          const files2 = this.app.vault.getFiles().filter((image) => image.path.toLowerCase().startsWith(attachmentFolder.toLowerCase()) && image.basename.toLowerCase().startsWith(file.basename.toLowerCase()));
          if (files2.length === 1)
            imagePath = files2[0].path;
        }
        if (imagePath == void 0 || imagePath === "") {
          if (reporter !== void 0)
            reporter.addFileUpdated();
          continue;
        }
        const metadataImage = {
          path: imagePath
        };
        yaml.data.images.push(metadataImage);
        delete yaml.data.image;
        const newYamlArray = YamlHelper.stringify(yaml).split("\n");
        fileContentArray.splice(codeblock.position.start.line + 1, codeblock.position.end.line - codeblock.position.start.line - 1, ...newYamlArray);
        fileContent = fileContentArray.join("\n");
        if (reporter !== void 0)
          reporter.addFileUpdated();
        this.app.vault.modify(file, fileContent).then(() => {
          if (reporter !== void 0)
            reporter.addFileUpdated();
        });
      }
    });
  }
};

// src/updaters/DatabaseUpdater.ts
var versionMap = {
  "1.2": V1_2_to_1_3_worker,
  "1.3": V1_3_to_2_0_worker,
  "2.0": V2_0_to_3_0_worker,
  "3.0": V3_0_to_3_1_worker
};
var DatabaseUpdater = class {
  constructor(_app, _rpgManager, _previousVersion, _currentVersion) {
    this._app = _app;
    this._rpgManager = _rpgManager;
    this._previousVersion = _previousVersion;
    this._currentVersion = _currentVersion;
    this._versionsHistory = /* @__PURE__ */ new Map();
    this._versionsHistory.set("1.2", { previousVersion: "1.2", nextVersion: "1.3" });
    this._versionsHistory.set("1.3", { previousVersion: "1.3", nextVersion: "2.0" });
    this._versionsHistory.set("2.0", { previousVersion: "2.0", nextVersion: "3.0" });
    this._versionsHistory.set("3.0", { previousVersion: "3.0", nextVersion: "3.1" });
  }
  get newVersion() {
    return this._currentVersion;
  }
  get oldVersion() {
    return this._previousVersion;
  }
  requiresDatabaseUpdate() {
    return __async(this, null, function* () {
      if (this._previousVersion === "")
        this._previousVersion = "1.2";
      const previousVersionMajorMinor = this._getMajorMinor(this._previousVersion);
      const currentVersionMajorMinor = this._getMajorMinor(this._currentVersion);
      if (previousVersionMajorMinor === void 0 || currentVersionMajorMinor === void 0 || previousVersionMajorMinor === currentVersionMajorMinor)
        return false;
      if (yield this._isVaultEmptyOfRpgManagerComponents()) {
        const currentVersionMajorMinor2 = this._getMajorMinor(this._currentVersion);
        yield this._rpgManager.updateSettings({ previousVersion: currentVersionMajorMinor2 });
        return false;
      }
      return this._versionsHistory.get(previousVersionMajorMinor) !== void 0;
    });
  }
  update(reporter = void 0) {
    return __async(this, null, function* () {
      let response = false;
      if (this._previousVersion === "")
        this._previousVersion = "1.2";
      const previousVersionMajorMinor = this._getMajorMinor(this._previousVersion);
      const currentVersionMajorMinor = this._getMajorMinor(this._currentVersion);
      if (previousVersionMajorMinor === void 0 || currentVersionMajorMinor === void 0 || previousVersionMajorMinor === currentVersionMajorMinor)
        return false;
      const empty = yield this._isVaultEmptyOfRpgManagerComponents();
      let updater = yield this._versionsHistory.get(previousVersionMajorMinor);
      while (updater !== void 0) {
        response = true;
        if (!empty) {
          const worker = yield new versionMap[updater.previousVersion](this._app);
          if (reporter !== void 0)
            reporter.setUpdater(this._previousVersion, this._currentVersion);
          yield worker.run(reporter);
        }
        updater = yield this._versionsHistory.get(updater.nextVersion);
      }
      yield this._rpgManager.updateSettings({ previousVersion: currentVersionMajorMinor });
      return response;
    });
  }
  _isVaultEmptyOfRpgManagerComponents() {
    return __async(this, null, function* () {
      const everyMarkdown = this._app.vault.getMarkdownFiles();
      for (let index = 0; index < everyMarkdown.length; index++) {
        const cache = this._app.metadataCache.getFileCache(everyMarkdown[index]);
        if (cache === void 0 || (cache == null ? void 0 : cache.sections) == void 0)
          continue;
        const validSections = cache.sections.filter((section) => section.type === "code");
        for (let sectionIndex = 0; sectionIndex < validSections.length; sectionIndex++) {
          const fileContent = yield this._app.vault.read(everyMarkdown[index]);
          const fileArray = fileContent.split("\n");
          if (fileArray[validSections[sectionIndex].position.start.line].startsWith("```RpgManager"))
            return false;
        }
      }
      return true;
    });
  }
  _getMajorMinor(version) {
    const versionParts = version.split(".");
    if (versionParts.length < 2)
      return void 0;
    return versionParts[0] + "." + versionParts[1];
  }
};

// src/views/ReleaseNoteView.ts
var import_obsidian37 = require("obsidian");

// src/fetchers/ReleaseNoteFetcher.ts
var ReleaseNoteFetcher = class extends AbstractFetcher {
  constructor() {
    super(...arguments);
    this.fetchUrl = "https://raw.githubusercontent.com/carlonicora/obsidian-rpg-manager/master/ChangeLog.md";
  }
  fetchMarkdown() {
    return __async(this, null, function* () {
      const apiResponse = yield fetch(this.fetchUrl);
      if (apiResponse === void 0)
        return void 0;
      const response = yield apiResponse.text();
      return response;
    });
  }
};

// src/views/ReleaseNoteView.ts
var ReleaseNoteView = class extends AbstractRpgManagerView {
  constructor() {
    super(...arguments);
    this.viewType = "rpgm-release-note-view" /* ReleaseNote */.toString();
    this.displayText = "RPG Manager Release Notes";
    this.icon = "d20";
  }
  initialise(params) {
  }
  render() {
    return __async(this, null, function* () {
      this.rpgmContentEl.empty();
      const fetcher = yield this.factories.fetchers.create(ReleaseNoteFetcher);
      const releaseNotes = yield fetcher.fetchMarkdown();
      if (releaseNotes != null) {
        import_obsidian37.MarkdownRenderer.renderMarkdown(releaseNotes, this.rpgmContentEl, "", null);
      }
      const closeButtonEl = this.contentEl.createEl("button", { text: "Close the release notes" });
      closeButtonEl.addEventListener("click", () => {
        this.app.workspace.detachLeavesOfType("rpgm-release-note-view" /* ReleaseNote */.toString());
      });
    });
  }
};

// src/views/RPGManagerView.ts
var import_obsidian38 = require("obsidian");
var RPGManagerView = class extends AbstractRpgManagerView {
  constructor() {
    super(...arguments);
    this.viewType = "rpgm-creator-view" /* RPGManager */.toString();
    this.displayText = "RPG Manager";
    this.icon = "d20";
  }
  onResize() {
    super.onResize();
    this.initialise([]);
    this.render();
  }
  initialise(params) {
    super.initialise([]);
    const campaigns = this.database.read((campaign) => campaign.id.type === 1 /* Campaign */);
    this._hasCampaigns = campaigns.length > 0;
    if (campaigns.length === 1) {
      this._currentCampaign = campaigns[0];
    } else {
      this._currentCampaign = void 0;
    }
    const file = this.app.workspace.getActiveFile();
    if (file != null) {
      this._currentComponent = this.database.readByPath(file.path);
    } else {
      this._currentComponent = void 0;
    }
  }
  render() {
    return __async(this, null, function* () {
      this.rpgmContentEl.removeClass("rpgm-view");
      this.rpgmContentEl.addClass("rpgm-right-view");
      this.rpgmContentEl.empty();
      this._verticalTabHeaderEl = this.rpgmContentEl.createDiv({ cls: "vertical-tab-header" });
      this._verticalTabHeaderEl.createDiv({ cls: "vertical-tab-headers-group-title  title", text: "RPG Manager" });
      this._addCreationLinks();
      this._addIncompleteComponents();
      this._addToDoList();
      this._addReleaseNotes();
      return Promise.resolve(void 0);
    });
  }
  _addIncompleteComponents() {
    return __async(this, null, function* () {
      const groupEl = this._verticalTabHeaderEl.createDiv({ cls: "vertical-tab-headers-group-title" });
      const arrowEl = groupEl.createSpan();
      arrowEl.style.marginRight = "10px";
      (0, import_obsidian38.setIcon)(arrowEl, "openClose");
      const titleEl = groupEl.createSpan({ text: "Incomplete Components" });
      const arrowIconEl = arrowEl.children[0];
      this._incompleteListEl = groupEl.createDiv({ cls: "vertical-tab-headers-group-items" });
      this._incompleteListEl.style.display = "none";
      arrowEl.addEventListener("click", () => {
        if (this._incompleteListEl.style.display === "none") {
          this._incompleteListEl.style.display = "";
          arrowIconEl.style.transform = "rotate(90deg)";
        } else {
          this._incompleteListEl.style.display = "none";
          arrowIconEl.style.transform = "rotate(0deg)";
        }
      });
      titleEl.addEventListener("click", () => {
        if (this._incompleteListEl.style.display === "none") {
          this._incompleteListEl.style.display = "";
          arrowIconEl.style.transform = "rotate(90deg)";
        } else {
          this._incompleteListEl.style.display = "none";
          arrowIconEl.style.transform = "rotate(0deg)";
        }
      });
      this._addIncompleteComponentList();
      this.registerEvent(this.app.workspace.on("rpgmanager:refresh-views", this._addIncompleteComponentList.bind(this)));
    });
  }
  _addIncompleteComponentList() {
    return __async(this, null, function* () {
      this._incompleteListEl.empty();
      const components = this.database.read((component) => component.isComplete === false);
      components.forEach((component) => {
        const itemEl = this._incompleteListEl.createDiv({ cls: "vertical-tab-nav-item", text: component.file.basename });
        itemEl.addEventListener("click", () => {
          this.app.workspace.getLeaf(false).openFile(component.file);
        });
      });
    });
  }
  _addReleaseNotes() {
    return __async(this, null, function* () {
      const groupEl = this._verticalTabHeaderEl.createDiv({ cls: "vertical-tab-headers-group-title", text: "Release Notes" });
      const groupItemEl = groupEl.createDiv({ cls: "vertical-tab-headers-group-items" });
      const itemEl = groupItemEl.createDiv({ cls: "vertical-tab-nav-item", text: "Read Release Notes" });
      itemEl.addEventListener("click", () => {
        this.factories.views.showObsidianView("rpgm-release-note-view" /* ReleaseNote */);
      });
    });
  }
  _addToDoList() {
    const groupEl = this._verticalTabHeaderEl.createDiv({ cls: "vertical-tab-headers-group-title" });
    const arrowEl = groupEl.createSpan();
    arrowEl.style.marginRight = "10px";
    (0, import_obsidian38.setIcon)(arrowEl, "openClose");
    const titleEl = groupEl.createSpan({ text: "To Do List" });
    const arrowIconEl = arrowEl.children[0];
    arrowEl.addEventListener("click", () => {
      if (this._incompleteListEl.style.display === "none") {
        this._incompleteListEl.style.display = "";
        arrowIconEl.style.transform = "rotate(90deg)";
      } else {
        this._incompleteListEl.style.display = "none";
        arrowIconEl.style.transform = "rotate(0deg)";
      }
    });
    titleEl.addEventListener("click", () => {
      if (this._incompleteListEl.style.display === "none") {
        this._incompleteListEl.style.display = "";
        arrowIconEl.style.transform = "rotate(90deg)";
      } else {
        this._incompleteListEl.style.display = "none";
        arrowIconEl.style.transform = "rotate(0deg)";
      }
    });
    const groupItemEl = groupEl.createDiv({ cls: "vertical-tab-headers-group-items" });
    groupItemEl.style.display = "none";
    this._loadToDo(groupItemEl);
  }
  _addCreationLinks() {
    const groupEl = this._verticalTabHeaderEl.createDiv({ cls: "vertical-tab-headers-group-title", text: "Create New Components" });
    const groupItemEl = groupEl.createDiv({ cls: "vertical-tab-headers-group-items" });
    this._createElementListItem(1 /* Campaign */, groupItemEl);
    if (this._hasCampaigns) {
      Object.keys(ComponentType).filter((v) => isNaN(Number(v))).forEach((typeString) => {
        const type = ComponentType[typeString];
        if (type !== 1 /* Campaign */) {
          this._createElementListItem(type, groupItemEl);
        }
      });
    }
  }
  _loadToDo(containerEl) {
    return __async(this, null, function* () {
      const components = this.database.read((component) => true);
      let firstToDoFound = false;
      components.forEach((component) => {
        this.app.vault.read(component.file).then((content) => {
          const contentArray = content.split("\n");
          contentArray.forEach((line) => {
            if (line.trimStart().startsWith("- [ ]")) {
              if (!firstToDoFound) {
                firstToDoFound = true;
                containerEl.empty();
              }
              line = line.replaceAll("- [ ]", "").replaceAll("*", "");
              let finalLine = line;
              while (line.indexOf("[[") !== -1) {
                line = line.substring(line.indexOf("[[") + 2);
                const endLinkIndex = line.indexOf("]]");
                if (endLinkIndex === -1)
                  break;
                const nameAndAlias = line.substring(0, endLinkIndex);
                const aliasIndex = nameAndAlias.indexOf("|");
                if (aliasIndex === -1) {
                  finalLine = finalLine.replaceAll("[[" + nameAndAlias + "]]", nameAndAlias);
                } else {
                  finalLine = finalLine.replaceAll("[[" + nameAndAlias + "]]", nameAndAlias.substring(0, aliasIndex));
                }
              }
              const itemEl = containerEl.createDiv({ cls: "vertical-tab-nav-item", text: finalLine });
              itemEl.addEventListener("click", () => {
                this.app.workspace.getLeaf(false).openFile(component.file);
              });
            }
          });
        });
      });
    });
  }
  _createElementListItem(type, containerEl) {
    const itemEl = containerEl.createDiv({ cls: "vertical-tab-nav-item", text: "Create new " + ComponentType[type] });
    itemEl.addEventListener("click", () => {
      this._openCreationModal(type);
    });
  }
  _openCreationModal(type) {
    var _a, _b, _c, _d;
    let modalOpened = false;
    if (this._currentComponent !== void 0) {
      modalOpened = true;
      new CreationModal(this.app, type, true, null, (_a = this._currentComponent) == null ? void 0 : _a.id.campaignId, (_b = this._currentComponent) == null ? void 0 : _b.id.adventureId, (_c = this._currentComponent) == null ? void 0 : _c.id.actId).open();
    } else if (this._currentCampaign !== void 0) {
      modalOpened = true;
      new CreationModal(this.app, type, true, null, (_d = this._currentCampaign) == null ? void 0 : _d.id.campaignId).open();
    }
    if (!modalOpened) {
      new CreationModal(this.app, type).open();
    }
  }
};

// src/views/TimelineView.ts
var import_obsidian39 = require("obsidian");

// src/responses/ResponseTimelineElement.ts
var ResponseTimelineElement = class {
  constructor(fullDate, date, time, type, synopsis, link) {
    this.fullDate = fullDate;
    this.date = date;
    this.time = time;
    this.type = type;
    this.synopsis = synopsis;
    this.link = link;
  }
};

// src/views/TimelineView.ts
var TimelineView = class extends AbstractRpgManagerView {
  constructor() {
    super(...arguments);
    this.viewType = "rpgm-timeline-view" /* Timeline */.toString();
    this.displayText = "RPG Manager Timeline";
    this.icon = "d20";
  }
  initialise(params) {
    this._campaignId = params[0];
    this._campaign = this.database.readSingle(1 /* Campaign */, this._campaignId);
    super.initialise([]);
    this._elements = [];
    this.database.read((event) => event.id.type === 256 /* Event */ && event.id.campaignId === this._campaignId.id && event.date != null).forEach((event) => {
      var _a;
      if (event.date !== void 0) {
        let time = event.date.toLocaleTimeString();
        time = time.substring(0, time.length - 3);
        this._elements.push(new ResponseTimelineElement(event.date, event.date.toDateString(), time, "event", (_a = event.synopsis) != null ? _a : "", event.file.path));
      }
    });
    this.database.read((clue) => clue.id.type === 512 /* Clue */ && clue.id.campaignId === this._campaignId.id && clue.found != null).forEach((clue) => {
      var _a;
      if (clue.found != null) {
        this._elements.push(new ResponseTimelineElement(clue.found, clue.found.toDateString(), "00:00", "clue", (_a = clue.synopsis) != null ? _a : "", clue.file.path));
      }
    });
    this.database.read((character) => ((32 /* Character */ | 64 /* NonPlayerCharacter */) & character.id.type) === character.id.type && character.id.campaignId === this._campaignId.id && character.death != null).forEach((character) => {
      var _a;
      if (character.death !== void 0) {
        this._elements.push(new ResponseTimelineElement(character.death, character.death.toDateString(), "00:00", "death", (_a = character.synopsis) != null ? _a : "", character.file.path));
      }
    });
    const sessions = this.database.read((session) => 16 /* Session */ === session.id.type && session.id.campaignId === this._campaignId.id);
    sessions.forEach((session) => {
      var _a, _b;
      const scenes = this.database.read((scene) => scene.id.type === 8 /* Scene */ && scene.id.campaignId === this._campaignId.id && scene.id.sessionId === session.id.sessionId && scene.date != null).sort(this.factories.sorter.create([
        new SorterComparisonElement((scene) => scene.date)
      ]));
      const sessionDate = (_a = scenes[0]) == null ? void 0 : _a.date;
      if (sessionDate != null) {
        this._elements.push(new ResponseTimelineElement(sessionDate, sessionDate.toDateString(), "00:00", "session", (_b = session.synopsis) != null ? _b : "", session.file.path));
      }
    });
    this._elements.sort(this.factories.sorter.create([
      new SorterComparisonElement((data) => data.fullDate)
    ]));
  }
  render() {
    return __async(this, null, function* () {
      this.rpgmContentEl.empty();
      if (this._campaign.images.length > 0) {
        const bannerContainer = this.rpgmContentEl.createDiv({ cls: "rpg-container" });
        const header = bannerContainer.createDiv({ cls: "rpgm-header" });
        header.style.backgroundImage = "url('" + this._campaign.images[0].src + "')";
        const overlay = header.createDiv({ cls: "rpgm-header-overlay" });
        overlay.createDiv({ cls: "rpgm-header-title", text: "Timeline" });
        overlay.createDiv({ cls: "rpgm-campaign-name", text: this._campaign.file.basename });
        overlay.createDiv({ cls: "rpgm-current-date", text: this._campaign.date !== void 0 ? this._campaign.date.toDateString() : "" });
      } else {
        this.rpgmContentEl.createEl("h1", { text: this._campaign.file.basename });
      }
      const timelineEl = this.rpgmContentEl.createDiv({ cls: "rpgm-new-timeline" });
      const listEl = timelineEl.createEl("ul");
      this._elements.forEach((timeline) => {
        const itemEl = listEl.createEl("li", { cls: timeline.type });
        const contentEl = itemEl.createDiv({ cls: "content" });
        contentEl.createEl("span", { cls: timeline.type, text: timeline.type.toString() + ": " + timeline.date + (timeline.time !== "00:00" ? " @ " + timeline.time : "") });
        const titleEl = contentEl.createEl("h3");
        const file = this.app.vault.getAbstractFileByPath(timeline.link);
        if (file !== null && file instanceof import_obsidian39.TFile) {
          titleEl.createEl("a", { text: file.basename, href: "#" }).addEventListener("click", () => {
            this.app.workspace.getLeaf(false).openFile(file);
          });
        }
        const descriptionEl = contentEl.createDiv();
        import_obsidian39.MarkdownRenderer.renderMarkdown(timeline.synopsis, descriptionEl, "", null);
        this.updateInternalLinks(descriptionEl);
      });
      return;
    });
  }
};

// src/manipulators/CodeBlockManipulator.ts
var import_obsidian40 = require("obsidian");
var CodeBlockManipulator = class extends AbstractFactory {
  replaceID(file, id) {
    return __async(this, null, function* () {
      var _a;
      const fileEditor = new FileManipulator(this.app, file);
      if (!(yield fileEditor.read()))
        return;
      const metadata = {
        id,
        checksum: Md5.hashStr(id)
      };
      const newIdCodeBlock = [];
      newIdCodeBlock.push("```RpgManagerID");
      newIdCodeBlock.push("### DO NOT EDIT MANUALLY IF NOT INSTRUCTED TO DO SO ###");
      newIdCodeBlock.push(YamlHelper.stringify(metadata));
      newIdCodeBlock.push("```");
      (_a = fileEditor.cachedFile.sections) == null ? void 0 : _a.forEach((section) => {
        if (section.type === "code" && fileEditor.arrayContent[section.position.start.line] === "```RpgManagerID") {
          const replacedArray = fileEditor.arrayContent;
          replacedArray.splice(section.position.start.line, section.position.end.line - section.position.start.line + 1, ...newIdCodeBlock);
          fileEditor.maybeWrite(replacedArray.join("\n")).then(() => {
            DatabaseInitialiser.initialise(this.app).then((database) => {
              this.database = database;
              this.app.workspace.trigger("rpgmanager:force-refresh-views");
            });
          });
        }
      });
    });
  }
  stopCurrentDuration(file) {
    return __async(this, null, function* () {
      const fileEditor = new FileManipulator(this.app, file);
      if (!(yield fileEditor.read()))
        return;
      const metadata = yield fileEditor.getCodeBlockMetadata();
      if (metadata === void 0 || metadata.data.durations === void 0)
        return;
      const durations = metadata.data.durations;
      let endDurationAdded = false;
      for (let index = 0; index < durations.length; index++) {
        if (durations[index].indexOf("-") === -1) {
          endDurationAdded = true;
          const end = Math.floor(Date.now() / 1e3);
          const start = +durations[index];
          durations[index] = durations[index] + "-" + end.toString();
          if (metadata.data.duration === void 0) {
            metadata.data.duration = 0;
          }
          metadata.data.duration += end - start;
          break;
        }
      }
      if (endDurationAdded) {
        yield fileEditor.maybeReplaceCodeBlockMetadata(metadata);
      }
    });
  }
  startNewDuration(file) {
    return __async(this, null, function* () {
      const fileEditor = new FileManipulator(this.app, file);
      if (!(yield fileEditor.read()))
        return;
      let metadata = yield fileEditor.getCodeBlockMetadata();
      if (metadata === void 0) {
        metadata = {
          data: {}
        };
      }
      if (metadata.data.durations === void 0)
        metadata.data.durations = [];
      const durations = metadata.data.durations;
      for (let index = 0; index < durations.length; index++) {
        if (durations[index].indexOf("-") === -1) {
          return;
        }
      }
      durations.push(Math.floor(Date.now() / 1e3).toString());
      yield fileEditor.maybeReplaceCodeBlockMetadata(metadata);
    });
  }
  updateInFile(file, identifier, value) {
    return __async(this, null, function* () {
      const fileEditor = new FileManipulator(this.app, file);
      if (!(yield fileEditor.read()))
        return;
      const metadata = yield fileEditor.getCodeBlockMetadata();
      this._updateYamlElement(metadata, identifier.split("."), value);
      yield fileEditor.maybeReplaceCodeBlockMetadata(metadata);
    });
  }
  update(identifier, value) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const activeView = app.workspace.getActiveViewOfType(import_obsidian40.MarkdownView);
      if (activeView != null) {
        const editor = activeView.editor;
        const file = activeView.file;
        const cache = this.app.metadataCache.getFileCache(file);
        let stringYaml;
        for (let index = 0; index < ((_b = (_a = cache == null ? void 0 : cache.sections) == null ? void 0 : _a.length) != null ? _b : 0); index++) {
          stringYaml = (cache == null ? void 0 : cache.sections) !== void 0 ? cache.sections[index] : void 0;
          if (stringYaml !== void 0 && editor.getLine(stringYaml.position.start.line) === "```RpgManagerData") {
            if (stringYaml === void 0)
              continue;
            const start = { line: stringYaml.position.start.line + 1, ch: 0 };
            const end = { line: stringYaml.position.end.line, ch: 0 };
            const range = editor.getRange(start, end);
            const yaml = (_c = (0, import_obsidian40.parseYaml)(range)) != null ? _c : {};
            this._updateYamlElement(yaml, identifier.split("."), value);
            editor.replaceRange(YamlHelper.stringify(yaml), start, end);
            this.app.vault.modify(file, editor.getValue()).then(() => {
              var _a2;
              (_a2 = this.database.readByPath(file.path)) == null ? void 0 : _a2.touch();
              this.app.workspace.trigger("rpgmanager:force-refresh-views");
            });
            break;
          }
        }
      }
    });
  }
  addOrUpdateRelationship(relationship) {
    return __async(this, null, function* () {
      return this._executeCodeBlockChange(this._addOrUpdateRelationship.bind(this), relationship);
    });
  }
  removeRelationship(path2) {
    return __async(this, null, function* () {
      return this._executeCodeBlockChange(this._removeRelationship.bind(this), path2);
    });
  }
  removeImage(path2) {
    return __async(this, null, function* () {
      return this._executeCodeBlockChange(this._removeImage.bind(this), path2);
    });
  }
  addOrUpdateImage(path2, caption) {
    return __async(this, null, function* () {
      return this._executeCodeBlockChange(this._addOrUpdateImage.bind(this), { path: path2, caption }).then(() => {
        return this.factories.image.create(path2, caption);
      });
    });
  }
  _removeImage(yaml, path2) {
    if (yaml.relationships === void 0)
      return;
    let found;
    for (let index = 0; index < yaml.data.images.length; index++) {
      if (path2 === yaml.data.images[index].path) {
        found = index;
        break;
      }
    }
    if (found !== void 0) {
      yaml.data.images.splice(found, 1);
    }
  }
  _addOrUpdateImage(yaml, image) {
    if (yaml.data === void 0)
      yaml.data = {};
    if (yaml.data.images === void 0)
      yaml.data.images = [];
    let found;
    for (let index = 0; index < yaml.data.images.length; index++) {
      if (image.path === yaml.data.images[index].path) {
        found = index;
        break;
      }
    }
    const metadataImage = {
      path: image.path,
      caption: image.caption
    };
    if (found !== void 0) {
      yaml.data.images.splice(found, 1, metadataImage);
    } else {
      yaml.data.images.push(metadataImage);
    }
  }
  _executeCodeBlockChange(fn, variable) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const activeView = app.workspace.getActiveViewOfType(import_obsidian40.MarkdownView);
      if (activeView != null) {
        const editor = activeView.editor;
        const file = activeView.file;
        const cache = this.app.metadataCache.getFileCache(file);
        let stringYaml;
        for (let index = 0; index < ((_b = (_a = cache == null ? void 0 : cache.sections) == null ? void 0 : _a.length) != null ? _b : 0); index++) {
          stringYaml = (cache == null ? void 0 : cache.sections) !== void 0 ? cache.sections[index] : void 0;
          if (stringYaml !== void 0 && editor.getLine(stringYaml.position.start.line) === "```RpgManagerData") {
            if (stringYaml === void 0)
              continue;
            const start = { line: stringYaml.position.start.line + 1, ch: 0 };
            const end = { line: stringYaml.position.end.line, ch: 0 };
            const range = editor.getRange(start, end);
            const yaml = (_c = (0, import_obsidian40.parseYaml)(range)) != null ? _c : {};
            fn(yaml, variable);
            editor.replaceRange(YamlHelper.stringify(yaml), start, end);
            this.app.vault.modify(file, editor.getValue()).then(() => {
              this.database.onSave(file);
              this.app.workspace.trigger("rpgmanager:force-refresh-views");
            });
            break;
          }
        }
      }
    });
  }
  _addOrUpdateRelationship(yaml, relationship) {
    if (yaml.relationships === void 0)
      yaml.relationships = [];
    let found;
    for (let relationshipsIndex = 0; relationshipsIndex < yaml.relationships.length; relationshipsIndex++) {
      if (relationship.path === yaml.relationships[relationshipsIndex].path) {
        found = relationshipsIndex;
        break;
      }
    }
    if (found !== void 0) {
      yaml.relationships.splice(found, 1);
    }
    const metadataRelationship = {
      type: this.factories.relationshipType.createReadableRelationshipType(relationship.type),
      path: relationship.path,
      description: relationship.description
    };
    yaml.relationships.push(metadataRelationship);
  }
  _removeRelationship(yaml, path2) {
    if (yaml.relationships === void 0)
      return;
    let found;
    for (let relationshipsIndex = 0; relationshipsIndex < yaml.relationships.length; relationshipsIndex++) {
      if (path2 === yaml.relationships[relationshipsIndex].path) {
        found = relationshipsIndex;
        break;
      }
    }
    if (found !== void 0) {
      yaml.relationships.splice(found, 1);
    }
  }
  selectData() {
    var _a;
    const activeView = app.workspace.getActiveViewOfType(import_obsidian40.MarkdownView);
    if (activeView == null)
      return;
    const editor = activeView.editor;
    const file = activeView.file;
    const cache = this.app.metadataCache.getFileCache(file);
    if (cache == null)
      return;
    (_a = cache.sections) == null ? void 0 : _a.forEach((section) => {
      if (section.type === "code" && editor.getLine(section.position.start.line) === "```RpgManagerData") {
        editor.setSelection({ line: section.position.start.line + 1, ch: 0 }, { line: section.position.end.line, ch: 0 });
        editor.focus();
      }
    });
  }
  read(fileManipulator, component) {
    return __async(this, null, function* () {
      return this._addRelationshipsFromContent(fileManipulator.content, this._readMetadata(fileManipulator.content, fileManipulator.cachedFile), component);
    });
  }
  _addRelationshipsFromContent(fileContent, metadata, component) {
    var _a, _b;
    if (metadata.relationships == void 0)
      metadata.relationships = [];
    let content = fileContent;
    let indexOfRelationship = content.indexOf("[[");
    while (indexOfRelationship !== -1) {
      content = content.substring(content.indexOf("[[") + 2);
      const endLinkIndex = content.indexOf("]]");
      if (endLinkIndex === -1)
        break;
      const nameAndAlias = content.substring(0, endLinkIndex);
      const aliasIndex = nameAndAlias.indexOf("|");
      let basename;
      if (aliasIndex === -1) {
        basename = nameAndAlias;
      } else {
        basename = nameAndAlias.substring(0, aliasIndex);
      }
      let path2 = void 0;
      const allFiles = this.app.vault.getMarkdownFiles();
      for (let filesIndex = 0; filesIndex < allFiles.length; filesIndex++) {
        if (allFiles[filesIndex].basename === basename) {
          path2 = allFiles[filesIndex].path;
          break;
        }
      }
      if (path2 !== void 0) {
        let relationshipAlreadyExists = false;
        for (let relationshipsIndex = 0; relationshipsIndex < metadata.relationships.length; relationshipsIndex++) {
          if (metadata.relationships[relationshipsIndex].path === path2) {
            relationshipAlreadyExists = true;
            break;
          }
        }
        if (!relationshipAlreadyExists) {
          let relationship = void 0;
          if (component.stage === 2 /* Run */ || component.stage === 0 /* Plot */) {
            relationship = 4 /* Unidirectional */;
          } else {
            relationship = 2 /* Bidirectional */;
          }
          (_a = metadata.relationships) == null ? void 0 : _a.push({
            type: this.factories.relationshipType.createReadableRelationshipType(relationship),
            path: path2,
            isInContent: true
          });
        }
      } else {
        (_b = metadata.relationships) == null ? void 0 : _b.push({
          type: void 0,
          path: basename,
          isInContent: true
        });
      }
      indexOfRelationship = content.indexOf("[[");
    }
    return metadata;
  }
  _readMetadata(fileContent, fileCacheMetadata) {
    let response = {
      plot: {},
      data: {},
      relationships: []
    };
    const arrayContent = fileContent.split("\n");
    const sections = fileCacheMetadata.sections;
    if (sections !== void 0) {
      for (let index = 0; index < sections.length; index++) {
        const section = sections[index];
        if (section !== void 0) {
          if (section.type === "code") {
            if (arrayContent[section.position.start.line] === "```RpgManagerData") {
              let codeBlockContent = "";
              for (let index2 = section.position.start.line + 1; index2 < arrayContent.length; index2++) {
                if (arrayContent[index2] === "```")
                  break;
                if (arrayContent[index2] !== "")
                  codeBlockContent += arrayContent[index2] + "\n";
              }
              try {
                const newCodeBlockContent = (0, import_obsidian40.parseYaml)(codeBlockContent);
                if (codeBlockContent !== "")
                  response = __spreadValues(__spreadValues({}, response), newCodeBlockContent);
              } catch (e) {
                throw new Error("INVALID YAML");
              }
            }
          }
        }
      }
    }
    return response;
  }
  _updateYamlElement(yaml, key, value) {
    if (key == null || key.length === 0)
      return;
    const initialKeyPart = key.shift();
    if (initialKeyPart === void 0)
      return;
    if (yaml[initialKeyPart] === void 0) {
      yaml[initialKeyPart] = {};
    }
    if (key.length > 0) {
      return this._updateYamlElement(yaml[initialKeyPart], key, value);
    } else {
      yaml[initialKeyPart] = value;
    }
  }
};

// src/manipulators/AllComponentManipulator.ts
var AllComponentManipulator = class extends AbstractFactory {
  updateImagePath(oldPath, newPath) {
    return __async(this, null, function* () {
      return this._updatePath(oldPath, newPath);
    });
  }
  updateRelationshipPath(oldPath, newPath) {
    return __async(this, null, function* () {
      return this._updatePath(oldPath, newPath, this._updateRelationship.bind(this));
    });
  }
  _updateRelationship(file) {
    return __async(this, null, function* () {
      const component = this.database.readByPath(file.path);
      if (component === void 0)
        return;
      component.readMetadata().then(() => {
        component.initialiseRelationships();
      });
    });
  }
  _updatePath(oldPath, newPath, callbackFunction) {
    return __async(this, null, function* () {
      const allFiles = this.app.vault.getMarkdownFiles();
      allFiles.forEach((file) => {
        this.factories.fileManipulator.create(file).then((fileManipulator) => {
          fileManipulator.read().then((isReady) => {
            if (!isReady)
              return;
            if (!fileManipulator.content.contains("path:"))
              return;
            if (!fileManipulator.content.contains(oldPath))
              return;
            const updatedFileContent = fileManipulator.content.replaceAll(oldPath, newPath);
            fileManipulator.maybeWrite(updatedFileContent).then(() => {
              if (callbackFunction !== void 0)
                callbackFunction(file);
            });
          });
        });
      });
    });
  }
};

// src/manipulators/Manipulators.ts
var Manipulators = class extends AbstractRpgManager {
  constructor(app2) {
    super(app2);
    this.codeblock = new CodeBlockManipulator(this.app);
    this.allComponents = new AllComponentManipulator(this.app);
  }
};

// src/modals/UpdaterModal.ts
var import_obsidian41 = require("obsidian");
var UpdaterModal = class extends AbstractRpgManagerModal {
  constructor(app2, _updater) {
    super(app2);
    this._updater = _updater;
    this._currentCounter = 0;
  }
  onOpen() {
    super.onOpen();
    this.contentEl.createEl("h2", { text: "RPG Manager Needs to update the data structure" });
    this._infoEl = this.contentEl.createDiv();
    const infoMessage = "RPG Manager has been updated to version **" + this._updater.newVersion + "**, that requires some updates to the structure of your notes.\n\nThe process is automatic and has been tested, but there is always the possibility for some of your customisations to have escaped what is believed to be the normal structure of the data.\n\n**To avoid any data loss, the update is not automatic, therefore RPG Manager is currently disabled.**\n\nIt is highly recommended you **create a backup copy of your vault** before you run the updater. Once you have performed a backup of your vault, you can update your data with the button below.\n\nIn case of any trouble during the update process, you can [ask for support](https://github.com/carlonicora/obsidian-rpg-manager) directly on RPG Manager GitHubpage.\n\nIf you have backed up your data (*or if you feel like a curious Kender and prefer to live on the edge*) you can run the data update clicking the button below!";
    const waitMessage = "**Updating your data in progress**.\n\nPlease be patient...";
    const successMessage = "The data structure of your notes has been updated to the latest version of RPG Manager\n\nYou can now use the plugin once more. Please don't forget to read the [release notes](https://github.com/carlonicora/obsidian-rpg-manager/blob/master/ChangeLog.md) to know what's new in RPG Manager.\n\n*...oh, and if you like to support or collaborate with us, your help wil be highly appreciated.*";
    this._updateModalDescription(infoMessage);
    const updateButtonEl = this.contentEl.createEl("button", { text: "Update the data to v" + this._updater.newVersion + " or RPG Manager" });
    updateButtonEl.addEventListener("click", () => {
      this._updateModalDescription(waitMessage, true);
      updateButtonEl.remove();
      this._updater.update(this).then(() => {
        this.app.plugins.getPlugin("rpg-manager").initialise();
        this._updateModalDescription(successMessage);
        updateButtonEl.remove();
      });
    });
  }
  _updateModalDescription(content, addCounters = void 0) {
    return __async(this, null, function* () {
      this._infoEl.empty();
      import_obsidian41.MarkdownRenderer.renderMarkdown(content, this._infoEl, "", null);
      if (addCounters) {
        const updaterInfoContainerEl = this._infoEl.createDiv();
        this._versionEl = updaterInfoContainerEl.createDiv({ text: "Updating" });
        const countersContainerEl = updaterInfoContainerEl.createDiv();
        this._currentEl = countersContainerEl.createSpan({ text: "0" });
        countersContainerEl.createSpan({ text: " out of " });
        this._countEl = countersContainerEl.createSpan({ text: "0" });
        countersContainerEl.createSpan({ text: " components updated" });
        this._currentCounter = 0;
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
  setUpdater(startVersion, endVersion) {
    return __async(this, null, function* () {
      if (this._versionEl !== void 0)
        this._versionEl.textContent = "Updating from version " + startVersion + " to " + endVersion;
    });
  }
  setFileCount(count) {
    return __async(this, null, function* () {
      if (this._countEl !== void 0)
        this._countEl.textContent = count.toString();
    });
  }
  addFileUpdated() {
    return __async(this, null, function* () {
      this._currentCounter++;
      if (this._currentEl !== void 0)
        this._currentEl.textContent = this._currentCounter.toString();
    });
  }
};

// src/main.ts
var RpgManager = class extends import_obsidian42.Plugin {
  constructor() {
    super(...arguments);
    this._isVersionUpdated = false;
    this.ready = false;
  }
  onload() {
    return __async(this, null, function* () {
      this.version = this.manifest.version;
      this.factories = yield new Factories(this.app);
      this.manipulators = yield new Manipulators(this.app);
      console.info("Loading RpgManager " + this.manifest.version);
      yield this.loadSettings();
      this.addSettingTab(new RpgManagerSettings(this.app));
      this.tagHelper = yield new TagHelper(this.settings);
      yield (0, import_obsidian42.addIcon)("d20", '<g cx="50" cy="50" r="50" fill="currentColor" g transform="translate(0.000000,0.000000) scale(0.018)" stroke="none"><path d="M1940 4358 l-612 -753 616 -3 c339 -1 893 -1 1232 0 l616 3 -612 753 c-337 413 -616 752 -620 752 -4 0 -283 -339 -620 -752z"/><path d="M1180 4389 c-399 -231 -731 -424 -739 -428 -9 -6 3 -17 40 -38 30 -17 152 -87 271 -156 l217 -126 476 585 c261 321 471 584 467 583 -4 0 -333 -189 -732 -420z"/><path d="M3676 4225 c457 -562 477 -585 498 -572 11 8 133 78 269 157 l249 143 -29 17 c-62 39 -1453 840 -1458 840 -2 0 210 -263 471 -585z"/><path d="M281 2833 c0 -472 4 -849 8 -838 24 58 520 1362 523 1373 3 12 -168 116 -474 291 l-58 32 1 -858z"/><path d="M4571 3536 c-145 -84 -264 -156 -264 -160 -1 -4 118 -320 263 -701 l265 -694 3 430 c1 237 1 621 0 854 l-3 424 -264 -153z"/><path d="M1272 3290 c7 -20 1283 -2229 1288 -2229 5 0 1281 2209 1288 2229 2 7 -451 10 -1288 10 -837 0 -1290 -3 -1288 -10z"/><path d="M1025 3079 c-2 -8 -158 -416 -345 -906 -187 -491 -340 -897 -340 -903 0 -5 4 -10 8 -10 5 0 415 -65 913 -145 497 -80 928 -149 957 -154 l52 -8 -23 41 c-85 150 -1202 2083 -1208 2090 -5 6 -10 3 -14 -5z"/><path d="M3470 2028 c-337 -585 -614 -1066 -616 -1069 -2 -3 7 -4 19 -2 12 2 445 71 962 154 517 82 941 152 943 154 3 2 -1 19 -7 37 -33 93 -675 1774 -681 1781 -4 4 -283 -471 -620 -1055z"/><path d="M955 842 c17 -11 336 -196 710 -412 374 -216 695 -401 713 -412 l32 -20 0 314 0 314 -707 113 c-390 62 -724 115 -743 118 l-35 5 30 -20z"/><path d="M3428 741 l-718 -116 0 -313 0 -314 33 20 c17 11 347 201 732 422 385 222 704 407 710 412 16 14 -22 8 -757 -111z"/></g>');
      yield (0, import_obsidian42.addIcon)("pieEighth", '<g transform="translate(3.000000,3.000000) scale(4.75)"><circle r="10" cx="10" cy="10" fill="transparent" stroke="black" stroke-width="0.5"/><circle r="5" cx="10" cy="10" fill="transparent" stroke="black" stroke-width="10" stroke-dasharray="calc(12.5 * 31.4 / 100) 31.4" transform="rotate(-90) translate(-20)" /></g>');
      yield (0, import_obsidian42.addIcon)("openClose", '<g transform="translate(40.000000,40.000000) scale(0.06)"><path d="M207,990V10L793,500.8L207,990L207,990z"/></g>');
      this.registerView("rpgm-error-view" /* Errors */.toString(), (leaf) => new ErrorView(this.app, leaf));
      this.registerView("rpgm-release-note-view" /* ReleaseNote */.toString(), (leaf) => new ReleaseNoteView(this.app, leaf));
      this.registerView("rpgm-creator-view" /* RPGManager */.toString(), (leaf) => new RPGManagerView(this.app, leaf));
      this.registerView("rpgm-timeline-view" /* Timeline */.toString(), (leaf) => new TimelineView(this.app, leaf));
      this.addRibbonIcon("d20", "RPG Manager", () => {
        this.factories.views.showObsidianView("rpgm-creator-view" /* RPGManager */);
      });
      app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    });
  }
  onLayoutReady() {
    return __async(this, null, function* () {
      this.app.workspace.detachLeavesOfType("rpgm-error-view" /* Errors */.toString());
      this.app.workspace.detachLeavesOfType("rpgm-release-note-view" /* ReleaseNote */.toString());
      this.app.workspace.detachLeavesOfType("rpgm-creator-view" /* RPGManager */.toString());
      this.app.workspace.detachLeavesOfType("rpgm-timeline-view" /* Timeline */.toString());
      let requiresUpdate = false;
      if (this.settings.previousVersion !== this.manifest.version) {
        const databaseUpdater = yield new DatabaseUpdater(this.app, this, this.settings.previousVersion, this.manifest.version);
        if (yield databaseUpdater.requiresDatabaseUpdate()) {
          requiresUpdate = true;
          new UpdaterModal(this.app, databaseUpdater).open();
        }
      }
      if (!requiresUpdate)
        this.initialise();
    });
  }
  initialise() {
    return __async(this, null, function* () {
      this._registerCodeBlock();
      this._registerCommands();
      DatabaseInitialiser.initialise(this.app).then((database) => {
        this.database = database;
        this.factories.logger.info(2 /* Database */, "Database Initialised", this.database);
        this.factories.runningTimeManager.updateMedianTimes(true);
        this._registerEvents();
        this.app.workspace.trigger("rpgmanager:refresh-views");
        this.app.workspace.on("active-leaf-change", (leaf) => {
          if (this.factories.runningTimeManager.isTimerRunning) {
            let isCurrentlyRunningSceneOpen = false;
            this.app.workspace.iterateAllLeaves((leaf2) => {
              var _a;
              if (leaf2.view instanceof import_obsidian42.MarkdownView) {
                const file = (_a = leaf2.view) == null ? void 0 : _a.file;
                if (file !== void 0) {
                  const component = this.database.readByPath(file.path);
                  if (component !== void 0 && component.id.type === 8 /* Scene */ && this.factories.runningTimeManager.isCurrentlyRunningScene(component)) {
                    isCurrentlyRunningSceneOpen = true;
                  }
                }
              }
            });
            if (!isCurrentlyRunningSceneOpen && this.factories.runningTimeManager.currentlyRunningScene !== void 0) {
              this.factories.runningTimeManager.stopScene(this.factories.runningTimeManager.currentlyRunningScene);
            }
          }
        });
        if (this._isVersionUpdated) {
          this.factories.views.showObsidianView("rpgm-release-note-view" /* ReleaseNote */);
        } else {
          this.app.workspace.detachLeavesOfType("rpgm-release-note-view" /* ReleaseNote */.toString());
        }
        return;
      });
    });
  }
  onunload() {
    return __async(this, null, function* () {
      __superGet(RpgManager.prototype, this, "onunload").call(this);
      this.app.workspace.detachLeavesOfType("rpgm-error-view" /* Errors */.toString());
      this.app.workspace.detachLeavesOfType("rpgm-release-note-view" /* ReleaseNote */.toString());
      this.app.workspace.detachLeavesOfType("rpgm-creator-view" /* RPGManager */.toString());
      this.app.workspace.off("resolved", this.refreshViews);
      this.app.workspace.off("modify", this.refreshViews);
    });
  }
  refreshViews() {
    this.app.workspace.trigger("rpgmanager:refresh-views");
  }
  createRpgView(source, el, component, sourcePath) {
    return __async(this, null, function* () {
      component.addChild(new Controller(this.app, el, source, component, sourcePath));
    });
  }
  createRpgDataView(rpgm, el) {
    return __async(this, null, function* () {
      (0, import_obsidian42.setIcon)(el, "d20");
      el.style.cursor = "pointer";
      el.addEventListener("click", () => {
        rpgm.manipulators.codeblock.selectData();
      });
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, rpgManagerDefaultSettings, yield this.loadData());
    });
  }
  updateSettings(settings, partial = true) {
    return __async(this, null, function* () {
      if (partial) {
        Object.assign(this.settings, settings);
      } else {
        this.settings = settings;
      }
      yield this.saveData(this.settings);
    });
  }
  _registerEvents() {
    this.registerEvent(this.app.metadataCache.on("resolved", this.refreshViews.bind(this)));
    this.registerEvent(this.app.workspace.on("file-open", this.refreshViews.bind(this)));
  }
  _registerCodeBlock() {
    this.registerMarkdownCodeBlockProcessor("RpgManager", (source, el, ctx) => __async(this, null, function* () {
      return this.createRpgView(source, el, ctx, ctx.sourcePath);
    }));
    this.registerMarkdownCodeBlockProcessor("RpgManagerData", (source, el, ctx) => __async(this, null, function* () {
      return this.createRpgDataView(this, el);
    }));
    this.registerMarkdownCodeBlockProcessor("RpgManagerID", (source, el, ctx) => __async(this, null, function* () {
    }));
  }
  _registerCommands() {
    Object.keys(ComponentType).filter((v) => isNaN(Number(v))).forEach((type, index) => {
      this.addCommand({
        id: "rpg-manager-create-" + type.toLowerCase(),
        name: "Create a new " + type,
        callback: () => {
          new CreationModal(this.app, ComponentType[type]).open();
        }
      });
      this.addCommand({
        id: "rpg-manager-fill-" + type.toLowerCase(),
        name: "Fill with " + type,
        callback: () => {
          let name = null;
          const activeFile = app.workspace.getActiveFile();
          if (activeFile != null) {
            name = activeFile.basename;
          }
          new CreationModal(this.app, ComponentType[type], false, name).open();
        }
      });
    });
  }
};
