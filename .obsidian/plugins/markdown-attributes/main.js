/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MarkdownAttributes
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/processor.ts
var _Processor = class {
  constructor() {
  }
  static parse(el) {
    if (typeof el == "string") {
      return new _Processor().parseLine(el);
    } else {
      return new _Processor().recurseAndParseElements(el);
    }
  }
  parseLine(text) {
    const elements = [];
    let attribute_strings = text.matchAll(
      new RegExp(_Processor.END_RE.source, "gm")
    );
    for (const [_, match] of attribute_strings) {
      elements.push({
        attributes: this.getAttrs(match),
        text: match
      });
    }
    return elements;
  }
  getTopLevelText(el) {
    const texts = [];
    for (let child of Array.from(el.childNodes)) {
      if (child.nodeType == Node.TEXT_NODE) {
        texts.push(child.data);
      }
    }
    return texts.join("");
  }
  getAttrs(str) {
    const trys = (str != null ? str : "").split(/\s(?=(?:[^'"`]*(['"`])[^'"`]*\1)*[^'"`]*$)/).map((t) => t && t.trim()).filter((t) => t && t !== '"' && t !== "'" && t.length);
    if (!trys || !trys.length)
      return;
    const allowedKeyChars = /[^\t\n\f />"'=]/;
    const keySeparator = "=";
    const classChar = ".";
    const attrs = [];
    for (let pair of trys) {
      if (!pair || !pair.length)
        continue;
      if (pair.charAt(0) === classChar) {
        attrs.push(["class", pair.slice(1)]);
        continue;
      }
      if (new RegExp(keySeparator).test(pair) && allowedKeyChars.test(pair.slice(0, pair.indexOf(keySeparator)))) {
        attrs.push([...pair.split(keySeparator, 2)]);
        continue;
      }
      attrs.push([pair, null]);
    }
    return attrs;
  }
  recurseAndParseElements(el) {
    var _a, _b, _c;
    const elements = [];
    const text = this.getTopLevelText(el);
    if (_Processor.BLOCK_RE.test(text)) {
      let element = el;
      if (el instanceof HTMLLIElement || (el == null ? void 0 : el.parentElement) instanceof HTMLQuoteElement || (el == null ? void 0 : el.hasClass("callout"))) {
        element = el.parentElement;
      }
      let [original, attribute_string] = (_a = text.match(_Processor.BLOCK_RE)) != null ? _a : [];
      const toAdd = {
        element,
        attributes: this.getAttrs(attribute_string),
        text: attribute_string
      };
      elements.push(toAdd);
      el.innerHTML = this.tryToReplace(
        toAdd.element,
        el.innerHTML,
        toAdd.attributes,
        original
      );
      if (el instanceof HTMLLIElement) {
        elements.push(...this.recurseAndParseElements(el));
      }
    } else if (_Processor.BASE_RE.test(text)) {
      let textNode = Array.from(el.childNodes).find(
        (node) => node.nodeType == Node.TEXT_NODE && _Processor.BASE_RE.test(text)
      );
      let sibling = (_b = Array.from(el.children).find(
        (node) => node.nextSibling == textNode
      )) != null ? _b : el;
      if (sibling && sibling.hasClass("collapse-indicator")) {
        sibling = sibling.parentElement;
      }
      if (sibling && sibling instanceof HTMLBRElement) {
        sibling = sibling.parentElement;
      }
      let [original, attribute_string] = (_c = text.match(_Processor.BASE_RE)) != null ? _c : [];
      const toAdd = {
        element: sibling,
        attributes: this.getAttrs(attribute_string),
        text: attribute_string
      };
      elements.push(toAdd);
      textNode.textContent = this.tryToReplace(
        toAdd.element,
        textNode.textContent,
        toAdd.attributes,
        original
      );
    }
    for (let child of Array.from(el.children)) {
      if (!(child instanceof HTMLElement))
        continue;
      if (child instanceof HTMLPreElement || child.tagName.toLowerCase() === "code")
        continue;
      elements.push(...this.recurseAndParseElements(child));
    }
    return elements;
  }
  tryToReplace(element, content, attributes, original) {
    if (!attributes || !attributes.length) {
      return content;
    }
    for (let [key, value] of attributes) {
      if (!key)
        continue;
      if (value)
        value = value.replace(/("|')/g, "");
      try {
        if (key === "class") {
          element.addClasses(value.split(" "));
        } else if (!value) {
          element.setAttr(key, true);
        } else {
          element.setAttr(key, value);
        }
      } catch (e) {
        console.log(
          `Markdown Attributes: ${key} is not a valid attribute.`
        );
        return content;
      }
    }
    return content.replace(original, "");
  }
};
var Processor = _Processor;
__publicField(Processor, "BASE_RE", /\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}/);
__publicField(Processor, "ONLY_RE", /^\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}$/);
__publicField(Processor, "BLOCK_RE", /\n[ ]*\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}[ ]*$/);
__publicField(Processor, "END_RE", /\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}$/m);

// src/live-preview.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");
function selectionAndRangeOverlap(selection, rangeFrom, rangeTo) {
  for (const range of selection.ranges) {
    if (range.from <= rangeTo && range.to >= rangeFrom) {
      return true;
    }
  }
  return false;
}
function inlineRender(view) {
  if (!view.state.field(import_obsidian.editorLivePreviewField)) {
    this.decorations = import_view.Decoration.none;
    return;
  }
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile)
    return;
  const widgets = [];
  const selection = view.state.selection;
  for (const { from, to } of view.visibleRanges) {
    (0, import_language.syntaxTree)(view.state).iterate({
      from,
      to,
      enter: ({ node }) => {
        var _a;
        const type = node.type;
        if (type.name.includes("formatting"))
          return;
        const start = node.from;
        const end = node.to;
        if (selectionAndRangeOverlap(selection, start - 1, end + 1))
          return;
        const original = view.state.doc.sliceString(start, end).trim();
        if (!Processor.END_RE.test(original))
          return;
        const parsed = (_a = Processor.parse(original)) != null ? _a : [];
        for (const item of parsed) {
          const { attributes, text } = item;
          const firstBracket = original.slice(0, original.indexOf(text)).lastIndexOf("{");
          const lastBracket = original.indexOf(
            "}",
            original.indexOf(text)
          );
          widgets.push(
            import_view.Decoration.replace({
              inclusive: false,
              block: false
            }).range(start + firstBracket, start + lastBracket + 1),
            import_view.Decoration.mark({
              inclusive: true,
              attributes: Object.fromEntries(attributes)
            }).range(start, end)
          );
        }
      }
    });
  }
  return import_view.Decoration.set(widgets, true);
}
function inlinePlugin() {
  return import_view.ViewPlugin.fromClass(
    class {
      constructor(view) {
        __publicField(this, "decorations");
        var _a;
        this.decorations = (_a = inlineRender(view)) != null ? _a : import_view.Decoration.none;
      }
      update(update) {
        var _a;
        if (!update.state.field(import_obsidian.editorLivePreviewField)) {
          this.decorations = import_view.Decoration.none;
          return;
        }
        if (update.docChanged || update.viewportChanged || update.selectionSet) {
          this.decorations = (_a = inlineRender(update.view)) != null ? _a : import_view.Decoration.none;
        }
      }
    },
    { decorations: (v) => v.decorations }
  );
}

// src/main.ts
var MarkdownAttributes = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "parsing", /* @__PURE__ */ new Map());
  }
  onload() {
    return __async(this, null, function* () {
      console.log(`Markdown Attributes v${this.manifest.version} loaded.`);
      this.registerMarkdownPostProcessor(this.postprocessor.bind(this));
      this.registerEditorExtension(inlinePlugin());
    });
  }
  postprocessor(topElement, ctx) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const child = topElement.firstElementChild;
      if (!child)
        return;
      let str;
      if (child instanceof HTMLPreElement) {
        if (!ctx.getSectionInfo(topElement))
          return;
        const { lineStart } = ctx.getSectionInfo(topElement);
        const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
        if (!(file instanceof import_obsidian2.TFile))
          return;
        const text = yield this.app.vault.cachedRead(file);
        let source = text.split("\n").slice(lineStart, lineStart + 1);
        str = source.join("\n");
        if (!Processor.BASE_RE.test(str))
          return;
        let [attribute_string] = (_a = str.match(Processor.BASE_RE)) != null ? _a : [];
        child.prepend(new Text(attribute_string));
      }
      if (child instanceof HTMLTableElement || child.hasClass("math") && child.hasClass("math-block") || child.hasClass("callout")) {
        if (!ctx.getSectionInfo(topElement))
          return;
        const { text, lineEnd } = ctx.getSectionInfo(topElement);
        const adjustment = child.hasClass("callout") ? 0 : 1;
        let source = ((_b = text.split("\n").slice(lineEnd + adjustment, lineEnd + adjustment + 1)) != null ? _b : []).shift();
        if (source && source.length && Processor.ONLY_RE.test(source.trim())) {
          let [attribute_string] = (_c = source.match(Processor.ONLY_RE)) != null ? _c : [];
          child.prepend(new Text(attribute_string));
          str = topElement.innerText;
        }
      }
      if (child instanceof HTMLParagraphElement && !child.childElementCount) {
        if (Processor.ONLY_RE.test(child.innerText.trim())) {
          child.detach();
          return;
        }
      }
      if (!Processor.BASE_RE.test(str != null ? str : topElement.innerText))
        return;
      if (!(child instanceof HTMLElement))
        return;
      Processor.parse(child);
    });
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("Markdown Attributes unloaded");
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vR2l0SHViL29ic2lkaWFuLW1hcmtkb3duLWF0dHJpYnV0ZXMvc3JjL21haW4udHMiLCAiLi4vLi4vLi4vLi4vR2l0SHViL29ic2lkaWFuLW1hcmtkb3duLWF0dHJpYnV0ZXMvc3JjL3Byb2Nlc3Nvci50cyIsICIuLi8uLi8uLi8uLi9HaXRIdWIvb2JzaWRpYW4tbWFya2Rvd24tYXR0cmlidXRlcy9zcmMvbGl2ZS1wcmV2aWV3LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0LCBQbHVnaW4sIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgUHJvY2Vzc29yIGZyb20gXCIuL3Byb2Nlc3NvclwiO1xuaW1wb3J0IHsgaW5saW5lUGx1Z2luIH0gZnJvbSBcIi4vbGl2ZS1wcmV2aWV3XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtkb3duQXR0cmlidXRlcyBleHRlbmRzIFBsdWdpbiB7XG4gICAgcGFyc2luZzogTWFwPE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIHN0cmluZz4gPSBuZXcgTWFwKCk7XG4gICAgYXN5bmMgb25sb2FkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgTWFya2Rvd24gQXR0cmlidXRlcyB2JHt0aGlzLm1hbmlmZXN0LnZlcnNpb259IGxvYWRlZC5gKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKHRoaXMucG9zdHByb2Nlc3Nvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihpbmxpbmVQbHVnaW4oKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgcG9zdHByb2Nlc3NvcihcbiAgICAgICAgdG9wRWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dFxuICAgICkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRvcEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpIHJldHVybjtcbiAgICAgICAgbGV0IHN0cjogc3RyaW5nO1xuXG4gICAgICAgIC8qKiBDb2RlIGJsb2NrcyBoYXZlIHRvIGJlIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIE9ic2lkaWFuIGRvZXMgbm90XG4gICAgICAgICAqICBpbmNsdWRlIGFueSB0ZXh0IHBhc3QgdGhlIGxhbmd1YWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgVW5mb3J0dW5hdGVseSB0aGlzIGFsc28gbWVhbnMgdGhhdCBjaGFuZ2VzIHRvIHRoZSBjb2RlIGJsb2NrIGF0dHJpYnV0ZXNcbiAgICAgICAgICogIHJlcXVpcmUgcmVsb2FkaW5nIHRoZSBub3RlIHRvIHRha2UgZWZmZWN0IGJlY2F1c2UgdGhleSBkbyBub3QgdHJpZ2dlciB0aGUgcG9zdHByb2Nlc3Nvci5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxQcmVFbGVtZW50KSB7XG4gICAgICAgICAgICAvKiogSWYgZ2V0U2VjdGlvbkluZm8gcmV0dXJucyBudWxsLCBzdG9wIHByb2Nlc3NpbmcuICovXG4gICAgICAgICAgICBpZiAoIWN0eC5nZXRTZWN0aW9uSW5mbyh0b3BFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvKiogUHVsbCB0aGUgU2VjdGlvbiBkYXRhLiAqL1xuICAgICAgICAgICAgY29uc3QgeyBsaW5lU3RhcnQgfSA9IGN0eC5nZXRTZWN0aW9uSW5mbyh0b3BFbGVtZW50KTtcblxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChjdHguc291cmNlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcblxuICAgICAgICAgICAgLyoqIEdldCB0aGUgc291cmNlIGZvciB0aGlzIGVsZW1lbnQuIE9ubHkgbG9vayBhdCB0aGUgdG9wIGxpbmUgZm9yIGNvZGUgYmxvY2tzLiAqL1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRleHQuc3BsaXQoXCJcXG5cIikuc2xpY2UobGluZVN0YXJ0LCBsaW5lU3RhcnQgKyAxKTtcbiAgICAgICAgICAgIHN0ciA9IHNvdXJjZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgLyoqIFRlc3QgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYXR0cmlidXRlcy4gKi9cbiAgICAgICAgICAgIGlmICghUHJvY2Vzc29yLkJBU0VfUkUudGVzdChzdHIpKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8qKiBQdWxsIHRoZSBtYXRjaGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBjaGlsZCBzbyB0aGUgUHJvY2Vzc29yIGNhdGNoZXMgaXQuICovXG4gICAgICAgICAgICBsZXQgW2F0dHJpYnV0ZV9zdHJpbmddID0gc3RyLm1hdGNoKFByb2Nlc3Nvci5CQVNFX1JFKSA/PyBbXTtcbiAgICAgICAgICAgIGNoaWxkLnByZXBlbmQobmV3IFRleHQoYXR0cmlidXRlX3N0cmluZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhYmxlIGVsZW1lbnRzIGFuZCBNYXRoamF4IGVsZW1lbnRzIHNob3VsZCBjaGVjayB0aGUgbmV4dCBsaW5lIGluIHRoZSBzb3VyY2UgdG8gc2VlIGlmIGl0IGlzIGEgc2luZ2xlIGJsb2NrIGF0dHJpYnV0ZSxcbiAgICAgICAgICogYmVjYXVzZSB0aG9zZSBibG9jayBhdHRyaWJ1dGVzIGFyZSBub3QgYXBwbGllZCB0byB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIEhUTUxUYWJsZUVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjaGlsZC5oYXNDbGFzcyhcIm1hdGhcIikgJiYgY2hpbGQuaGFzQ2xhc3MoXCJtYXRoLWJsb2NrXCIpKSB8fFxuICAgICAgICAgICAgY2hpbGQuaGFzQ2xhc3MoXCJjYWxsb3V0XCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCFjdHguZ2V0U2VjdGlvbkluZm8odG9wRWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICAgICAgLyoqIFB1bGwgdGhlIFNlY3Rpb24gZGF0YS4gKi9cbiAgICAgICAgICAgIGNvbnN0IHsgdGV4dCwgbGluZUVuZCB9ID0gY3R4LmdldFNlY3Rpb25JbmZvKHRvcEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvKiogQ2FsbG91dHMgaW5jbHVkZSB0aGUgYmxvY2sgbGV2ZWwgYXR0cmlidXRlICovXG4gICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gY2hpbGQuaGFzQ2xhc3MoXCJjYWxsb3V0XCIpID8gMCA6IDE7XG5cbiAgICAgICAgICAgIC8qKiBHZXQgdGhlIHNvdXJjZSBmb3IgdGhpcyBlbGVtZW50LiAqL1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IChcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UobGluZUVuZCArIGFkanVzdG1lbnQsIGxpbmVFbmQgKyBhZGp1c3RtZW50ICsgMSkgPz8gW11cbiAgICAgICAgICAgICkuc2hpZnQoKTtcblxuICAgICAgICAgICAgLyoqIFRlc3QgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYXR0cmlidXRlcy4gKi9cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICBzb3VyY2UubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgUHJvY2Vzc29yLk9OTFlfUkUudGVzdChzb3VyY2UudHJpbSgpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLyoqIFB1bGwgdGhlIG1hdGNoZWQgc3RyaW5nIGFuZCBhZGQgaXQgdG8gdGhlIGNoaWxkIHNvIHRoZSBQcm9jZXNzb3IgY2F0Y2hlcyBpdC4gKi9cbiAgICAgICAgICAgICAgICBsZXQgW2F0dHJpYnV0ZV9zdHJpbmddID0gc291cmNlLm1hdGNoKFByb2Nlc3Nvci5PTkxZX1JFKSA/PyBbXTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcmVwZW5kKG5ldyBUZXh0KGF0dHJpYnV0ZV9zdHJpbmcpKTtcblxuICAgICAgICAgICAgICAgIHN0ciA9IHRvcEVsZW1lbnQuaW5uZXJUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBlbGVtZW50IGlzIGEgPHA+IGFuZCB0aGUgdGV4dCBpcyAqb25seSogYW4gYXR0cmlidXRlLCBpdCB3YXMgdXNlZCBhcyBhIGJsb2NrIGF0dHJpYnV0ZVxuICAgICAgICAgKiBhbmQgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MUGFyYWdyYXBoRWxlbWVudCAmJiAhY2hpbGQuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIGlmIChQcm9jZXNzb3IuT05MWV9SRS50ZXN0KGNoaWxkLmlubmVyVGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRlc3QgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYXR0cmlidXRlcy4gKi9cbiAgICAgICAgaWYgKCFQcm9jZXNzb3IuQkFTRV9SRS50ZXN0KHN0ciA/PyB0b3BFbGVtZW50LmlubmVyVGV4dCkpIHJldHVybjtcblxuICAgICAgICAvKiogUGFyc2UgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIFByb2Nlc3Nvci4gKi9cbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgUHJvY2Vzc29yLnBhcnNlKGNoaWxkKTtcbiAgICB9XG5cbiAgICBhc3luYyBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXJrZG93biBBdHRyaWJ1dGVzIHVubG9hZGVkXCIpO1xuICAgIH1cbn1cbiIsICJpbnRlcmZhY2UgRWxlbWVudFdpdGhBdHRyaWJ1dGVzIHtcbiAgICBlbGVtZW50PzogRWxlbWVudDtcbiAgICBhdHRyaWJ1dGVzOiBbc3RyaW5nLCBzdHJpbmddW107XG4gICAgdGV4dDogc3RyaW5nO1xuICAgIC8qIHJlcGxhY2VyOiAoLi4uYXJnczogYW55KSA9PiB2b2lkOyAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9jZXNzb3Ige1xuICAgIHN0YXRpYyBCQVNFX1JFID0gL1xce1xcOj9bIF0qKFteXFx9XFxuIF1bXlxcfVxcbl0qKVsgXSpcXH0vO1xuICAgIHN0YXRpYyBPTkxZX1JFID0gL15cXHtcXDo/WyBdKihbXlxcfVxcbiBdW15cXH1cXG5dKilbIF0qXFx9JC87XG4gICAgc3RhdGljIEJMT0NLX1JFID0gL1xcblsgXSpcXHtcXDo/WyBdKihbXlxcfVxcbiBdW15cXH1cXG5dKilbIF0qXFx9WyBdKiQvO1xuICAgIHN0YXRpYyBFTkRfUkUgPSAvXFx7XFw6P1sgXSooW15cXH1cXG4gXVteXFx9XFxuXSopWyBdKlxcfSQvbTtcblxuICAgIGNvbnN0cnVjdG9yKCkge31cblxuICAgIHN0YXRpYyBwYXJzZShlbDogSFRNTEVsZW1lbnQpOiBFbGVtZW50V2l0aEF0dHJpYnV0ZXNbXTtcbiAgICBzdGF0aWMgcGFyc2UoZWw6IHN0cmluZyk6IEVsZW1lbnRXaXRoQXR0cmlidXRlc1tdO1xuICAgIHN0YXRpYyBwYXJzZShlbDogc3RyaW5nIHwgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NvcigpLnBhcnNlTGluZShlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NvcigpLnJlY3Vyc2VBbmRQYXJzZUVsZW1lbnRzKGVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUxpbmUodGV4dDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzOiBFbGVtZW50V2l0aEF0dHJpYnV0ZXNbXSA9IFtdO1xuICAgICAgICAvLyBQYXJzZSBvdXQgdGhlIGF0dHJpYnV0ZSBzdHJpbmcuXG4gICAgICAgIGxldCBhdHRyaWJ1dGVfc3RyaW5ncyA9IHRleHQubWF0Y2hBbGwoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKFByb2Nlc3Nvci5FTkRfUkUuc291cmNlLCBcImdtXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbXywgbWF0Y2hdIG9mIGF0dHJpYnV0ZV9zdHJpbmdzKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJzKG1hdGNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBtYXRjaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyBhbiBlbGVtZW50cyBjaGlsZCBub2RlcyBhbmQgcmV0dXJucyB0aGUgdGV4dCBjb250ZW50LlxuICAgICAqIEBwYXJhbSBlbCBIVE1MIGVsZW1lbnQgdG8gZ2V0IHRleHQgbm9kZXMgb2YuXG4gICAgICogQHJldHVybnMgVG9wIGxldmVsIHRleHQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRUb3BMZXZlbFRleHQoZWw6IEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgdGV4dHMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0cy5wdXNoKChjaGlsZCBhcyBDaGFyYWN0ZXJEYXRhKS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgc3RyaW5nIGFuZCByZXR1cm4gdGhlIFtrZXksIHZhbHVlXSBhdHRyaWJ1dGUgcGFpcnMuXG4gICAgICogQHBhcmFtIHN0ciBTdHJpbmcgdG8gcHVsbCBhdHRyaWJ1dGVzIGZyb20uXG4gICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IEFycmF5IG9mIFtrZXksIHZhbHVlXSBhdHRyaWJ1dGUgcGFpcnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRBdHRycyhzdHI6IHN0cmluZykge1xuICAgICAgICBjb25zdCB0cnlzID0gKHN0ciA/PyBcIlwiKVxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCBzcGFjZXMgdGhhdCBhcmUgKm5vdCogYmV0d2VlbiBxdW90ZXMuXG4gICAgICAgICAgICAuc3BsaXQoL1xccyg/PSg/OlteJ1wiYF0qKFsnXCJgXSlbXidcImBdKlxcMSkqW14nXCJgXSokKS8pXG4gICAgICAgICAgICAvLyBUcmltIHRoZSByZXN1bHRpbmcgc3RyaW5ncy5cbiAgICAgICAgICAgIC5tYXAoKHQpID0+IHQgJiYgdC50cmltKCkpXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHN0cmluZ3MgdGhhdCBhcmUgdW5kZWZpbmVkLCB6ZXJvIGxlbmd0aCwgb3IganVzdCBhIHF1b3RlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIC5maWx0ZXIoKHQpID0+IHQgJiYgdCAhPT0gJ1wiJyAmJiB0ICE9PSBcIidcIiAmJiB0Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCF0cnlzIHx8ICF0cnlzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFRoZXNlIGNoYXJhY3RlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGluc2lkZSBhbiBhdHRyaWJ1dGUga2V5LlxuICAgICAgICBjb25zdCBhbGxvd2VkS2V5Q2hhcnMgPSAvW15cXHRcXG5cXGYgLz5cIic9XS87XG5cbiAgICAgICAgLy8gezogZGF0YT12YWx1ZSB9XG4gICAgICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IFwiPVwiO1xuICAgICAgICAvLyB7IC5jbGFzcyB9XG4gICAgICAgIGNvbnN0IGNsYXNzQ2hhciA9IFwiLlwiO1xuICAgICAgICAvLyB7ICNpZCB9XG4gICAgICAgIC8vIGN1cnJlbnRseSBub3QgYWxsb3dlZCBkdWUgdG8gT2JzaWRpYW4gdGFnXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgYSB3b3JrYXJvdW5kLlxuICAgICAgICAvKiBjb25zdCBpZENoYXIgPSBcIiNcIjsgKi9cbiAgICAgICAgY29uc3QgYXR0cnM6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgcGFpciBvZiB0cnlzKSB7XG4gICAgICAgICAgICBpZiAoIXBhaXIgfHwgIXBhaXIubGVuZ3RoKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8jaWRcbiAgICAgICAgICAgIC8qIGlmIChwYWlyLmNoYXJBdCgwKSA9PT0gaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChbXCJpZFwiLCBwYWlyLnNsaWNlKDEpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9ICovXG5cbiAgICAgICAgICAgIC8vIC5jbGFzc1xuICAgICAgICAgICAgaWYgKHBhaXIuY2hhckF0KDApID09PSBjbGFzc0NoYXIpIHtcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKFtcImNsYXNzXCIsIHBhaXIuc2xpY2UoMSldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGF0YT12YWx1ZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoa2V5U2VwYXJhdG9yKS50ZXN0KHBhaXIpICYmXG4gICAgICAgICAgICAgICAgYWxsb3dlZEtleUNoYXJzLnRlc3QocGFpci5zbGljZSgwLCBwYWlyLmluZGV4T2Yoa2V5U2VwYXJhdG9yKSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKFsuLi5wYWlyLnNwbGl0KGtleVNlcGFyYXRvciwgMildIGFzIFtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2tlZFxuICAgICAgICAgICAgYXR0cnMucHVzaChbcGFpciwgbnVsbF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbCBIVE1MIGVsZW1lbnQgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge0VsZW1lbnRXaXRoQXR0cmlidXRlc30gRWxlbWVudCwgYXR0cmlidXRlcyB0byBhcHBseSwgb3JpZ2luYWwgbWF0Y2hlZCB0ZXh0LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVjdXJzZUFuZFBhcnNlRWxlbWVudHMoZWw6IEhUTUxFbGVtZW50KTogRWxlbWVudFdpdGhBdHRyaWJ1dGVzW10ge1xuICAgICAgICBjb25zdCBlbGVtZW50czogRWxlbWVudFdpdGhBdHRyaWJ1dGVzW10gPSBbXTtcblxuICAgICAgICAvLyBUZXh0IGNvbnRlbnQgb2YgdGhpcyBub2RlIGFuZCAqbm90KiB0aGUgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRvcExldmVsVGV4dChlbCk7XG5cbiAgICAgICAgaWYgKFByb2Nlc3Nvci5CTE9DS19SRS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIHNob3VsZCBhcHBseSB0byB0aGUgd2hvbGUgYmxvY2suXG5cbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZWw7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MTElFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZWw/LnBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MUXVvdGVFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZWw/Lmhhc0NsYXNzKFwiY2FsbG91dFwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhcHBseSBhdHRyaWJ1dGVzIHRvIGNvbnRhaW5pbmcgVUwgaWYgSFRNTExJRWxlbWVudCBoYXMgYSBibG9jayBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IFtvcmlnaW5hbCwgYXR0cmlidXRlX3N0cmluZ10gPVxuICAgICAgICAgICAgICAgIHRleHQubWF0Y2goUHJvY2Vzc29yLkJMT0NLX1JFKSA/PyBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRvQWRkID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdGhpcy5nZXRBdHRycyhhdHRyaWJ1dGVfc3RyaW5nKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBhdHRyaWJ1dGVfc3RyaW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHRoaXMudHJ5VG9SZXBsYWNlKFxuICAgICAgICAgICAgICAgIHRvQWRkLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgIHRvQWRkLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvKiBlbC5pbm5lckhUTUwgPSBlbC5pbm5lckhUTUwucmVwbGFjZShvcmlnaW5hbCwgXCJcIik7ICovXG5cbiAgICAgICAgICAgIC8vcmVydW4gcGFyc2VyIGlmIExJIGVsZW1lbnQgdG8gZ2V0IGlubGluZXNcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxMSUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKC4uLnRoaXMucmVjdXJzZUFuZFBhcnNlRWxlbWVudHMoZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChQcm9jZXNzb3IuQkFTRV9SRS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIGFyZSBpbmxpbmUuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRleHQgbm9kZXMgdGhhdCBjb250YWlucyB0aGUgYXR0cmlidXRlIHN0cmluZy5cbiAgICAgICAgICAgIGxldCB0ZXh0Tm9kZSA9IEFycmF5LmZyb20oZWwuY2hpbGROb2RlcykuZmluZChcbiAgICAgICAgICAgICAgICAobm9kZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSAmJlxuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzb3IuQkFTRV9SRS50ZXN0KHRleHQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgdGV4dCBub2RlLlxuICAgICAgICAgICAgLy8gdGV4dE5vZGUucHJldmlvdXNTaWJsaW5nIGNvdWxkIHJldHVybiBhbm90aGVyIHRleHQgbm9kZS5cbiAgICAgICAgICAgIC8vIHByZXZpb3VzRWxlbWVudFNpYmxpbmcgZG9lcyBub3QgZXhpc3Rpbmcgb24gYSB0ZXh0IG5vZGUuXG4gICAgICAgICAgICBsZXQgc2libGluZyA9XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZmluZChcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUpID0+IG5vZGUubmV4dFNpYmxpbmcgPT0gdGV4dE5vZGVcbiAgICAgICAgICAgICAgICApID8/IGVsO1xuXG4gICAgICAgICAgICAvLyBDb2xsYXBzaWJsZSBlbGVtZW50cyBhcmUgYSBzcGVjaWFsIGNhc2UgZHVlIHRvIHRoZSBjb2xsYXBzZSBoYW5kbGUuXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLmhhc0NsYXNzKFwiY29sbGFwc2UtaW5kaWNhdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgc2libGluZyA9IHNpYmxpbmcucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZyBpbnN0YW5jZW9mIEhUTUxCUkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gc2libGluZy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJzZSBvdXQgdGhlIGF0dHJpYnV0ZSBzdHJpbmcuXG4gICAgICAgICAgICBsZXQgW29yaWdpbmFsLCBhdHRyaWJ1dGVfc3RyaW5nXSA9XG4gICAgICAgICAgICAgICAgdGV4dC5tYXRjaChQcm9jZXNzb3IuQkFTRV9SRSkgPz8gW107XG5cbiAgICAgICAgICAgIGNvbnN0IHRvQWRkID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHNpYmxpbmcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdGhpcy5nZXRBdHRycyhhdHRyaWJ1dGVfc3RyaW5nKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBhdHRyaWJ1dGVfc3RyaW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRvQWRkKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGUgc3RyaW5nIGZyb20gdGhlIHRleHQgY29udGVudC5cbiAgICAgICAgICAgIHRleHROb2RlLnRleHRDb250ZW50ID0gdGhpcy50cnlUb1JlcGxhY2UoXG4gICAgICAgICAgICAgICAgdG9BZGQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgICB0b0FkZC5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLyogdGV4dE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKG9yaWdpbmFsLCBcIlwiKTsgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50LlxuXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBIVE1MUHJlRWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjb2RlXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goLi4udGhpcy5yZWN1cnNlQW5kUGFyc2VFbGVtZW50cyhjaGlsZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgICB0cnlUb1JlcGxhY2UoXG4gICAgICAgIGVsZW1lbnQ6IEVsZW1lbnQsXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICAgICAgYXR0cmlidXRlczogW3N0cmluZywgc3RyaW5nXVtdLFxuICAgICAgICBvcmlnaW5hbDogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlcyB8fCAhYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICgha2V5KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oXCJ8JykvZywgXCJcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZENsYXNzZXModmFsdWUuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHIoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBgTWFya2Rvd24gQXR0cmlidXRlczogJHtrZXl9IGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZS5gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2Uob3JpZ2luYWwsIFwiXCIpO1xuICAgIH1cbn1cbiIsICIvKlxuICogaW5zcGlyZWQgYW5kIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYmxhY2tzbWl0aGd1L29ic2lkaWFuLWRhdGF2aWV3L2Jsb2IvbWFzdGVyL3NyYy9tYWluLnRzXG4gKlxuICogVGhlIG9yaWdpbmFsIHdvcmsgaXMgTUlULWxpY2Vuc2VkLlxuICpcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIyIGFydGlzdGljYXQxXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiAqL1xuXG5pbXBvcnQge1xuICAgIERlY29yYXRpb24sXG4gICAgRGVjb3JhdGlvblNldCxcbiAgICBFZGl0b3JWaWV3LFxuICAgIFZpZXdQbHVnaW4sXG4gICAgVmlld1VwZGF0ZSxcbiAgICBXaWRnZXRUeXBlXG59IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5pbXBvcnQgeyBFZGl0b3JTZWxlY3Rpb24sIFJhbmdlIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5pbXBvcnQgeyBzeW50YXhUcmVlIH0gZnJvbSBcIkBjb2RlbWlycm9yL2xhbmd1YWdlXCI7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBlZGl0b3JFZGl0b3JGaWVsZCxcbiAgICBlZGl0b3JMaXZlUHJldmlld0ZpZWxkLFxuICAgIGVkaXRvclZpZXdGaWVsZFxufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBQcm9jZXNzb3IgZnJvbSBcIi4vcHJvY2Vzc29yXCI7XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkFuZFJhbmdlT3ZlcmxhcChcbiAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbixcbiAgICByYW5nZUZyb206IG51bWJlcixcbiAgICByYW5nZVRvOiBudW1iZXJcbikge1xuICAgIGZvciAoY29uc3QgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2UuZnJvbSA8PSByYW5nZVRvICYmIHJhbmdlLnRvID49IHJhbmdlRnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIGNsYXNzIElubGluZVdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICByZWFkb25seSBjc3NDbGFzc2VzOiBzdHJpbmdbXSxcbiAgICAgICAgcmVhZG9ubHkgcmF3UXVlcnk6IHN0cmluZyxcbiAgICAgICAgcHJpdmF0ZSBlbDogSFRNTEVsZW1lbnQsXG4gICAgICAgIHByaXZhdGUgdmlldzogRWRpdG9yVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8vIFdpZGdldHMgb25seSBnZXQgdXBkYXRlZCB3aGVuIHRoZSByYXcgcXVlcnkgY2hhbmdlcy90aGUgZWxlbWVudCBnZXRzIGZvY3VzIGFuZCBsb3NlcyBpdFxuICAgIC8vIHRvIHByZXZlbnQgcmVkcmF3cyB3aGVuIHRoZSBlZGl0b3IgdXBkYXRlcy5cbiAgICBlcShvdGhlcjogSW5saW5lV2lkZ2V0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvdGhlci5yYXdRdWVyeSA9PT0gdGhpcy5yYXdRdWVyeSkge1xuICAgICAgICAgICAgLy8gY2hhbmdlIENTUyBjbGFzc2VzIHdpdGhvdXQgcmVkcmF3aW5nIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBvdGhlci5jc3NDbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNzc0NsYXNzZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQ2xhc3ModmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYWRkQ2xhc3ModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQ1NTIGNsYXNzZXMgYW5kIHJldHVybiBIVE1MIGVsZW1lbnQuXG4gICAgLy8gSW4gXCJjb21wbGV4XCIgY2FzZXMgaXQgd2lsbCBnZXQgZmlsbGVkIHdpdGggdGhlIGNvcnJlY3QgdGV4dC9jaGlsZCBlbGVtZW50cyBsYXRlci5cbiAgICB0b0RPTSh2aWV3OiBFZGl0b3JWaWV3KTogSFRNTEVsZW1lbnQge1xuICAgICAgICB0aGlzLmVsLmFkZENsYXNzZXModGhpcy5jc3NDbGFzc2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgfVxuXG4gICAgLyogTWFrZSBxdWVyaWVzIG9ubHkgZWRpdGFibGUgd2hlbiBzaGlmdCBpcyBwcmVzc2VkIChvciBuYXZpZ2F0ZWQgaW5zaWRlIHdpdGggdGhlIGtleWJvYXJkXG4gICAgICogb3IgdGhlIG1vdXNlIGlzIHBsYWNlZCBhdCB0aGUgZW5kLCBidXQgdGhhdCBpcyBhbHdheXMgcG9zc2libGUgcmVnYXJkbGVzcyBvZiB0aGlzIG1ldGhvZCkuXG4gICAgICogTW9zdGx5IHVzZWZ1bCBmb3IgbGlua3MsIGFuZCBtYWtlcyByZXN1bHRzIHNlbGVjdGFibGUuXG4gICAgICogSWYgdGhlIHdpZGdldHMgc2hvdWxkIGFsd2F5cyBiZSBleHBhbmRhYmxlLCBtYWtlIHRoaXMgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgKi9cbi8qIGlnbm9yZUV2ZW50KGV2ZW50OiBNb3VzZUV2ZW50IHwgRXZlbnQpOiBib29sZWFuIHtcbiAgICAgICAgLy8gaW5zdGFuY2VvZiBjaGVjayBkb2VzIG5vdCB3b3JrIGluIHBvcC1vdXQgd2luZG93cywgc28gY2hlY2sgaXQgbGlrZSB0aGlzXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlZG93blwiKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHtcbiAgICAgICAgICAgICAgICB4OiAoZXZlbnQgYXMgTW91c2VFdmVudCkueCxcbiAgICAgICAgICAgICAgICB5OiAoZXZlbnQgYXMgTW91c2VFdmVudCkueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKGV2ZW50IGFzIE1vdXNlRXZlbnQpLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIGVsZW1lbnQgc28gdGhhdCBpdCBkb2Vzbid0IHNlbGVjdCBzdGFydGluZyBmcm9tIHRoZSBsYXN0IGN1cnNvciBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvcykge1xuICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMudmlldy5zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpZWxkKGVkaXRvckVkaXRvckZpZWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0YXRlLmZpZWxkKGVkaXRvclZpZXdGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoZWRpdG9yLm9mZnNldFRvUG9zKGN1cnJlbnRQb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0gKi9cblxuZnVuY3Rpb24gaW5saW5lUmVuZGVyKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgICAvLyBzdGlsbCBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQgZm9yIHRhYmxlcyBhbmQgY2FsbG91dHNcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZWRpdG9yTGl2ZVByZXZpZXdGaWVsZCkpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50RmlsZSA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGlmICghY3VycmVudEZpbGUpIHJldHVybjtcblxuICAgIGNvbnN0IHdpZGdldHM6IFJhbmdlPERlY29yYXRpb24+W10gPSBbXTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAvKiBiZWZvcmU6XG4gICAgICogICAgIGVtIGZvciBpdGFsaWNzXG4gICAgICogICAgIGhpZ2hsaWdodCBmb3IgaGlnaGxpZ2h0XG4gICAgICogYWZ0ZXI6XG4gICAgICogICAgIHN0cm9uZyBmb3IgYm9sZFxuICAgICAqICAgICBzdHJpa2V0aHJvdWdoIGZvciBzdHJpa2V0aHJvdWdoXG4gICAgICovXG4gICAgZm9yIChjb25zdCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgIHN5bnRheFRyZWUodmlldy5zdGF0ZSkuaXRlcmF0ZSh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBlbnRlcjogKHsgbm9kZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgICAgICAvLyBtYXJrZG93biBmb3JtYXR0aW5nIHN5bWJvbHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5uYW1lLmluY2x1ZGVzKFwiZm9ybWF0dGluZ1wiKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHBvc2l0aW9uIG9mIG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IG5vZGUuZnJvbTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBub2RlLnRvO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNvbnRpbnVlIGlmIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGFuZCBpbmxpbmUgY29kZSBub2RlIChpbmNsdWRpbmcgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgIC8vIHN5bWJvbHMpIG92ZXJsYXBcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uQW5kUmFuZ2VPdmVybGFwKHNlbGVjdGlvbiwgc3RhcnQgLSAxLCBlbmQgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhzdGFydCwgZW5kKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFQcm9jZXNzb3IuRU5EX1JFLnRlc3Qob3JpZ2luYWwpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgcXVlcnkgcmVzdWx0IGlzIHByZWRlZmluZWQgdGV4dCAoZS5nLiBpbiB0aGUgY2FzZSBvZiBlcnJvcnMpLCBzZXQgaW5uZXJUZXh0IHRvIGl0LlxuICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgcGFzcyBvbiBhbiBlbXB0eSBlbGVtZW50IGFuZCBmaWxsIGl0IGluIGxhdGVyLlxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Uge0BsaW5rIElubGluZVdpZGdldC50b0RPTX0gaXMgc3luY2hyb25vdXMgYnV0IHNvbWUgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICogYXN5bmNocm9ub3VzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IFByb2Nlc3Nvci5wYXJzZShvcmlnaW5hbCkgPz8gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcywgdGV4dCB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCcmFja2V0ID0gb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBvcmlnaW5hbC5pbmRleE9mKHRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmxhc3RJbmRleE9mKFwie1wiKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0QnJhY2tldCA9IG9yaWdpbmFsLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIn1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLmluZGV4T2YodGV4dClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvKiBjb25zdCBjbGFzc2VzID0gZ2V0Q3NzQ2xhc3Nlcyh0eXBlLm5hbWUpOyAqL1xuICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm47ICovXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogd2lkZ2V0OiBuZXcgSW5saW5lV2lkZ2V0KGNsYXNzZXMsIGNvZGUsIGVsLCB2aWV3KSwgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmFuZ2Uoc3RhcnQgKyBmaXJzdEJyYWNrZXQsIHN0YXJ0ICsgbGFzdEJyYWNrZXQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5mcm9tRW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmFuZ2Uoc3RhcnQsIGVuZClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBEZWNvcmF0aW9uLnNldCh3aWRnZXRzLCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVBsdWdpbigpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgICAgIGNsYXNzIHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGlubGluZVJlbmRlcih2aWV3KSA/PyBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFjdGl2YXRlIGluIExQIGFuZCBub3Qgc291cmNlIG1vZGVcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5zdGF0ZS5maWVsZChlZGl0b3JMaXZlUHJldmlld0ZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLmRvY0NoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUuc2VsZWN0aW9uU2V0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lUmVuZGVyKHVwZGF0ZS52aWV3KSA/PyBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGRlY29yYXRpb25zOiAodikgPT4gdi5kZWNvcmF0aW9ucyB9XG4gICAgKTtcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQTREOzs7QUNPNUQsSUFBcUIsYUFBckIsTUFBK0I7QUFBQSxFQU0zQixjQUFjO0FBQUEsRUFBQztBQUFBLEVBSWYsT0FBTyxNQUFNLElBQTBCO0FBQ25DLFFBQUksT0FBTyxNQUFNLFVBQVU7QUFDdkIsYUFBTyxJQUFJLFdBQVUsRUFBRSxVQUFVLEVBQUU7QUFBQSxJQUN2QyxPQUFPO0FBQ0gsYUFBTyxJQUFJLFdBQVUsRUFBRSx3QkFBd0IsRUFBRTtBQUFBLElBQ3JEO0FBQUEsRUFDSjtBQUFBLEVBQ0EsVUFBVSxNQUFjO0FBQ3BCLFVB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
